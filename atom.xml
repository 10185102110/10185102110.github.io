<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生孰来</title>
  
  
  <link href="http://10185102110.github.io/atom.xml" rel="self"/>
  
  <link href="http://10185102110.github.io/"/>
  <updated>2021-08-28T03:35:48.371Z</updated>
  <id>http://10185102110.github.io/</id>
  
  <author>
    <name>Ave Bai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot相关原理</title>
    <link href="http://10185102110.github.io/2021/08/17/SpringBoot%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"/>
    <id>http://10185102110.github.io/2021/08/17/SpringBoot%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-17T07:53:37.000Z</published>
    <updated>2021-08-28T03:35:48.371Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring Web MVC 是一种基于 Java 的轻量级 Web 框架，使用 MVC架构模式的思想将 web 层进行职责解耦，基于请求驱动即使用请求-响应模型，框架的目的就是帮助我们简化开发。</p><p>Spring MVC 主要由前端控制器(DispatcherServlet)、处理器映射(HandlerMapping)、控制器(Controller)、视图解析器(ViewResolver)、视图组成。</p><p>Spring 的 Web MVC 框架提供了模型 - 视图 - 控制器架构：</p><ul><li><strong>模型（Model ）</strong>封装了应用程序的数据和一般他们会组成的 POJO。</li><li><strong>视图（View）</strong>是负责呈现模型数据和一般它生成的 HTML 输出，客户端的浏览器能够解释。</li><li><strong>控制器（Controller ）</strong>负责处理用户的请求，并建立适当的模型，并把它传递给视图渲染。</li></ul><h2 id="Spring-MVC-运行原理"><a href="#Spring-MVC-运行原理" class="headerlink" title="Spring MVC 运行原理"></a>Spring MVC 运行原理</h2><p><img src="mvc1.png" alt=""></p><p>$(1)$ HTTP请求：客户端请求提交到 DispatcherServlet。<br>$(2)$ 寻找处理器：由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的 Controller。<br>$(3)$ 调用处理器：DispatcherServlet 将请求提交到 Controller。<br>$(4)$ 调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。<br>$(5)$ 处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图。<br>$(6)$ HTTP 响应：视图负责将结果显示到客户端。</p><h2 id="Spring-MVC-接口"><a href="#Spring-MVC-接口" class="headerlink" title="Spring MVC 接口"></a>Spring MVC 接口</h2><ol><li>DispatcherServlet 接口：<br>Spring 提供的前端控制器，所有的请求都有经过它来统一分发。在 DispatcherServlet 将请求分发给 Controller 之前，需要借助 Spring 提供的 HandlerMapping 定位到具体的 Controller。</li><li>HandlerMapping 接口：<br>能够完成客户请求到 Controller 的映射。</li><li>Controller 接口：<br>需要为并发用户处理上述请求，因此实现 Controller 接口时，必须保证线程安全并且可重用。<br>Controller 将处理用户请求，并返回 ModelAndView 对象给 DispatcherServlet 前端控制器。ModelAndView 类对象包含模型和视图。</li><li>ViewResolver 接口：<br>Spring 提供的视图解析器，在 Web 应用中查找 View 对象，从而将相应结果渲染给客户。</li></ol><h2 id="自动配置源码分析与实例"><a href="#自动配置源码分析与实例" class="headerlink" title="自动配置源码分析与实例"></a>自动配置源码分析与实例</h2><p>除了装载 DispatcherServlet 外，Spring Boot 还做了如下默认配置：</p><ul><li>自动配置视图解析器；</li><li>静态资源文件处理；</li><li>自动注册大量的转换器和格式化器；</li><li>提供 HttpMessageConverter 对请求参数和返回结果进行处理；</li><li>自动注册 MessageCodeResolver；</li><li>默认欢迎页配置；</li><li>favicon 自动配置；</li><li>可配置的 Web 初始化绑定器。</li></ul><p>以上自动配置都是在 WebMvcAutoConfiguration 自动配置类中操作的。</p><h3 id="WebMvcAutoConfiguration自动配置类"><a href="#WebMvcAutoConfiguration自动配置类" class="headerlink" title="WebMvcAutoConfiguration自动配置类"></a>WebMvcAutoConfiguration自动配置类</h3><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定该类为配置类</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 当前应用是Servlet Web应用时该配置类才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(</span></span><br><span class="line"><span class="meta">    type = Type.SERVLET</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 判断当前classpath是否存在Servlet类、DispatcherServlet类和WebMvcConfigurer类，存在则生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span></span><br><span class="line"><span class="comment">// 判断IOC容器中是否存在WebMvcConfigurationSupport类型的Bean，不存在则生效</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)</span></span><br><span class="line"><span class="comment">// 类的加载顺序，数值越小越优先加载</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(-2147483638)</span></span><br><span class="line"><span class="comment">// 自动配置的生效时间在这三个自动配置类之后</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上源码可知 WebMvcAutoConfiguration 自动配置类的自动配置触发条件。</p><h3 id="ViewResolver视图解析器"><a href="#ViewResolver视图解析器" class="headerlink" title="ViewResolver视图解析器"></a>ViewResolver视图解析器</h3><p>Spring MVC 中的 Controller 控制器可以返回各种各样的视图，比如 JSP、JSON、Velocity、FreeMarker、Thymeleaf、HTML 字符流等。这些视图的解析需要各种视图解析器，视图解析器的作用就是将逻辑视图转为物理视图，所有的视图解析器都必须实现 ViewResolver 接口。开发者可以设置一个视图解析器或混用多个视图解析器并指定优先顺序，Spring MVC 会按照视图解析器的优先顺序对逻辑视图进行解析，直到解析成功并返回视图对象，否则抛出异常。</p><p>WebMvcAutoConfiguration 的子类 WebMvcAutoConfigurationAdapter 中，在前置条件满足的情况下自动配置类会向 IOC 容器中注册三个视图解析器，分别是 InternalResourceViewResolver、BeanNameViewResolver 和 ContentNegotiatingViewResolver。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span>, <span class="title">ServletContextAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="comment">// 如果没有，就在IOC容器中注册一个InternalResourceViewResolver类型的Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> InternalResourceViewResolver <span class="title">defaultViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">            resolver.setPrefix(<span class="keyword">this</span>.mvcProperties.getView().getPrefix());</span><br><span class="line">            resolver.setSuffix(<span class="keyword">this</span>.mvcProperties.getView().getSuffix());</span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean(&#123;View.class&#125;)</span></span><br><span class="line">        <span class="comment">// IOC容器中存在View.class</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="comment">// 满足上一个条件时，如果没有，就在IOC容器中注册一个BeanNameViewResolver类型的Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BeanNameViewResolver <span class="title">beanNameViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BeanNameViewResolver resolver = <span class="keyword">new</span> BeanNameViewResolver();</span><br><span class="line">            resolver.setOrder(<span class="number">2147483637</span>);</span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean(&#123;ViewResolver.class&#125;)</span></span><br><span class="line">        <span class="comment">// IOC容器中存在ViewResolver.class</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">            name = &#123;&quot;viewResolver&quot;&#125;,</span></span><br><span class="line"><span class="meta">            value = &#123;ContentNegotiatingViewResolver.class&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">        <span class="comment">// 满足上一个条件时，如果IOC容器中没有名称为ViewResolver且类型为ContentNegotiatingViewResolver类的Bean，就向容器中注册一个</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ContentNegotiatingViewResolver <span class="title">viewResolver</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">            ContentNegotiatingViewResolver resolver = <span class="keyword">new</span> ContentNegotiatingViewResolver();</span><br><span class="line">            resolver.setContentNegotiationManager((ContentNegotiationManager)beanFactory.getBean(ContentNegotiationManager.class));</span><br><span class="line">            resolver.setOrder(-<span class="number">2147483648</span>);</span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>InternalResourceViewResolver：通过设置前缀、后缀和控制器中的方法来返回视图名的字符串，从而得到实际视图内容。</p><p>BeanNameViewResolver：在控制器中，一个方法的返回值的字符串会根据 BeanNameViewResolver 查找 Bean 的名称并为返回字符串的 View 渲染视图。</p><p>ContentNegotiatingViewResolver：特殊的视图解析器，它不会为自己处理视图，而是委派给其他视图解析器来处理不同的视图，级别最高。</p><p>Spring Boot 的自动配置机制会直接在项目启动过程中将视图解析器注册到 IOC 容器中，当然，如果开发者不想使用默认的配置策略，也可以自行添加视图解析器到 IOC 容器中。</p><h3 id="Converter、Formatter类型转换器"><a href="#Converter、Formatter类型转换器" class="headerlink" title="Converter、Formatter类型转换器"></a>Converter、Formatter类型转换器</h3><p>在 WebMvcAutoConfigurationAdapter 内部类中含有 <code>addFormatters()</code> 方法，该方法会向 FormatterRegistry 添加 IOC 容器中拥有的 Converter、GenericConverter、Formatter 类型的 Bean。</p><p> <code>addFormatters()</code> 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">    ApplicationConversionService.addBeans(registry, <span class="keyword">this</span>.beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 <code>ApplicationConversionService.addBeans()</code> 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBeans</span><span class="params">(FormatterRegistry registry, ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Set&lt;Object&gt; beans = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(GenericConverter.class).values());</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(Converter.class).values());</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(Printer.class).values());</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(Parser.class).values());</span><br><span class="line">    Iterator var3 = beans.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        Object bean = var3.next();</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> GenericConverter) &#123;</span><br><span class="line">            registry.addConverter((GenericConverter)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Converter) &#123;</span><br><span class="line">            registry.addConverter((Converter)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Formatter) &#123;</span><br><span class="line">            registry.addFormatter((Formatter)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Printer) &#123;</span><br><span class="line">            registry.addPrinter((Printer)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Parser) &#123;</span><br><span class="line">            registry.addParser((Parser)bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单类型转换的案例：</p><p>在 Controller 包中新建 TestController 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test/type/conversion&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">typeConversionTest</span><span class="params">(String name,<span class="keyword">float</span> weight,<span class="keyword">int</span> type,Boolean onSale)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;weight:&quot;</span>+weight);</span><br><span class="line">        System.out.println(<span class="string">&quot;type:&quot;</span>+type);</span><br><span class="line">        System.out.println(<span class="string">&quot;onSale:&quot;</span>+onSale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 Spring Boot 项目，在浏览器中输入 <a href="http://localhost:8080/test/type/conversion?name=iPhoneX&amp;weight=174.5&amp;type=1&amp;onSale=true">http://localhost:8080/test/type/conversion?name=iPhoneX&amp;weight=174.5&amp;type=1&amp;onSale=true</a> ，查看控制台的打印结果：</p><p><img src="1.png" alt=""></p><p>HTTP 请求传递的数据都是字符串 String 类型的，而类型转换方法可以将其转换成其他数据类型。</p><h3 id="HttpMessageConverter消息转换器"><a href="#HttpMessageConverter消息转换器" class="headerlink" title="HttpMessageConverter消息转换器"></a>HttpMessageConverter消息转换器</h3><p> HttpMessageConverter 的设置也是通过 WebMvcAutoConfigurationAdapter 完成的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConvertersProvider.ifAvailable((customConverters) -&gt; &#123;</span><br><span class="line">        converters.addAll(customConverters.getConverters());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Spring MVC 开发 Web 项目时，@RequestBody、@ResponseBody 注解用来进行请求实体的转换和响应结果的格式化输出。以 JSON 数据为例，前者的作用是将请求中的数据解析成 JOSN 并绑定为实体对象，后者的作用是将响应结果以 JSON 格式返回给请求发起者。两者结合起来就是 HttpMessageConverter 的作用。</p><p>举个例子，在项目中新建 entity 包并定义一个实体类 SaleGoods，然后通过 @RequestBody、@ResponseBody 注解进行参数的读取和响应，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleGoods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String goodsName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">private</span> Boolean onSale;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGoodsName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goodsName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsName</span><span class="params">(String goodsName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goodsName = goodsName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">float</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getOnSale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onSale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnSale</span><span class="params">(Boolean onSale)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onSale = onSale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SaleGoods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;,goodsName=&#x27;&quot;</span> + goodsName +<span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;,weight=&#x27;&quot;</span> + weight +</span><br><span class="line">                <span class="string">&quot;,type=&#x27;&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;,onSale=&#x27;&quot;</span> + onSale + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TestController 类中添加 <code>httpMessageConverterTest()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test/httpmessageconverter&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SaleGoods <span class="title">httpMessageConverterTest</span><span class="params">(<span class="meta">@RequestBody</span> SaleGoods saleGoods)</span></span>&#123;</span><br><span class="line">    System.out.println(saleGoods.toString());</span><br><span class="line">    saleGoods.setType(saleGoods.getType() + <span class="number">1</span>);</span><br><span class="line">    saleGoods.setGoodsName(<span class="string">&quot;商品名:&quot;</span> + saleGoods.getGoodsName());</span><br><span class="line">    <span class="keyword">return</span> saleGoods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码作用是拿到封装好的 SaleGoods 对象，进行简单的修改后，最后将对象数据返回。</p><p>由于这里是 POST 请求，使用 Postman 软件模拟请求：</p><p><img src="2.png" alt=""></p><p>同时控制台输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SaleGoods&#123;id=1,goodsName=&#x27;Spring Boot&#x27;,weight=&#x27;10.5,type=&#x27;2,onSale=&#x27;true&#125;</span><br></pre></td></tr></table></figure><p>消息转换器使得对象数据的读取不仅简单而且正确，响应时也不用自行封装工具类。</p><h3 id="静态资源的映射规则"><a href="#静态资源的映射规则" class="headerlink" title="静态资源的映射规则"></a>静态资源的映射规则</h3><p>这部分配置依然是 WebMvcAutoConfigurationAdapter 内部类完成的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// webjars文件访问配置</span></span><br><span class="line">        <span class="keyword">this</span>.addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态资源映射配置</span></span><br><span class="line">        <span class="keyword">this</span>.addResourceHandler(registry, <span class="keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">            registration.addResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ServletContextResource resource = <span class="keyword">new</span> ServletContextResource(<span class="keyword">this</span>.servletContext, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                registration.addResourceLocations(<span class="keyword">new</span> Resource[]&#123;resource&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态资源的映射是在 <code>addResourceHandler()</code> 方法中配置的，StaticPathPattern 的值为 “/**”，表示访问当前项目的任何资源，只要没有匹配的处理映射，则都去静态资源的文件夹找映射。实际的静态资源存放目录通过 <code>getStaticLocations()</code> 方法获取，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] staticLocations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> addMappings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> customized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebProperties.Resources.Chain chain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebProperties.Resources.Cache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">        <span class="keyword">this</span>.addMappings = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.customized = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.chain = <span class="keyword">new</span> WebProperties.Resources.Chain();</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> WebProperties.Resources.Cache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStaticLocations() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.staticLocations;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，Spring Boot 默认的静态资源处理目录为：”classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“。开发 Web 项目时只需要包含这几个目录中的一个或者多个，并将静态资源文件放入其中即可。</p><p>为验证该配置，在类路径下分别创建 public 目录、resources 目录、static 目录，并分别在三个文件夹中放入静态文件，如图所示：</p><p><img src="3.png" alt=""></p><p>重启 Spring Boot，打开浏览器分别进行请求：</p><p><img src="4.png" alt=""></p><p><img src="5.png" alt=""></p><p><img src="6.png" alt=""></p><p><img src="7.png" alt=""></p><p>可见静态资源虽然在不同的目录中，但都能被正确返回，这就是 Spring Boot 对静态资源的拦截处理。</p><p>开发者也可以在配置文件 application.properties 中修改拦截地址和静态资源目录。</p><h3 id="welcomePage-和-favicon-配置"><a href="#welcomePage-和-favicon-配置" class="headerlink" title="welcomePage 和 favicon 配置"></a>welcomePage 和 favicon 配置</h3><p>welcomePage 即默认欢迎页面，配置源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext,FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">    WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),<span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">    welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">    <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getWelcomePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String location : <span class="keyword">this</span>.resourceProperties.getStaticLocations()) &#123;</span><br><span class="line">        Resource indexHtml = getIndexHtml(location);</span><br><span class="line">        <span class="keyword">if</span> (indexHtml != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> indexHtml;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ServletContext servletContext = getServletContext();</span><br><span class="line">    <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getIndexHtml(<span class="keyword">new</span> ServletContextResource(servletContext, SERVLET_LOCATION));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getIndexHtml</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getIndexHtml(<span class="keyword">this</span>.resourceLoader.getResource(location));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getIndexHtml</span><span class="params">(Resource location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Resource resource = location.createRelative(<span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource.exists() &amp;&amp; (resource.getURL() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行 Web MVC 自动配置时程序会向 IOC 容器注册一个 WelcomePageHandlerMapping 类型的 Bean，即默认欢迎页面，其路径为静态资源目录下的 index.html 文件。</p><p>在 /static/ 目录下添加 index.html 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>welcome page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    这里是默认欢迎页</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启项目，再访问 <a href="http://localhost:8080/">http://localhost:8080/</a> ，效果如下：</p><p><img src="8.png" alt=""></p><p>favicon 即网页图标，Spring Boot 2.2 版本之后不提供默认 favicon 图标，开发者可以自定义配置。只要将 favicon 文件放入静态资源目录然后重启项目即可。</p><p><img src="9.png" alt=""></p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot 就是一个 Java web 的开发框架。</p><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>习惯优于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p><p>主要优点：</p><ul><li>可以快速创建独立运行的 Spring 项目</li><li>拥有大量的自动配置</li><li>starter 自动依赖与版本控制</li><li>使用嵌入式的  Servlet 容器</li></ul><h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><p>convention over configuration ，意为惯例优先原则。约定优于配置不是说不需要配置，它其实是一种开发原则，目的是在一定限度内减少需要开发人员手动配置的工作量，用默认的配置达到开发人员的需求。</p><p>比如在项目中加入 spring-boot-starter-web 后，Spring Boot 会自动导入 Spring MVC 的相关依赖和一个内置的 Tomcat 容器。在导入 spring-boot-starter-web 后，就表示开发人员与 Spring Boot 之间约定当前项目是一个 Web 项目，进一步约定开发人员会使用 Spring MVC，从而自动装配 DispatchServlet 到 IOC 容器中。同理，在项目中加入 jdbc-starter 后就表示开发人员与 Spring Boot 之间约定会对数据库进行操作，Spring Boot 会自动导入 JDBC 相关的依赖并配置一个数据源对象供开发人员调用。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>打开 pom.xml 文件，可以看到一个 parent 属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该项目依赖父项目：spring-boot-starter-parent，按住 Ctrl 键并点击 spring-boot-starter-parent，进入 spring-boot-starter-parent-2.5.3.pom 文件，部分源码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Parent pom providing dependency and plugin management for applications built with Maven<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource.delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">resource.delimiter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该文件仅仅定义了 JDK 所需版本为 1.8、项目的默认编码 UTF-8 和 Maven 项目编译设置，并且它也依赖一个父项目：spring-boot-dependencies。</p><p>进入 spring-boot-dependencies-2.5.3.pom 文件中，部分源码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Boot Dependencies<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://spring.io/projects/spring-boot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache License, Version 2.0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://www.apache.org/licenses/LICENSE-2.0<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pivotal<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">email</span>&gt;</span>info@pivotal.io<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organization</span>&gt;</span>Pivotal Software, Inc.<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>https://www.spring.io<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/spring-projects/spring-boot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.2<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.90<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.17.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">awaitility.version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">awaitility.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build-helper-maven-plugin.version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">build-helper-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">byte-buddy.version</span>&gt;</span>1.10.22<span class="tag">&lt;/<span class="name">byte-buddy.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caffeine.version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">caffeine.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cassandra-driver.version</span>&gt;</span>4.11.2<span class="tag">&lt;/<span class="name">cassandra-driver.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classmate.version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">classmate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该文件定义了大量依赖信息，如 commons 相关依赖、log 相关依赖、数据库相关依赖、Spring 相关依赖、ElasticSearch 搜索引擎相关依赖、消息队列相关依赖等。这就是 Spring Boot 项目依赖的版本管理中心。版本管理中心默认配置好大部分依赖的版本信息，这些版本信息随着 Spring Boot 版本的更新而更改。这种设计让开发者导入依赖包时不需要写版本号，但如果不是 dependencies 中默认管理的依赖，就需要声明版本号。</p><p>结合 Spring Boot 约定优于配置的特性，可以这样理解：Spring Boot 为开发者设置了默认编码、默认 JDK 版本及 Maven 编译的默认设置，同时维护了一套项目依赖的配置，相关依赖可以直接导入，并不需要声明版本号。这就是 Spring Boot 与开发者之间的约定，如果认可这个约定就可以减少一些基本配置和依赖配置；如果不认可也可以自行配置，这些配置会覆盖默认配置。</p><p>在 pom.xml 文件中还有一个 spring-boot-starter-web，即在创建项目时选择的 Web 模块。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开 spring-boot-starter-web-2.5.3.pom 文件，可以发现 Spring MVC 所需的依赖和内置的 Tomcat 依赖都已经定义在文件中，这就是为什么仅仅在 pom.xml 文件中加入 spring-boot-starter-web 场景启动器就可以进行 Web 项目的开发。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SpringBootApplication-注解分析"><a href="#SpringBootApplication-注解分析" class="headerlink" title="@SpringBootApplication 注解分析"></a>@SpringBootApplication 注解分析</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p><code>@SpringBootApplication</code> 标注在一个主程序类上，说明这是一个 Spring Boot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动Spring应用</span></span><br><span class="line">        SpringApplication.run(MallApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按住 Ctrl 并点击  <code>@SpringBootApplication</code>，查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>@SpringBootApplication</code> 注解是一个复合注解，前面四个是 Java 元注解：</p><ul><li>@Target({ElementType.TYPE})：类、接口和 enum 声明；</li><li>@Retention(RetentionPolicy.RUNTIME)：运行时注解；</li><li>@Documented：将注解添加到 Java doc 中；</li><li>@Inherited：允许继承。</li></ul><p>重要的是后面三个注解：</p><ul><li>@SpringBootConfiguration：Spring Boot 配置注解；</li><li>@EnableAutoConfiguration：启动自动配置注解；</li><li>@ComponentScan：组件自动扫描注解。</li></ul><p>Java 元注解并无特殊意义，因此如果主程序中不使用 <code>@SpringBootApplication</code> 注解，也可以替换成后三个注解，效果是一样的。</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>表示某个类是一个 Spring Boot 的配置类。</p><p>查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Configuration 注解主要用于定义配置类，替代 XML 配置文件。</p><p> @SpringBootConfiguration 注解仅仅是对 @Configuration 注解进行了包装，本质上依然是 @Configuration 注解。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>表示开启自动配置功能。自动配置是“约定大于配置”设计思想的主要体现， 而 @EnableAutoConfiguration 注解是这个功能的入口。</p><p>查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 AutoConfigurationImportSelector 这个类注册到 Spring 的 IOC容器中，AutoConfigurationImportSelector 可以帮助 Spring Boot 应用将所有符合条件的 @Configuration 配置都加载到当前 Spring Boot 使用的 IOC 容器中。</p><h3 id="AutoConfigurationImportSelector-class"><a href="#AutoConfigurationImportSelector-class" class="headerlink" title="AutoConfigurationImportSelector.class"></a>AutoConfigurationImportSelector.class</h3><p>该类是整个自动配置的核心实现，它负责把返回自动配置的相关组件名称注册到 IOC 容器中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">// 获取自动装配配置项</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            <span class="comment">// 获取停用配置项</span></span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            <span class="comment">// 移除停用配置项</span></span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="comment">// 返回所有的自动装配配置</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Group&gt; getImportGroup() &#123;</span><br><span class="line">        <span class="keyword">return</span> AutoConfigurationImportSelector.AutoConfigurationGroup.class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否开启自动配置，默认为true</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass() == AutoConfigurationImportSelector.class ? (Boolean)<span class="keyword">this</span>.getEnvironment().getProperty(<span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>, Boolean.class, <span class="keyword">true</span>) : <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AnnotationAttributes <span class="title">getAttributes</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        String name = <span class="keyword">this</span>.getAnnotationClass().getName();</span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, <span class="keyword">true</span>));</span><br><span class="line">        Assert.notNull(attributes, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;No auto-configuration attributes found. Is &quot;</span> + metadata.getClassName() + <span class="string">&quot; annotated with &quot;</span> + ClassUtils.getShortName(name) + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getAnnotationClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中 <code>getCandidateConfigurations</code> 方法会调用 <code>SpringFactoriesLoader.loadFactoryNames</code> 获取所有自动配置类的类名。SpringFactoriesLoader 类源码此处省略。</p><p>从源码可以看出：Spring Boot 启动时从类路径 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的配置项，过滤后将这些值作为自动配置类导入容器中。</p><p>有哪些自动配置类项？</p><p><img src="0.png" alt=""></p><p>可以查看 spring.factories 文件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Initializers</span></span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section"># Auto Configure</span></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项定义的就是 Spring Boot 默认加载的所有自动配置类。如果 pom.xml 文件没有引入相应的 jar 包和依赖，部分自动配置无法生效。</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>在 Spring IOC 容器中 @Controller、@Service、@Repository、@Component 等注解的默认装配标识是 @ComponentScan 注解。</p><p> @ComponentScan 注解的作用就是让 Spring 容器从对应包下获取需要注册的类，开发者通过注解来定义哪些包需要被自动扫描并装配。Spring 将会在被指定的包及其子包中寻找标注了 @ComponentScan 注解的 Bean 并注册到容器中。</p><h2 id="SpringApplication-启动流程"><a href="#SpringApplication-启动流程" class="headerlink" title="SpringApplication 启动流程"></a>SpringApplication 启动流程</h2><p>Spring Boot 项目通过运行启动类中的 run() 方法来启动应用，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先实例化SpringApplication</span></span><br><span class="line">        <span class="keyword">return</span> run(<span class="keyword">new</span> Class[]&#123;primarySource&#125;, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 再执行run()方法</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(primarySources)).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终执行的run()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        <span class="comment">// 代码执行时间监控开启</span></span><br><span class="line">        stopWatch.start();</span><br><span class="line">        DefaultBootstrapContext bootstrapContext = <span class="keyword">this</span>.createBootstrapContext();</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 配置Headless属性，默认为true</span></span><br><span class="line">        <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">        <span class="comment">// 获取SpringApplicationRunListener集合</span></span><br><span class="line">        SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">        <span class="comment">// 调用所有SpringApplicationRunListener对象的starting()方法</span></span><br><span class="line">        listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ApplicationArguments对象</span></span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">            <span class="comment">// 创建Environment对象，加载属性配置</span></span><br><span class="line">            ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">            <span class="comment">// 设置系统参数</span></span><br><span class="line">            <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="comment">// 获取需要打印的Spring Boot Banner</span></span><br><span class="line">            Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">            <span class="comment">// 创建Spring容器ApplicationContext</span></span><br><span class="line">            context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">            context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">            <span class="comment">// 准备容器</span></span><br><span class="line">            <span class="keyword">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="comment">// 刷新容器</span></span><br><span class="line">            <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">            <span class="comment">// 执行容器初始化的后置逻辑</span></span><br><span class="line">            <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            <span class="comment">// 代码执行时间监控结束</span></span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="comment">// 打印Spring Boot的启动时长日志</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发布容器启动事件</span></span><br><span class="line">            listeners.started(context);</span><br><span class="line">            <span class="comment">// 调用启动方法</span></span><br><span class="line">            <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleRunFailure(context, var10, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listeners.running(context);</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleRunFailure(context, var9, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>Spring Boot 项目启动步骤：</strong></p><p>$(1)$ 实例化 SpringApplication 对象。</p><p>SpringApplication 类的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 设置当前应用类型</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 加载ApplicationContextInitializer，配置在META-INF/spring.factories文件中</span></span><br><span class="line">    <span class="keyword">this</span>.bootstrapRegistryInitializers = <span class="keyword">this</span>.getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 加载ApplicationListener</span></span><br><span class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webApplicationType 值的设置是为了获取当前应用的类型，对后续构造容器环境和 Spring 容器的初始化起作用。deduceFromClasspath() 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">WebApplicationType</span> </span>&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    SERVLET,</span><br><span class="line">    REACTIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;javax.servlet.Servlet&quot;</span>, <span class="string">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBMVC_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBFLUX_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JERSEY_INDICATOR_CLASS = <span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>, (ClassLoader)<span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>, (ClassLoader)<span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>, (ClassLoader)<span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> REACTIVE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String[] var0 = SERVLET_INDICATOR_CLASSES;</span><br><span class="line">            <span class="keyword">int</span> var1 = var0.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var1; ++var2) &#123;</span><br><span class="line">                String className = var0[var2];</span><br><span class="line">                <span class="keyword">if</span> (!ClassUtils.isPresent(className, (ClassLoader)<span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NONE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SERVLET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webApplicationType 值有 $3$ 个：</p><ol><li>SERVLET：Servlet 环境；</li><li>REACTIVE：Reactive 环境；</li><li>NONE：非 Web 环境。</li></ol><p>deduceFromClasspath() 方法多次调用 ClassUtils.isPresent() 方法，先判断 webflux 相关类是否存在，存在则认为当前应用为 REACTIVE 类型；不存在则继续判断 SERVLET 相关类是否存在，若存在则当前应用为 SERVLET 类型；不存在则为 NONE 类型。</p><p>$(2)$ 开始执行 <code>run()</code> 方法，代码执行时间的监控开启，Spring Boot 应用启动成功后会打印启动时间。</p><p>$(3)$ 配置 headless 属性，java.awt.headless 是 J2SE 的一种模式，用于在缺失显示屏、鼠标或键盘时的系统配置，默认为 true。作用是没有检测到显示器也能继续执行后续步骤。</p><p>$(4)$ 获取  SpringApplicationRunListeners；</p><p>$(5)$ 回调 SpringApplicationRunListener 对象的 <code>starting()</code> 方法；</p><p>$(6)$ 解析 <code>run()</code> 方法的 args 参数并封装为 DefaultApplicationArguments 类；</p><p>$(7)$ 为当前应用准备一个 Environment 对象，即运行环境；</p><p>$(8)$ 设置系统参数；</p><p>$(9)$ 获取需要打印的 Spring Boot Banner 对象。默认打印在控制台上，Spring Boot 目前支持图片 Banner 和文字 Banner。</p><p>$(10)$ 创建 Spring 容器 ApplicationContext。根据 webApplicationType 决定创建哪种 contextClass。</p><p>$(11)$ 准备 ApplicationContext 实例。至此，主启动类加载完成，容器准备好。</p><p>$(12)$ 刷新容器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="comment">// 注册一个Hook函数，作用是监听JVM在关闭时销毁的IOC容器</span></span><br><span class="line">        shutdownHook.registerApplicationContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.refresh(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先注册一个 Hook 函数，然后调用 refresh() 方法，经过层层调用，最终执行 AbstractApplicationContext 的 refresh() 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化上下文环境</span></span><br><span class="line">        <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">        <span class="comment">// 初始化BeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行BeanFactory的后置处理器</span></span><br><span class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 执行Bean的后置处理器</span></span><br><span class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line">            <span class="comment">// 初始化MessageSource组件</span></span><br><span class="line">            <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">            <span class="comment">// 初始化ApplicationContext事件广播器</span></span><br><span class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">            <span class="keyword">this</span>.onRefresh();</span><br><span class="line">            <span class="comment">// 注册监听器，BeanFactory创建完成</span></span><br><span class="line">            <span class="keyword">this</span>.registerListeners();</span><br><span class="line">            <span class="comment">// 初始化剩余的单例Bean</span></span><br><span class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// 完成容器的创建工作</span></span><br><span class="line">            <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var10) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var10);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.cancelRefresh(var10);</span><br><span class="line">            <span class="keyword">throw</span> var10;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是 Spring Bean 加载的核心，用于刷新整个 Spring 上下文信息，定义加载流程。</p><p>$(13)$ 调用 <code>afterRefresh()</code> 方法，执行 Spring 容器初始化的后置逻辑，默认实现是一个空的方法；</p><p>$(14)$ 代码执行时间的监控停止，知道启动应用花费的时间；</p><p>$(15)$ 发布容器启动事件；</p><p>$(16)$ 在 ApplicationContext 完成启动后，程序会对 ApplicationRunner 和 CommandLineRunner 进行回调处理，查找当前 ApplicationContext 中是否注册有 CommandLineRunner，如果有则遍历执行它们。</p><p>CommandLineRunner 接口的组件会在所有 Spring Beans 初始化之后，SpringApplication.run() 之前执行，一般用于应用程序启动之初的加载数据工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Spring-MVC&quot;&gt;&lt;a href=&quot;#Spring-MVC&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC&quot;&gt;&lt;/a&gt;Spring MVC&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cl</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目的创建</title>
    <link href="http://10185102110.github.io/2021/08/12/SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>http://10185102110.github.io/2021/08/12/SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2021-08-12T13:36:43.000Z</published>
    <updated>2021-08-28T04:49:43.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul><li><p>JDK 1.8.0_301</p><p><img src="sf.png" alt=""></p></li><li><p>Maven 3.8.1</p><p><img src="2[4}FJJ50D{Y@T1QG]D8ZMR.png" alt=""></p><p>由于每次下载新的依赖文件都需要通过外网访问 Maven 中央仓库，所以需要配置国内镜像。</p><p>进入 Maven 安装目录，打开 conf/settings.xml 配置文件，添加阿里云镜像仓库的链接：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.2.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.2.0 http://maven.apache.org/xsd/settings-1.2.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 本地仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D://CS_Software//maven//LocalWare<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 配置阿里云镜像服务器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>IntelliJ IDEA 2021.2 专业版</p><p>IDEA 编辑器自带 Maven 环境，将其设置为自己安装的 Maven 环境。</p><p><img src="D:\blog\source\_posts\Springboot项目的搭建\2.png" alt="2"></p></li></ul><h1 id="创建一个SpringBoot项目"><a href="#创建一个SpringBoot项目" class="headerlink" title="创建一个SpringBoot项目"></a>创建一个SpringBoot项目</h1><p>Spring 官方提供了 Spring Initializr 进行 Spring Boot 项目的初始化，如下图：</p><p><img src="awd.png" alt=""></p><p>添加依赖和 Starter：选择 Spring Web 依赖</p><p><img src="asdd.png" alt=""></p><p>创建完成，等待文件加载完毕</p><p><img src="adsadas.png" alt=""></p><p>src/main/java 表示 Java 程序开发目录，在该目录下进行业务代码的开发。</p><p>该目录下的 HelloWorldApplication 文件是程序主入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.avebai.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序主入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloWorldApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main/resources 表示配置文件目录，主要用于存放静态文件、模板文件和配置文件。</p><p>static 目录用于存放静态资源文件，如 JavaScript 文件、图片、CSS 文件等。</p><p>templates 目录用于存放模板类文件，如 Thymeleaf 文件或 FreeMarker 文件。</p><p>src/main/test 表示测试类文件。</p><p>pom.xml 用于配置项目依赖。</p><p>运行主程序，效果如下图：</p><p><img src="trh.png" alt=""></p><p>可以看到 Tomcat 运行在 $8080$ 端口。</p><p>Tomcat：一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器。</p><p><img src="0.png" alt=""></p><p>该页面是 Spring Boot 项目的默认错误页面，404 错误。</p><h1 id="编写一个Web接口"><a href="#编写一个Web接口" class="headerlink" title="编写一个Web接口"></a>编写一个Web接口</h1><p>在主程序目录新建一个 package，命名为 controller，在 controller 下新建 class，命名为 HelloController。</p><p>实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.avebai.helloworld.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的含义是处理请求为 /hello 的 GET 请求并返回一个字符串。</p><p>运行结果：</p><p><img src="1.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDK 1.8.0_301&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;sf.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>软件测试基础</title>
    <link href="http://10185102110.github.io/2021/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://10185102110.github.io/2021/08/11/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-11T02:44:18.000Z</published>
    <updated>2021-09-20T03:45:51.403Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h2><p>根据 IEEE 的定义，软件由计算机程序、规程、文档和运行所需的数据组成，这些要素构成了软件工程过程中的各种配置。</p><h2 id="软件特征"><a href="#软件特征" class="headerlink" title="软件特征"></a>软件特征</h2><p>（1）软件是逻辑产品，不是物理产品，所以软件具有和硬件完全不同的特征。</p><ul><li>软件是由开发产生，不是用传统方法制造的；</li><li>软件不会像硬件那样有磨损；</li><li>软件不能通过已有构件组装，只能自己定义。</li></ul><p>（2）当前软件分为七大类：</p><ol><li>系统软件</li><li>应用软件</li><li>Web 应用软件</li><li>工程和科学软件</li><li>嵌入式软件</li><li>产品线软件</li><li>人工智能软件</li></ol><p>（3）软件工程是一种层次化技术。</p><ol><li>软件工程的根基在于对质量的关注。</li><li>软件工程的过程层是基础。过程层定义了关键过程区域的框架，确立上下各区域的关系，并规定了采用的技术方法，产生的工程产品，建立里程碑，质量保证以及管理变化。</li><li>软件工程的方法层涵盖一系列任务，如需求分析、设计、编程、测试、维护。</li><li>软件工程的工具层对过程层和方法层提供自动、半自动的支持。</li></ol><p>（4）<strong>软件质量</strong></p><p>生产高质量的软件是我们的首要目标。</p><p>IEEE 关于软件质量的定义：</p><ul><li>系统、部件或者过程满足规定需求的程度。</li><li>系统、部件或者过程满足顾客或者用户需要或期望的程度。</li></ul><p>各类软件综合起来可以看到 $6$ 个主要特征：</p><ol><li>功能性：软件实现的功能达到要求的和隐含的用户需求以及设计规范的程度。</li><li>可靠性：软件在指定条件和特定时间段内维持性能的能力程度。</li><li>易使用性：用户使用该软件所付出的学习精力。</li><li>效率：在指定条件下软件功能与所占资源之间的比值。</li><li>可维护性：当发现错误、运行环境改变或客户需求改变时程序能修改的容易程度。</li><li>可移植性：将软件从一种环境移入另一种环境的容易程度。</li></ol><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>（1）软件测试是保证软件质量的关键步骤，是对软件规格说明、设计和编码的最后复审。</p><p>（2）软件测试工作可以这样概括：</p><ul><li>测试执行、模拟一个系统或者程序的操作；</li><li>测试在于带着发现问题和错误的意图来分析程序；</li><li>测试能够度量程序的功能和质量；</li><li>测试在于评价程序和项目工作产品的属性、能力，并且评估是否获得了期望。</li></ul><p>（3）<strong>软件测试的方法</strong></p><p>软件测试技术可以从不同角度加以分类。</p><p>从是否需要执行被测软件的角度分为静态测试和动态测试；</p><p>从是否针对系统的内部结构和具体实现算法的角度分为白盒测试和黑盒测试。</p><p>1.<strong>静态测试</strong></p><p>静态测试无需执行被测代码，而是借助专用的软件测试工具评审软件文档或程序，度量程序静态复杂度，通过分析或检查源程序的文法、结构、过程、接口等来检查程序的正确性，借以发现程序的不足之处来减少错误概率。</p><p>静态测试包含的内容如下：</p><ul><li>代码检查</li><li>静态结构分析：主要以图形的方式表现程序的内部结构，例如函数调用关系图、函数内部控制流图。</li><li>代码质量度量</li></ul><ol><li><strong>动态测试</strong></li></ol><p>动态测试通过人工或使用工具运行程序，使被测代码在相对真实的环境下运行，从多角度观察程序运行时能体现的功能、逻辑、行为、结构等行为，并通过检查、分析程序的执行状态、程序的外部表现来定位程序的错误。</p><p>动态测试由三部分组成：</p><ul><li>功能确认和接口测试</li><li>覆盖率分析</li><li>性能分析</li></ul><ol><li><strong>黑盒测试</strong></li></ol><p>也称为功能测试，是已知软件所需功能，通过测试来检测每个功能是否都能正常使用。</p><p>黑盒测试方法主要有等价类划分、边值分析、因果图、错误推测等。</p><p>该方法着眼于程序外部结构，不考虑内部逻辑结构，针对软件界面和软件功能进行测试。黑盒测试方法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能查出程序中所有的错误。</p><ol><li><strong>白盒测试</strong></li></ol><p>也称结构测试或逻辑驱动测试，知道软件内部的工作过程，可通过测试来检测软件产品内部的动作是否按照规格说明书的规定正常进行，并且按照程序内部的结构测试程序来检验程序中的每条通路是否都能按照预定要求正确工作，而不考虑功能是否正确。</p><p>白盒测试方法主要有逻辑覆盖、域测试、路径测试、程序插桩、程序变异等。</p><ol><li><strong>灰盒测试</strong></li></ol><p>介于白盒与黑盒之间，关注输出对于输入的正确性，同时也关注内部表现。但这种关注不像白盒那样详细完整，只是通过一些表征性的现象、标志来判断内部的运行状态。</p><p>如果每次都通过白盒测试来操作，效率会很低，所以需要灰盒测试。</p><h1 id="软件测试-1"><a href="#软件测试-1" class="headerlink" title="软件测试"></a>软件测试</h1><p>软件测试的核心是测试数据生成。</p><p>软件测试的实质是根据软件开发各阶段的规格说明和程序的内部结构精心选取一批测试数据，形成测试用例，并用这些测试用例去驱动被测程序，验证所得结果与预期结果是否一致。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>测试是程序的执行过程，目的在于发现错误；</li><li>一个好的测试用例在于能发现至今未发现的错误；</li><li>一个成功的测试用例是发现了至今未发现的错误的测试。</li></ul><p>测试一般不可能发现程序中的所有错误，测试只能证明程序中存在错误，但不能证明程序中不存在错误。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul><li><p>在整个开发过程中要尽早地和不断地进行软件测试。</p><p>不应把软件测试仅仅看作是软件开发的一个独立阶段，而应当贯穿到软件开发的各个阶段中。</p></li><li><p>在开始测试时不应默认程序中不存在错误。</p></li><li><p>在设计测试用例时要给出测试的预期结果。</p><p>一个测试用例必须包括两部分：对程序输入数据的描述和由这些输入数据应产生的输出结果的精确描述。</p></li><li><p>测试工作应避免由开发人员来承担。</p><p>从心理学上讲，让一个人否定自己所做的工作是一件沮丧的事情。另外，如果程序中包含了由于程序员对程序功能的误解而产生的错误，当程序员测试自己的程序时，往往还会带着同样的误解而使错误难以发现。</p></li><li><p>对合理的和不合理的输入数据都要进行测试。</p><p>为了提高程序的可靠性。合理的输入数据可以验证程序的正确性，而不合理的输入数据是指异常的、临界的、可能引起问题异变的输入数据。事实上，用户往往会不遵循合理的输入要求而进行一些非法的输入，如果系统不能对此做出正确反应，系统将很容易产生故障，甚至造成系统瘫痪。</p></li><li><p>重点测试错误群集的程序区段。</p></li><li><p>除检查程序功能是否完备外还要检查程序功能是否有多余。</p></li><li><p>用穷举测试是不可能的。</p></li><li><p>长期完整地保留所有的测试用例和测试文件，直到该软件产品被废弃为止。</p><p>因为测试不是一次完成的，在测试出错误并修改后需要继续测试。另外，以后进行维护时也需要这些测试文件进行后续测试。测试文件包括测试数据集、预期的结果、程序执行的记录等。</p></li></ul><h2 id="软件测试的种类"><a href="#软件测试的种类" class="headerlink" title="软件测试的种类"></a>软件测试的种类</h2><p>在进行软件测试时需要以下 3 类信息：</p><ul><li>软件配置：指需求说明书、设计说明书和源程序等。</li><li>测试配置：指测试方案、测试用例和测试驱动程序等。</li><li>测试工具：指计算机辅助测试的有关工具。</li></ul><p>通常综合测试分为 4 个步骤：</p><ol><li>单元测试（Unit Testing）</li><li>集成测试（Integrated Testing）</li><li>系统测试（System Testing）</li><li>验收测试（Acceptance Testing）</li></ol><p>另外，在所有测试过程中始终贯穿着回归测试（Regression Testing）。</p><p><img src="1.png" alt=""></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单元测试指对软件中的最小可测试单元或基本组成单元进行检查和验证。</p><p>单元测试中选取的单元应可以清晰地与其他单元区分开，在某种意义上，单元的概念已经扩展为组件(Component)。</p><p>一般遵循以下<strong>单元选取原则</strong>：</p><ul><li>对于 C 语言这类面向过程的开发语言来说，单元常指一个函数或子过程。在特殊情况下，如果几个函数具有强耦合性，导致函数关系非常密切，应将这几个函数共同作为一个单元来测试。</li><li>对于 C++、Java 语言或 C# 等面向对象的开发语言来说，单元一般指一个类。然而某些基础类可能非常庞大，涉及大量属性和方法，甚至需要几个开发人员来编码完成，此时的测试应上升到集成测试的层面。</li><li>在图形化软件中，单元常指一个窗体或一个菜单。</li></ul><p>总之，单元是人为规定的最小的被测功能模块。而单元测试则是一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。</p><h3 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h3><ul><li><p>接口测试</p><p>接口测试指对通过被测模块的数据流进行测试检查数据能否正确地输入和输出，主要对模块接口的以下方面进行测试：</p><ul><li>输入的实参与形参在个数、属性、量纲和顺序上是否匹配；</li><li>被测模块调用其他模块时传递的实参与被调用模块的形参是否匹配；</li><li>调用标准函数时传递的实参在个数、属性、量纲和顺序上是否正确；</li><li>是否存在与当前入口点无关的参数引用；</li><li>是否修改了只做输入用的只读形参；</li><li>全局变量在每个模块中的定义是否一致；</li><li>是否将某些约束条件作为形参来传递。</li></ul></li><li><p>局部数据结构测试</p><p>局部数据结构是最常见的缺陷来源，检查局部数据结构可以保证临时存储在模块内的数据在代码执行过程中是正确的和完整的。应考虑以下方面：</p><ul><li>是否存在不正确、不一致的数据类型说明；</li><li>是否存在未初始化或未赋值的错误；</li><li>变量是否存在初始化或默认值错误；</li><li>是否存在变量名拼写或书写错误；</li><li>是否存在不一致的数据类型；</li><li>是否出现上溢、下溢或地址异常。</li></ul></li><li><p>重要执行路径测试</p><p>对重要执行路径和循环的测试是最常用、最有效的测试技术，以发现因错误的计算、错误的比较和不适当的控制流而导致的缺陷。</p><p>常见的错误计算如下：</p><ul><li>操作符优先次序是否被正确理解；</li><li>是否存在混合模式的计算；</li><li>是否存在被零除的风险；</li><li>运算精度不够；</li><li>变量的初值是否正确；</li><li>表达式的符号是否正确。</li></ul><p>常见的比较和控制错误如下：</p><ul><li>是否存在不同数据类型变量之间的比较；</li><li>是否存在错误的逻辑运算符或优先次序；</li><li>是否存在因计算机表示的局限性导致浮点运算精度不够，致使期望值与实际值不相等的两值比较；</li><li>在关系表达式中是否存在错误的变量和比较符；</li><li>是否存在不可能的循环终止条件导致死循环；</li><li>是否存在迭代发散导致不能退出；</li><li>是否错误地修改了循环变量，导致循环次数多一次或少一次。</li></ul></li><li><p>错误处理测试</p><p>完善的设计应能预见各种出错条件，并设置适当的出错处理，以提高系统的容错能力，保证逻辑的正确性。</p><p>应考虑以下方面：</p><ul><li>输出的出错信息是否难以理解；</li><li>出错描述提供的信息是否不足，导致无法对错误进行定位；</li><li>显示的错误是否与实际遇到的缺陷不符合；</li><li>对错误条件的处理是否正确；</li><li>在程序自定义的出错处理运行之前缺陷条件是否已经引起系统干预。</li></ul></li><li><p>边界条件测试</p><p>程序最容易在边界上出错，应注意以下方面：</p><ul><li>输入/输出数据的等价类边界；</li><li>选择条件和循环条件的边界；</li><li>复杂数据结构的边界。</li></ul></li></ul><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>在对模块进行测试时，每个模块在整个软件系统中不是孤立的，不能独立运行，而需要由其他模块来调用和驱动，模块的执行还依赖被它调用的下级模块。因此，为了模拟模块与它周围模块的关系，需要设计辅助测试模块。</p><p>辅助测试模块分为以下两种：</p><ul><li><strong>驱动模块</strong>（Driver）：用来模拟被测模块的上级调用模块，功能比真正的上级模块简单得多，仅仅是接受测试数据，并向被测模块传送测试数据，启动被测模块，回收并输出测试结果。</li><li><strong>桩模块</strong>（Stub）：用来模拟被测模块在执行过程中所要调用的模块，接受被测模块输出的数据并完成它所指派的任务。</li></ul><p>图（a）表示被测软件的结构，图（b）表示用驱动模块和桩模块建立的测试模块 B 的环境。</p><p><img src="2.png" alt=""></p><p>驱动模块和桩模块的编写会给软件开发带来额外开销，而且不必和最终的软件一起提交，因此在保证测试质量的前提下尽量避免开发驱动模块和桩模块。当测试单元较简单时，可以直接与被测模块放在一起执行测试；当测试单元较复杂时，最好利用驱动模块或桩模块构建测试环境运行程序。</p><h3 id="测试技术"><a href="#测试技术" class="headerlink" title="测试技术"></a>测试技术</h3><p>用于单元测试的主要技术如下：</p><ul><li><p>静态测试</p><p>静态测试是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。静态测试的结果可用于进一步的查错，并未测试用例选取提供指导。</p></li><li><p>白盒测试</p><p>白盒测试也称结构测试或逻辑驱动测试，是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p><p>白盒测试的原则如下：</p><p>（1）每条语句至少执行一次；</p><p>（2）每个判定的每个分支至少执行一次；</p><p>（3）每个判定的每个条件应取到各种可能的值；</p><p>（4）每个判定中各条件的每一种组合至少出现一次；</p><p>（5）每一条可能的路径至少执行一次。</p></li><li><p>状态转换测试</p><p>被测单元可能具有多个不同的状态，在某些条件下状态会互相转换。状态转换测试就是要模拟使状态发生转换的各种用户操作场景，以及通过一些非正常技术手段来校验不允许发生的状态转换。</p></li><li><p>功能测试和非功能测试</p><p>功能测试就是对产品的各功能进行验证，根据产品特征、操作描述和用户方案测试一个产品的特性和可操作性行为，以确定它们满足设计需求。</p><p>非功能测试指在必要时对单元的性能（如系统响应时间、外部接口响应时间、CPU 的使用、内存使用的相容性）等方面进行测试。</p></li></ul><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>集成测试是在单元测试的基础上将所有已通过单元测试的模块按照概要设计的要求组装成子系统或系统。</p><p>进行集成测试的目的是确保各单元模块组合在一起能够按照既定意图协作运行，并确保增量的行为正确。不经过单元测试的模块不应该进行集成测试，否则将对集成测试的效果和效率带来巨大的影响。</p><h3 id="测试内容-1"><a href="#测试内容-1" class="headerlink" title="测试内容"></a>测试内容</h3><p>集成测试的内容包括模块之间的接口以及集成后的功能，使用黑盒测试方法测试集成的功能，并对以前的集成进行回归测试。具体来说，集成测试包括以下内容：</p><ul><li>将各模块连接起来时穿越模块接口的数据是否会丢失；</li><li>各子功能组合起来能否达到预期要求的父功能；</li><li>模块的功能是否会对其他模块的功能产生不利影响；</li><li>全局数据结构是否有问题，是否会被异常修改；</li><li>单个模块的误差积累起来是否会放大到不可接受的程度。</li></ul><h3 id="测试方法-1"><a href="#测试方法-1" class="headerlink" title="测试方法"></a>测试方法</h3><ul><li><p>非增量式集成测试方法</p><p>基本思路是首先将各模块独立地进行单元测试，然后把所有模块组装在一起进行测试，最终得到一个符合要求的软件系统。</p><p>这种方法容易出现混乱，因为测试时可能发现一大堆错误，为每个错误进行定位和纠正非常困难，并且改正一个错误同时又可能引入新的错误。</p></li><li><p><strong>增量式集成测试方法</strong></p><p>基本思路是首先将各模块独立地进行单元测试，然后将这些模块逐步组装成较大的系统，边组装边测试，以发现在组装时产生的错误，最终组装成一个符合要求的软件系统。</p><p>按照不同的次序实施，有下面两种测试策略：</p><ul><li><p>自顶向下增量式集成测试</p><p>该测试方法是按照程序结构图，首先利用桩模块测试主模块，通过测试后用实际的模块替代桩模块进行测试，重复以上步骤，直至替代了所有的桩模块。</p><p>在测试过程中，决定模块测试次序的基本原则如下：</p><p>（1）尽早测试关键的模块，即比较重要、比较复杂的可能出错或含有新算法的模块；</p><p>（2）尽早测试包含输入、输出功能的模块。</p></li><li><p>自底向上增量式集成测试</p><p>该测试方法是按照程序结构图，首先利用驱动模块测试最底层模块，通过测试后用实际的模块替代驱动模块进行测试，重复以上步骤，直至替代了所有的驱动模块。</p><p>在测试过程中，决定测试次序的基本原则是该模块的所有下级模块都被测试过了。</p></li></ul></li></ul><p>两种测试方法的比较：</p><div class="table-container"><table><thead><tr><th style="text-align:left">测试方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td style="text-align:left">自顶向下</td><td>（1）如果程序错误趋向于发生在程序的顶端，有利于查出错误。                                （2）可以较早出现程序的轮廓。                                                                                              （3）加进输入/输出模块后较方便描述测试用例。</td><td>（1）桩模块较难设计。                （2）模块介入，使结果较难观察。</td></tr><tr><td style="text-align:left">自底向上</td><td>（1）如果程序错误趋向于发生在程序的底端，有利于查出错误。                           （2）容易产生测试条件和观察测试结果。                                                                        （3）容易编写测试模块。</td><td>（1）在加入最后一个模块之前程序不能作为一个整体存在。                               （2）必须给出驱动程序。</td></tr></tbody></table></div><h3 id="测试技术-1"><a href="#测试技术-1" class="headerlink" title="测试技术"></a>测试技术</h3><p>集成测试主要是测试软件的结构问题，因为测试建立在模块的接口上，所以多为<strong>黑盒测试</strong>，适当辅以白盒测试。</p><p>集成测试一般覆盖的区域包括以下几个：</p><ul><li>从其他关联模块调用一个模块；</li><li>在关联模块间正确传输数据；</li><li>关联模块间的互相影响；</li><li>模块间接口的可靠性。</li></ul><p>执行集合测试应遵循下面的方法：</p><p>（1）确认组成一个完整系统的模块之间的关系；</p><p>（2）评审模块之间的交互、通信需求，确认出模块间的接口；</p><p>（3）使用上述信息产生一套测试用例；</p><p>（4）采用增量式测试，直到所有模块被功能集成进来。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>系统测试是将经过良好的集成测试的软件系统作为整个计算机系统的一部分与计算机硬件、外部设备、支持软件、数据以及人员等其它系统元素结合在一起，在实际使用环境下对计算机系统进行一系列的严格测试，从而发现软件中的潜在缺陷。</p><p>系统测试的最终目的是保证开发人员交付给用户的软件产品能够满足用户的需求，系统测试的测试用例应在实际的用户使用环境下来执行。</p><h3 id="测试内容-2"><a href="#测试内容-2" class="headerlink" title="测试内容"></a>测试内容</h3><p>几类常用的系统测试：</p><ul><li><p>功能测试</p><p>也称确认测试，根据软件需求规格说明书来检验被测系统是否满足用户的功能使用要求。</p><p>功能测试是系统测试中最基本的测试。</p></li><li><p>性能测试</p><p>性能测试检测软件运行时的性能，为记录软件的运行性能，经常需要安装必要的测试仪表或软件。</p></li><li><p>强度测试</p><p>强度测试检查系统能力的最高实际限度，即软件在一些超负荷情况下的运行情况。</p></li><li><p>可靠性测试</p><p>通常使用几个指标来度量系统的可靠性：平均无故障时间是否超过规定的时限、因故障而停机的时间在一年中不应超过多少时间等。</p></li><li><p>恢复测试</p><p>主要目的是检查系统的容错能力，可以采用人工干预方式。如果系统本身能够自动恢复，则应检查重新初始化、数据恢复和重新启动等机制是否正确。</p></li><li><p>安装测试</p><p>目的是找出那些在安装过程中出现的错误，而不是软件故障。</p></li><li><p>安全性测试</p><p>目的在于检查系统对非法入侵的防范能力。</p><p>理论上说没有不可进入的系统，因此系统安全设计的准则是使非法入侵的代价超过被保护信息的价值。</p></li><li><p>配置测试</p><p>操作系统、数据库管理系统以及信息交换系统等都是在许多硬件配置支持下工作的，如何保证软件在其设计和连接的硬件上正常工作是配置测试的工作目标。配置测试是用各种硬件和软件平台以及不同设置检查软件操作的过程，以保证测试的软件可以使用尽可能多的硬件组合。</p></li><li><p>可用性测试</p><p>可用性测试检测用户对所使用软件是否满意，具体体现为操作是否方便、用户界面是否友好等。</p><p>优秀的用户界面包括下面 7 个要素：符合标准和规范、直观性、一致性、灵活性、舒适性、正确性、实用性。</p></li><li><p>兼容性测试</p><p>检测软件之间能否正确地交互和共享信息，它是用其他软件检查软件操作的过程。</p></li><li><p>网站测试</p><p>一般来说包括以下几方面：文字测试、链接测试、图形测试、表单测试、动态内容测试、数据库测试、服务器性能和加载测试、安全性测试。</p></li></ul><h3 id="测试技术-2"><a href="#测试技术-2" class="headerlink" title="测试技术"></a>测试技术</h3><p>完全采用<strong>黑盒测试技术</strong>。</p><h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>验收测试是一种合格性测试，是以用户为主，软件开发人员、实施人员和质量保证人员共同参与的测试。验收测试让软件用户决定是否接受产品，是一项确定产品是否能够满足合同或用户所规定需求的测试。</p><h3 id="测试内容-3"><a href="#测试内容-3" class="headerlink" title="测试内容"></a>测试内容</h3><ul><li>明确规定验收测试通过的标准；</li><li>确定验收测试方法；</li><li>确定验收测试的组织和可利用的资源；</li><li>制订验收测试计划，并进行评审；</li><li>设计验收测试的测试用例；</li><li>执行验收测试；</li><li>分析测试结果，决定是否验收。</li></ul><h3 id="测试技术-3"><a href="#测试技术-3" class="headerlink" title="测试技术"></a>测试技术</h3><p>完全采用<strong>黑盒测试</strong>技术。</p><p>多采用称为 $\alpha,\beta$ 测试的过程。</p><ul><li><p>$\alpha$ 测试</p><p>对一个早期的、不稳定的软件版本你进行验收测试。</p></li><li><p>$\beta$ 测试</p><p>对一个晚期的、更加稳定的软件版本进行验收测试。</p></li></ul><h2 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>回归测试是指修改了旧代码后重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p><p>回归测试作为软件生命周期的组成部分，在整个软件测试过程中占有很大的比重，软件开发的各个阶段都会进行多次回归测试。</p><h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><p>为了高效进行回归测试，需要对测试用例库进行维护，并依据一定的策略，选择相应的回归测试包。</p><ul><li><p>测试用例库的维护</p><p>软件在其生命周期中会频繁地被修改和推出新版本，新版本软件会添加一些新的功能。</p><p>测试用例的维护包括以下方面：</p><p>（1）删除过时的测试用例；</p><p>（2）改进不受控制的测试用例，使其达到可重复和可控制的要求；</p><p>（3）删除冗余的测试用例；</p><p>（4）增添新的测试用例。</p></li><li><p>回归测试包的选择</p><p>软件生命周期中，即使一个得到良好维护的测试用例库也可能变得相当大，所以有时不得不选择一个缩减的回归测试包来完成测试。</p><p>常用的选择回归测试包的方式：</p><ul><li>再测试全部用例：比较安全，但成本最高。</li><li>基于风险选择测试：基于一定的风险标准优先运行最关键的、可疑的测试。</li><li>基于操作剖面选择测试</li><li>再测试修改的部分</li></ul></li></ul><h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><p>（1）识别出软件中被修改的过程；</p><p>（2）从原基线测试用例库 $T$ 中排除所有不再适用的测试用例，建立一个新的基线测试用例库 $T_0$；</p><p>（3）依据一定策略从  $T_0$ 中选择测试用例，测试被修改的软件；</p><p>（4）如果有必要，生成新的测试用例集  $T_1$，用于测试  $T_0$ 无法充分测试的软件部分。</p><h3 id="测试技术-4"><a href="#测试技术-4" class="headerlink" title="测试技术"></a>测试技术</h3><p>一般采用黑盒测试来测试软件的高级需求，也可能采用非功能测试来检查系统的增强或扩展是否影响了系统的性能特性，以及与其它系统间的互操作性和兼容性问题。</p><p>错误猜测在回归测试中是很重要的，主要来自于经验。</p><h2 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h2><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><p>敏捷开发的最大特点是高度迭代，有周期性，并且能够及时、持续地响应客户的频繁反馈。</p><p>敏捷测试即不断修正质量指标，正确建立测试策略，确认客户的有效需求得以实现。</p><p>敏捷测试是遵循敏捷宣言的一种测试实践。</p><p>（1）强调从客户的角度来测试系统；</p><p>（2）重点关注持续迭代地测试新开发的功能；</p><p>（3）尽早开始测试。</p><h3 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h3><p>测试驱动开发（Test-driven development,TDD）是一种软件开发过程中的应用方法，倡导先写测试程序，然后编码实现其功能。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。</p><p>带两顶帽子的开发方式：先戴上实现功能的帽子，在测试的辅助下快速实现其功能；再带上重构的帽子，在测试的保护下去除冗余代码。</p><p>基本思想是在开发功能代码之前先编写测试代码，然后只编写使测试通过的功能代码，从而以测试来驱使整个开发过程的进行。</p><p>测试驱动开发的基本过程如下：</p><p>（1）快速新增一个测试；</p><p>（2）运行所有的测试，发现新增的测试不能通过；</p><p>（3）做一些改动，尽快让测试程序可运行，为此可以在程序中使用一些不合情理的方法；</p><p>（4）运行所有测试，并且全部通过；</p><p>（5）重构代码，消除重复设计，优化设计结构。</p><h1 id="生命周期测试-amp-软件开发模型-amp-软件测试模型"><a href="#生命周期测试-amp-软件开发模型-amp-软件测试模型" class="headerlink" title="生命周期测试 &amp; 软件开发模型 &amp; 软件测试模型"></a>生命周期测试 &amp; 软件开发模型 &amp; 软件测试模型</h1><p><strong>在软件生命周期中，测试过程贯穿于软件开发生命周期的每个阶段。</strong></p><h2 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h2><ul><li>需求分析</li><li>设计</li><li>编码</li><li>测试</li><li>安装</li><li>维护</li></ul><h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。</p><p>理想化的瀑布模型如下：</p><p><img src="https://img-blog.csdnimg.cn/20190725130452991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>这是一种经典模型，提供了软件开发的基本框架，适合需求易于完善定义且不易变更的软件系统。</p><p>实际的瀑布模型是带“反馈环”的，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190725160647424.png" alt="img"></p><p>瀑布模型是文档驱动的模型，遵守这个约束可使软件维护变得容易一些，从而显著降低软件预算。</p><p>优点:</p><ul><li>各阶段划分清晰；</li><li>强调计划与需求分析；</li><li>适合需求稳定的产品开发。</li></ul><p>缺点:</p><ul><li>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；</li><li><p>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，增加了开发的风险；</p></li><li><p>早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果；</p></li><li>最终产品往往反映用户的初始需求而不是最终需求，不适合需求模糊或需求经常变动的系统；</li></ul><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。</p><p>快速原型模型是增量模型的另一种形式，在开发真实系统之前，迅速建造一个可以运行的软件原型 ，以便理解和澄清问题，在该原型的基础上，逐渐完成整个系统的开发工作。</p><p><img src="https://img0.baidu.com/it/u=4002882172,1165672642&amp;fm=26&amp;fmt=auto" alt="img"></p><p>优点：</p><p>克服瀑布模型的切点，减少由于软件需求不明确带来的开发风险，互动性更高更容易了解客户需求。</p><p>缺点：</p><ul><li>所选用的开发技术和工具不一定符合主流的发展 ；</li><li>快速建立起来的系统结构加上连续的修改可能会导致产品质量低下。</li></ul><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。</p><p>把软件产品分解成增量构件时，唯一必须遵守的约束条件是，当把新构件集成到现有构件中时，所形成的产品必须是可测试的。</p><p><img src="https://wiki.mbalib.com/w/images/d/d0/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B.jpg" alt="增量模型"></p><p>适合技术风险较大、用户需求较稳定的软件系统。</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型最大的特点在于引入了其他模型不具备的<strong>风险分析</strong>，使软件在无法排除重大风险时有机会停止，以减小损失。</p><p>螺旋模型是快速原型模型以进化的开发方式为中心，在每个项目阶段使用瀑布模型法。该模型的每一个周期都包括需求定义、风险分析、工程实现和评审 4 个阶段，由这 4 个阶段进行迭代。</p><p>简化的螺旋模型：</p><p><img src="https://img-blog.csdnimg.cn/20190726102921612.png" alt="img"></p><p>适合需求难以获取和确定、软件开发风险较大的软件系统。</p><h2 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h2><h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><p>$V$ 模型是在瀑布模型的基础上发展而来的，如下图所示：</p><p><img src="3.png" alt=""></p><p>在软件编码完成前，系统测试用例、软件测试用例以及单元测试用例已经完成。</p><p>优点：</p><ul><li>$V$ 模型开发流程将代码实现放在最后一步，即使客户需求发生变更也能很快做出修改，相比瀑布模型减少了回溯的成本和时间；</li><li>明确标注了测试过程中存在不同的测试类型，明确表示出了开发阶段与测试各阶段的对应关系。</li></ul><p>缺点：虽然测试尽早的进入到开发阶段，但是真正进行软件测试是在编码之后，这样忽视了测试对需求分析，系统设计的验证，时间效率上也大打折扣。</p><h3 id="W-模型"><a href="#W-模型" class="headerlink" title="W 模型"></a>W 模型</h3><p>又称双 V 模型，它由 V 模型演变而来，弥补了 V 模型的不足。左边的 V 是开发的生命周期，右边的 V 是测试的生命周期。</p><p><img src="https://img0.baidu.com/it/u=3561836809,2244645606&amp;fm=26&amp;fmt=auto" alt="img"></p><p>优点：测试与开发是同步进行的，从而有利于尽早地发现问题。<br>缺点：$W$ 模型是顺序性的，不可逆，需求的变更和调整，依旧不方便。</p><h3 id="H-模型"><a href="#H-模型" class="headerlink" title="H 模型"></a>H 模型</h3><p>在 $H$ 模型中，软件测试过程活动完全独立，贯穿于整个产品的周期，与其他流程并发地进行。</p><p>某个测试点准备就绪时，就可以从测试准备阶段进行到测试执行阶段。</p><p>软件测试可以尽早进行。</p><p><img src="https://img1.baidu.com/it/u=1514273074,3801459989&amp;fm=26&amp;fmt=auto" alt="img"></p><h3 id="X-模型"><a href="#X-模型" class="headerlink" title="X 模型"></a>X 模型</h3><p>$X$ 模型也是对 V 模型的改进。</p><p><img src="4.png" alt=""></p><p>$X$ 模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成，最终成为可执行的程序，然后再对这些可执行程序进行测试。己通过集成测试的成品可以进行封装并提交给用户，也可以作为更大规模和范围内集成的一部分。</p><p>多根并行的曲线表示变更可以在各个部分发生。</p><p>参考资料：</p><p>[1] 秦航，杨强 . 软件质量保证与测试(第 2 版)[M] . 北京：清华大学出版社，2017</p><p>[2] 赖均，陶春梅，刘兆宏，胡峰 . 软件工程[M] . 北京：清华大学出版社，2016</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;什么是软件&quot;&gt;&lt;a href=&quot;#什么是软件&quot; class=&quot;headerlink&quot; title=&quot;什么</summary>
      
    
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://10185102110.github.io/2021/08/11/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://10185102110.github.io/2021/08/11/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-11T02:44:18.000Z</published>
    <updated>2021-09-16T02:27:19.195Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常有小端和大端两种方式。</p><ol><li>小端：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。</li><li>大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。</li></ol><p>Java 语言的字节序是<strong>大端</strong>。</p><h2 id="JDK-与-JRE"><a href="#JDK-与-JRE" class="headerlink" title="JDK 与 JRE"></a>JDK 与 JRE</h2><ol><li>JDK：Java 开发工具包 (Java Development Kit)，提供 Java 的开发环境和运行环境。</li><li>JRE：Java 运行环境 (Java Runtime Environment)，提供 Java 运行所需的环境，包括 Java 虚拟机、Java 核心类库和支持文件。</li></ol><p>JDK 包含 JRE。如果只运行 Java 程序，安装 JRE 即可，要编写 Java 程序需安装 JDK。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。反射机制使得 Java具有动态获取程序信息和动态调用对象方法的能力。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ol><li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改类的成员变量；</li><li><strong>Method</strong> ：可以使用 invoke() 方法获取类的方法信息；</li><li><strong>Constructor</strong> ：可以用 Constructor 创建新的对象，获取类的构造方法。</li></ol><p>优点：</p><p>运行期类型的判断，class.forName() 动态加载类，提高代码的灵活度。</p><p>缺点：</p><p>（1）性能开销 ：反射涉及动态类型的解析，JVM 无法对这些代码进行优化。因此，反射操作的效率比非反射操作低得多，应避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p><p>（2）安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。</p><p>（3）内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如：访问私有的属性和方法），所以使用反射可能会导致代码功能失调并破坏可移植性。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化：将 Java 对象转化为字节序列。</p><p>反序列化：将字节序列转化为 Java 对象。</p><p>应用场景：</p><p>Web 服务器中的 Session 会话对象，当有 $10$ 万用户并发访问，就有可能出现 $10$ 万个 Session 对象，显然这种情况内存可能是吃不消的。于是 Web 容器就会把一些 Session 先序列化，让他们离开内存空间，序列化到硬盘中，当需要调用时，再把保存在硬盘中的对象还原到内存中。</p><p>序列化与反序列化实现了 <strong>数据的持久化与进程通信间的对象传送</strong>，发送方需要把这个 Java 对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为 Java 对象。</p><p>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个User类，实现Serializable接口，并生成一个版本号</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String userId; </span><br><span class="line">    <span class="keyword">private</span> String userName; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userId, String userName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.userId = userId; </span><br><span class="line">        <span class="keyword">this</span>.userName = userName; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类，来对该对象进行读写操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 将User对象作为文本写入磁盘 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObj</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        user user = <span class="keyword">new</span> user(<span class="string">&quot;1001&quot;</span>, <span class="string">&quot;AveBai&quot;</span>); </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:/Users/AveBai/Desktop/user.txt&quot;</span>)); </span><br><span class="line">            objectOutputStream.writeObject(user); </span><br><span class="line">            objectOutputStream.close(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObj</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:/Users/AveBai/Desktop/user.txt&quot;</span>)); </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                Object object = objectInputStream.readObject(); </span><br><span class="line">                user user = (user) object; </span><br><span class="line">                System.out.println(user); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        writeObj();</span><br><span class="line">        readObj(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>反序列化输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.user@180bc464</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如加日志、事务等。</p><p>给类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，还在原来的基础上添加额外处理的新功能。这个代理类并不是定义好的，是动态生成的，具有解耦意义，灵活，扩展性强。</p><p>动态代理的应用：Spring 的 AOP 、加事务、加权限、加日志。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p><blockquote><p>元注解</p></blockquote><p>元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：</p><ul><li>@Retention: 定义该注解的生命周期。<ul><li>RetentionPolicy.SOURCE：注解在编译阶段丢弃，它们不会写入字节码。@Override, @SuppressWarnings 都属于这类注解。</li><li>RetentionPolicy.CLASS : 在类加载的时候丢弃，注解默认使用这种方式。</li><li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。自定义的注解通常使用这种方式。</li></ul></li><li>@Target：表示注解作用的范围。 </li><li>@Documented：表示是否将注解信息添加在 java 文档中。 </li><li>@Inherited：@Inherited 修饰的注解修饰一个父类，如果它的子类没有被其他注解修饰，则它的子类也继承父类的注解。 </li><li>@Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但每次注解可以代表不同的含义。</li></ul><p><strong>注解的作用</strong></p><ol><li>生成文档。这是最常见的，也是 Java 最早提供的注解。常用的有 @param @return 等</li><li>跟踪代码依赖性，实现替代配置文件功能。</li><li>在编译时进行格式检查。如@override 放在方法前，如果该方法并没有覆盖超类方法，则编译时就能检查出。</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Java-中的参数传递是传值还是传引用？"><a href="#Java-中的参数传递是传值还是传引用？" class="headerlink" title="Java 中的参数传递是传值还是传引用？"></a>Java 中的参数传递是传值还是传引用？</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><ul><li><p>基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;before change, i = &quot;</span>+i);</span><br><span class="line">        change(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change, i = &quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        i = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change, i = 1</span><br><span class="line">after change, i = 1</span><br></pre></td></tr></table></figure></li><li><p>对象作为参数传递时，是把对象在内存中的地址的拷贝传给参数。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;before change, s is &quot;</span>+s.toString());</span><br><span class="line">        change(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change, s is &quot;</span>+s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer stringBuffer)</span></span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;World !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change, s is Hello </span><br><span class="line">after change, s is Hello World !</span><br></pre></td></tr></table></figure><p>可见 s 指向的对象的值被改变了，那么是否可以推论出，在Java中，当对象作为参数传递时，传递的是该对象的引用呢？再看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;before change, s is &quot;</span>+s.toString());</span><br><span class="line">        change(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change, s is &quot;</span>+s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer stringBuffer)</span></span>&#123;</span><br><span class="line">        stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hi &quot;</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;World !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的推论是正确的，即传递的是对象的引用，那么在调用 change 函数之后，原对象的值应该是会改变的，变为 “Hi World ！”，但运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change, s is Hello </span><br><span class="line">after change, s is Hello </span><br></pre></td></tr></table></figure><p>当执行 <code>StringBuffer sb = new StringBuffer(“Hello “)</code> 时，创建了一个指向新建对象 <code>“Hello “</code> 的引用 <code>“s”</code>。在例 1 中，调用 change 函数后，实际上，形参 stringBuffer 也指向了实参 s 所指向的对象，那么执行 <code>stringBuffer.append(“world !”)</code> 后，便通过对象的引用 “stringBuffer” 修改了对象的值，使之变成 “Hello world ！”。但是在例 2 中又新建了一个对象 <code>“new StringBuffer(“Hi “)”</code>，让形参 stringBuffer 实际指向了这个新建的对象，并将新对象的值设置为 “Hi World ！”，但是因为值没有被 return 返回赋值给 s 对象，所以 s 对象并没有被改变，所以输出的仍然是 “Hello ”。</p></li></ul><h2 id="Java-中的-IO-流的分类？"><a href="#Java-中的-IO-流的分类？" class="headerlink" title="Java 中的 IO 流的分类？"></a>Java 中的 IO 流的分类？</h2><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流 和 字符流。</p><p>字节流：InputStream/OutputStream 是字节流的抽象类。</p><p>字符流：Reader/Writer 是字符的抽象类。</p><p>字节流按 $8$ 位传输，以字节为单位输入输出数据，字符流按 $16$ 位传输，以字符为单位输入输出数据。</p><p>但是不管文件读写还是网络发送接收，信息的最小存储单元都是字节。</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li><p>修饰类：表示类不可被继承；</p></li><li><p>修饰方法：表示方法不可被子类覆盖，但可以重载；</p></li><li><p>修饰变量：表示变量一旦被赋值就不可以更改它的值。</p><p>$(1)$ 修饰类变量：只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</p><p>$(2)$ 修饰成员变量：可以在非静态初始化块声明该变量或者构造器中执行初始值。</p><p>$(3)$ 修饰局部变量：系统不会为局部变量初始化，必须由程序员显式初始化。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//类变量：在声明的时候赋值 或者 静态代码块赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">0</span>;<span class="comment">//成员变量：在声明的时候赋值 或者 构造器赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> local; <span class="comment">// 局部变量</span></span><br><span class="line">        local = <span class="number">0</span>; <span class="comment">// 使用之前一定要赋值</span></span><br><span class="line">        <span class="comment">//local = 1; 不允许第二次赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   $(4)$ 修饰基本数据类型的变量：数值初始化后不能修改。<br>   $(5)$ 修饰引用类型的变量：初始化后不能指向另一个变量，但是引用的值是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] mylist = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">mylist[<span class="number">2</span>] = -<span class="number">3</span>; <span class="comment">// 合法</span></span><br><span class="line">mylist = <span class="keyword">null</span>; <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Person p = <span class="keyword">new</span> Person(<span class="number">25</span>);</span><br><span class="line">p.setAge(<span class="number">24</span>); <span class="comment">// 合法</span></span><br><span class="line">p = <span class="keyword">null</span>; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><h3 id="为什么局部内部类和匿名内部类只能访问局部-final-变量？"><a href="#为什么局部内部类和匿名内部类只能访问局部-final-变量？" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部 final 变量？"></a>为什么局部内部类和匿名内部类只能访问局部 final 变量？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 局部final变量a,b</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPrint</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inclass</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> InClass().InPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类和外部类是同一级别的，比如 Test 类编译之后会生成两个 class文件：Test.class、Test1.class。内部类不会因为定义在方法中而随着方法执行完毕就被销毁。当外部类的方法结束时，局部变量会被销毁，但是内部类对象可能还存在(没人引用时才死亡)，这时就出现了矛盾：内部类对象访问了一个不存在的变量。为解决这个问题，将方法中的局部变量复制一份作为内部类的成员变量，当局部变量被销毁，内部类还可以访问它的 “copy”。将局部变量设置为 final，内部类就无法修改这个变量，可以保证内部类的成员变量和方法中的局部变量保持一致。</p><h3 id="final、finally-和-finalize-的区别"><a href="#final、finally-和-finalize-的区别" class="headerlink" title="final、finally 和 finalize 的区别"></a>final、finally 和 finalize 的区别</h3><ol><li><p>final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。</p></li><li><p>finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块表示这个语句最后执行(在 return 之前执行)，经常被用在需要释放资源的情况下。</p><p><strong>当遇到下面情况 finally 代码块不会执行</strong>：</p><ul><li>当程序在进入 try 语句块之前就出现异常时会直接结束。</li><li>当程序在 try 块中强制退出时，如使用 System.exit(0)。</li></ul></li><li><p>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize() 方法。当垃圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。</p></li></ol><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>1. 静态变量</strong> </p><p>静态变量在内存中只存在一份，只在类第一次实例化时初始化一次。</p><ul><li>静态变量：静态变量在内存中仅有一个拷贝，类所有的实例都共享静态变量，可以直接通过类名来访问它；</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;        <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong> </p><p>在类中使用 static 修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。</p><p>非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员；<br>非静态方法既可以访问静态方法又可以访问非静态方法，而静态方法只能访问静态数据方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(S.getStatic());<span class="comment">//使用类名加前缀访问静态方法</span></span><br><span class="line">        S s=<span class="keyword">new</span> S();</span><br><span class="line">        System.out.println(s.getStatic());<span class="comment">//使用实例化对象名访问静态方法</span></span><br><span class="line">        System.out.println(s.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态初始器：由static和&#123;&#125;组成，只在类装载时（第一次使用类）执行一次，用来初始化静态变量。</span></span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            a=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态方法只能访问静态数据成员</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStatic</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getT</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> t;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态方法可以访问静态方法和非静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            getT();</span><br><span class="line">            getStatic();</span><br><span class="line">            t=a;<span class="comment">//非静态方法可以访问非静态数据成员和静态数据成员</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong> </p><p>静态语句块和静态变量一样在类第一次实例化时运行一次。</p><p><strong>4. 初始化顺序</strong> </p><p>静态数据优先于其它数据的初始化，静态变量和静态语句块的运行顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例变量和普通语句块的初始化在静态变量和静态语句块初始化结束之后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String field = <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数中的数据进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为：</p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><h1 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h1><p>Object 里面有的方法，所有类都是继承 Object，所以“所有对象都有这些方法”。</p><blockquote><p>Java 中创建对象的几种方式？</p></blockquote><ul><li>使用 new 关键字；</li><li>反射，使用 Class 类的 newInstance 方法，该方法调用无参的构造器创建对象；</li><li>使用 clone() 方法；</li><li>反序列化。</li></ul><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals() 与 == 的区别"></a>equals() 与 == 的区别</h3><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个实例是否引用同一个对象，而 equals() 判断引用对象的值是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>重写</strong></p><p>以 Dog 类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="comment">// 判断地址是否相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="comment">// 判断对象是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(getClass()!=obj.getClass()) <span class="comment">// getClass()可以得到类对象，判断类型是否一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Dog other = (Dog) obj;</span><br><span class="line">    <span class="keyword">if</span>(age!=other.age) <span class="comment">// 判断属性值是否一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 如果地址相同，对象不为空，类型一样，属性值一样则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>obj.getClass()</code> 得到的类对象和类的对象不同，前者得到的是类的定义，后者是实例化的具体类。</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>哈希码是通过哈希算法生成的一个字符串，它是用来<strong>唯一</strong>区分我们对象的地址码。</p><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分不到所有可能的散列值上。</p><h3 id="两个对象的-hashCode-相同，则-equals-也一定为-true-吗？"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true-吗？" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？</h3><p>hasCode() 返回散列值，而 equals() 是用来判断两个实例是否相等。相等的两个实例散列值一定要相同，但是散列值相同的两个实例不一定相等。</p><h3 id="为什么重写-equals-就一定要重写-hashCode-方法？"><a href="#为什么重写-equals-就一定要重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 就一定要重写 hashCode() 方法？"></a>为什么重写 equals() 就一定要重写 hashCode() 方法？</h3><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证相等的两个实例散列值也相等。如果没有重写 hasCode()，则两个对象无论如何都不会相等，即使它们指向相同的数据。</p><p>这个问题应该是有个前提，就是你需要用到 HashMap、HashSet 等 Java 集合，用不到哈希表的话，其实仅仅重写 equals() 方法也可以。而工作中的场景是常常用到 Java 集合，所以 Java 官方建议重写 equals() 就一定要重写 hashCode() 方法。</p><p>对于对象集合的判重，如果一个集合含有大量对象实例，仅仅使用 equals() 方法的话，那么对于一个对象判重就需要比较很多次，随着集合规模的增大，时间开销很大。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在后续比较过程中，如果两个对象的 hashCode 不相同，就不需要调用 equals() 方法，从而大大减少了 equals() 比较次数。</p><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>Object 类的 <code>toString</code> 方法返回一个字符串，该字符串由类名、@和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><p>它通常只是为了方便输出，比如 System.out.println(xx)，括号里面的 “xx” 如果不是 String 类型的话，就自动调用 xx 的 toString() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;this is A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    A obj = <span class="keyword">new</span> A();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：this is A</span></span><br><span class="line"><span class="comment">// 如果去掉重写的toString，会输出：MyType$A@1e643faf</span></span><br></pre></td></tr></table></figure><p>打印 StringBuffer 类型必须用 toString，自动调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StringBuffer MyStrBuff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">MyStrBuff.append(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">System.out.println(MyStrBuff.toString());</span><br><span class="line">System.out.println(MyStrBuff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Hello!</span></span><br><span class="line"><span class="comment">//Hello!</span></span><br></pre></td></tr></table></figure><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p><strong>1. cloneable</strong> </p><p>clone() 是 Object 的受保护方法，这意味着，如果一个类不显式去重载 clone() 就没有这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line">CloneExample e2 = e1.clone(); <span class="comment">// &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure><p>接下来重载 Object 的 clone() 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MyType <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (MyType)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">MyType e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p><strong>2. 深拷贝与浅拷贝</strong> </p><ul><li>浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MyType <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (MyType) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line">MyType e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深拷贝：拷贝实例和原始实例的引用类型引用不同对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MyType <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    MyType result = (MyType) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line">MyType e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(MyType original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line">MyType e2 = <span class="keyword">new</span> MyType(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>成员可见表示其它类可以用这个类的实例访问到该成员；</li><li>类可见表示其它类可以用这个类创建对象。</li></ul><p>protected：子类可以用它修饰的成员。</p><p>private：访问权限仅限于类的内部，是一种封装的体现。</p><p>default：有时也称为friendly，任何处于本包下的类、接口、异常等，都可以相互访问。</p><div class="table-container"><table><thead><tr><th></th><th>类内部</th><th>本包</th><th>子类</th><th>外部包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></div><p>如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例。</p><p>字段绝不能是公有的，因为这么做的话就失去了对这个实例域修改行为的控制，客户端可以对其随意修改。可以使用共有的 getter 和 setter 方法来替换共有字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x; <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><ul><li>this关键字<strong>代表当前对象</strong></li></ul><p>　　this.属性 操作当前对象的属性</p><p>　　this.方法 调用当前对象的方法。</p><ul><li><p>封装对象的属性的时候，经常会使用this关键字。</p></li><li><p>当 getter 和 setter 函数参数名和成员函数名重合的时候，可以使用 this 区别。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScreen</span><span class="params">(<span class="keyword">float</span> screen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.screen = screen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类 (Inner Class) 就是定义在另外一个类里面的类。</p><ul><li>内部类提供了<strong>更好的封装</strong>，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li><li>内部类的方法可以<strong>直接访问外部类的所有数据</strong>，包括私有的数据。</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。</li></ul><p>内部类可分为以下几种： </p><ul><li><p>成员内部类</p><p>最常见，也称为普通内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">99</span>; <span class="comment">// 外部类的私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;访问内部类中的a：&quot;</span>+a);</span><br><span class="line">            System.out.println(<span class="string">&quot;this访问内部类中的a：&quot;</span>+<span class="keyword">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;this访问外部类中的a：&quot;</span>+Outer.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        Inner i = o.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        i.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问外部类中的a：2</span><br><span class="line">this访问内部类中的a：2</span><br><span class="line">访问外部类中的a：99</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p><p>静态内部类是 <strong>static 修饰的</strong>内部类，这种内部类的特点是：</p><ul><li>静态内部类不能直接访问外部类的非静态成员，但可以通过<strong>new 外部类().成员</strong>的方式访问。</li><li>如果外部类的静态成员与内部类的成员<strong>名称相同</strong>，可通过“<strong>类名.静态成员</strong>”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称<strong>不相同</strong>，则可通过“<strong>成员名”</strong>直接调用外部类的静态成员。</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <strong>内部类 对象名= new 内部类();</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SOuter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">99</span>; <span class="comment">// 外部类的私有属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">// 内部类的变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;访问外部类中的a：&quot;</span>+<span class="keyword">new</span> SOuter().a);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问外部类中的b：&quot;</span>+SOuter.b);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问内部类中的b：&quot;</span>+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SInner si = <span class="keyword">new</span> SInner(); <span class="comment">// 直接创建内部类的对象</span></span><br><span class="line">        si.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问外部类中的a：99</span><br><span class="line">访问外部类中的b：1</span><br><span class="line">访问内部类中的b：2</span><br></pre></td></tr></table></figure></li><li><p>方法内部类</p><p>方法内部类就是内部类定义在外部类的<strong>方法中</strong>，方法内部类只在该方法的内部可见，即<strong>只在该方法内可以使用</strong>。因此方法内部类不能使用访问控制符和 static 修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MOuter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">13</span>;</span><br><span class="line"><span class="comment">// 方法内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MInner</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;访问外部类的方法中的a：&quot;</span>+a);</span><br><span class="line">                System.out.println(<span class="string">&quot;访问内部类中的c：&quot;</span>+c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MInner mi = <span class="keyword">new</span> MInner();</span><br><span class="line">mi.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MOuter e = <span class="keyword">new</span> MOuter();</span><br><span class="line">e.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问外部类的方法中的a：25</span><br><span class="line">访问内部类中的c：2</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类　　</p><p>匿名类是<strong>不能有名称的类</strong>，所以没办法引用他们。必须在创建时，作为<strong>new语句</strong>的一部分来声明他们。但使用匿名内部类还有个前提条件：<strong>必须继承一个父类或实现一个接口。</strong></p><p>匿名类的声明是在编译时进行的，实例化在运行时进行。这意味着 for 循环中的一个 new 语句会创建相同匿名类的几个实例，而不是创建几个不同匿名类的一个实例。</p><p>假如要执行的任务需要一个对象，但却不值得创建全新的对象，匿名类就显得很有用。</p><ul><li><p>匿名内部类的基本实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在接口上使用匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在使用匿名内部类的过程中，需要注意如下几点：</p><ol><li>使用匿名内部类时，必须继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</li><li>匿名内部类中是不能定义构造函数的。</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li>匿名内部类为局部内部类（即方法内部类），所以局部内部类的所有限制同样对匿名内部类生效。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ol></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是类与类的一种关系，是一种 “is a” 的关系。比如“狗”继承“动物”，这里动物类是狗类的父类或者基类，狗类是动物类的子类或者派生类。Java 中的继承是单继承，即一个类只有一个父类。</p><p>优点：子类拥有父类的所有属性和方法（除了 private 修饰的属性）从而实现代码的复用。</p><p><strong>重写</strong>：子类如果对继承的父类的方法不满意，可以自己编写继承的方法，这种方式就称为方法的重写。当调用方法时会优先调用子类的方法。</p><h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><ul><li>重载：发生在同一个类中的多态手段，方法名必须相同，参数列表不同(个数、顺序)，返回值和访问修饰符可以不同，发生在编译时。</li><li>重写：发生在父子类中，方法名、参数列表必须相同，返回值范围和抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法访问修饰符为 private 则子类不能重写该方法。</li></ul><h3 id="是否可以重写一个-private-或者-static-方法？"><a href="#是否可以重写一个-private-或者-static-方法？" class="headerlink" title="是否可以重写一个 private 或者 static 方法？"></a>是否可以重写一个 private 或者 static 方法？</h3><p>Java 中 static 方法可以被继承但不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。</p><p>Java 中也不能覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的。</p><h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><ul><li><p>重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu a =  <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li><li><p>重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String name,<span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i,String name)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Smoking sk = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//学生是类，Smoking是接口 </span></span><br></pre></td></tr></table></figure></li><li><p>抽象类和抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="comment">//Animal是父类抽象类</span></span><br></pre></td></tr></table></figure></li></ul><p>多态特点：</p><ol><li>方法成员变量、静态方法看父类</li><li>非静态方法编译时看父类，运行时看子类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu method_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu method_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">8</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi method_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi method_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(f.num);<span class="comment">//与父类一致</span></span><br><span class="line">        f.method1();<span class="comment">//与父类一致</span></span><br><span class="line">        f.method2();<span class="comment">//编译时与父类一致，运行时与子类一致</span></span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(z.num);</span><br><span class="line">        z.method1();</span><br><span class="line">        z.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">fu method<span class="emphasis">_1</span></span><br><span class="line"><span class="emphasis">zi method_</span>2</span><br><span class="line">8</span><br><span class="line">zi method<span class="emphasis">_1</span></span><br><span class="line"><span class="emphasis">zi method_</span>2</span><br></pre></td></tr></table></figure><h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p><strong>1. 抽象类</strong> </p><p>抽象类和抽象方法都使用 abstract 进行声明。</p><ul><li><p>抽象类不能被实例化，如果被实例化，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</p></li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Telephone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类的普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">Telephone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="comment">//继承抽象类的子类必须重写抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写抽象类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Telephone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        p.call();</span><br><span class="line">        p.message();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写抽象类的方法</span><br><span class="line">抽象类的普通方法</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义的语法</span></span><br><span class="line">[可见度] <span class="class"><span class="keyword">interface</span> 接口名称 [<span class="keyword">extends</span> 其他的接口名] </span>&#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承父类实现接口的语法</span></span><br><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1，接口2...</span>&#123;</span><br><span class="line">    <span class="comment">//如果继承了抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口（Interface），在 Java 中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><ul><li><p>接口无法被实例化，没有构造方法，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p></li><li><p>接口不能包含成员变量，除了 static 和 final 变量。接口中的变量会被隐式的指定为 <code>public static final</code> 变量。</p></li></ul><ul><li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。接口中的方法会被隐式的指定为 <code>public abstract</code>。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 <code>default</code> 关键字修饰。</li><li>接口中的方法都是公有的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPlayGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paly</span><span class="params">()</span></span>; <span class="comment">//abstract 关键字可以省略，系统会自动加上</span></span><br><span class="line">    <span class="keyword">public</span> String name=<span class="string">&quot;游戏名字&quot;</span>; <span class="comment">//static final关键字可以省略，系统会自动加上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">Telephone</span> <span class="keyword">implements</span> <span class="title">IPlayGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;<span class="comment">//继承抽象类的子类必须重写抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写抽象类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IPlayGame i=<span class="keyword">new</span> Phone(); <span class="comment">//用接口的引用指向子类的对象</span></span><br><span class="line">        i.paly(); <span class="comment">//调用接口的方法</span></span><br><span class="line">        System.out.println(i.name); <span class="comment">//输出接口的常量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写接口的方法</span><br><span class="line">游戏名字</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong> </p><ul><li>从设计层面上看，抽象类是对类本质的抽象，表达 is a 的关系，比如 BMW is a Car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类实现。而接口是对方法的抽象，表达 like a 的关系，比如 Bird like a Aircraft(鸟像飞机一样可以飞)，鸟可以实现飞机飞的方法但鸟不是飞机。接口的核心是定义方法，即实现类可以做什么，至于谁实现，如何实现，接口并不关心。</li><li>从使用上来看，一个类可以实现多个接口，但只能继承一个抽象类。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型。</li><li>抽象类可以有抽象方法和具体方法，而接口中只能存在抽象(public abstract)方法。</li><li>抽象类中可以定义构造函数，接口不能定义构造函数。</li></ul><p>在 JDK1.8中，允许在接口中包含带有具体实现的方法，使用 default 修饰，这类方法就是默认方法。</p><p><strong>4. 使用选择</strong> </p><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码；</li><li>需要能控制继承来的方法和域的访问权限，而不是都为 public。</li><li>需要继承非静态（non-static）和非常量（non-final）字段。</li></ul><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><h3 id="在-Java-中定义一个不做事且没有参数的构造方法有什么作用？"><a href="#在-Java-中定义一个不做事且没有参数的构造方法有什么作用？" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法有什么作用？"></a>在 Java 中定义一个不做事且没有参数的构造方法有什么作用？</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String、StringBuffer-和-StringBuilder"><a href="#String、StringBuffer-和-StringBuilder" class="headerlink" title="String、StringBuffer 和 StringBuilder"></a>String、StringBuffer 和 StringBuilder</h2><p><strong>1. 是否可变</strong> </p><ul><li>String 是 final 修饰的，不可变，意味着每次操作都会产生新的 String 对象；</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 是否线程安全</strong> </p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 来同步</li><li>StringBuilder 不是线程安全的</li></ul><p>性能：StringBuilder &gt; StringBuffer &gt; String</p><p>使用场景：优先使用 StringBuilder，多线程使用共享变量时用 StringBuffer。</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><p>使用 String.intern() 可以保证相同内容的字符串实例引用相同的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用，这个方法首先把 s1 引用的对象放到 String Poll（字符串常量池）中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Poll 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">String s5 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 6 之前，字符串常量池被放在永久代中，而在 Java 7 时，它被放在堆的其它位置。这是因为永久代的空间有限，如果大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="String-为什么要设计为不可变类？"><a href="#String-为什么要设计为不可变类？" class="headerlink" title="String 为什么要设计为不可变类？"></a>String 为什么要设计为不可变类？</h2><p>（1）字符串常量池的需要：当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；</p><p>（2）允许 String 对象缓存 HashCode：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，意味着不必每次都去计算新的哈希码；</p><p>（3）String 被许多的 Java 类(库)用来当做参数，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。</p><h1 id="基本类型与运算"><a href="#基本类型与运算" class="headerlink" title="基本类型与运算"></a>基本类型与运算</h1><h2 id="基本类型与包装类型"><a href="#基本类型与包装类型" class="headerlink" title="基本类型与包装类型"></a>基本类型与包装类型</h2><p>八个基本类型：</p><ul><li><p>byte: 占用 1 个字节，</p><p>取值范围 $-128$ ~ $127$ </p></li><li><p>short: 占用 2 个字节</p><p>取值范围 $-2^{15} $~ $2^{15} -1 $</p></li><li><p>int：占用 4 个字节</p><p>取值范围 $-2^{31} $~ $2^{31} -1 $</p></li><li><p>long：占用 8 个字节 </p></li><li><p>float：占用 4 个字节 </p></li><li><p>double：占用 8 个字节 </p></li><li><p>char: 占用 2 个字节 </p></li><li><p>boolean：占用大小根据实现虚拟机不同有所差异</p></li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用<strong>自动装箱与拆箱</strong>完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><h2 id="Integer-和-int-的区别"><a href="#Integer-和-int-的区别" class="headerlink" title="Integer 和 int 的区别"></a>Integer 和 int 的区别</h2><p>（1）int 是 Java 的八种基本数据类型之一，而 Integer 是 Java 为 int 类型提供的封装类；</p><p>（2）int 型变量的默认值是 0，Integer 变量的默认值是 null，说明 Integer 可以区分未赋值和值为 0；</p><p>（3）Integer 变量必须实例化后才可以使用，而 int 不需要。</p><p>延伸：</p><ul><li>Integer 变量和 int 变量比较时，只要两个变量的值是相等的，则结果为 true。因为包装类 Integer 和基本数据类型 int 类型进行比较时，Java 会自动拆包装类为 int，然后进行比较，实际上就是两个 int 型变量在进行比较；</li><li>由于 Integer 变量实际上是对一个 Integer 对象的引用，所以两个通过 new 生成的 Integer 变量永远是不相等的，因为其内存地址是不同的；</li><li>非 new 生成的 Integer 变量和 new Integer() 生成的变量进行比较时，结果为 false。因为非 new 生成的 Integer 变量指向的是 Java 常量池中的对象，而 new Integer() 生成的变量指向堆中新建的对象；</li><li>对于两个非 new 生成的 Integer 对象进行比较时，如果两个变量的值在区间 $[-128, 127]$ 之间，则比较结果为 true，否则为 false。</li></ul><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和 &amp;&amp; 的区别"></a>&amp; 和 &amp;&amp; 的区别</h2><p>Java 中 &amp;&amp; 和 &amp; 都表示逻辑运算符与(and)，当两边的表达式都为 true 的时候，整个运算结果才为 true，否则为 false。</p><p>&amp;&amp;：有短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；</p><p>&amp;：不管第一个表达式结果是否为 true，第二个都会执行。</p><p>&amp; 还可以用作位运算符，当 &amp; 两边的表达式不是 Boolean 类型的时候，&amp; 表示按位操作。</p><h3 id="Math-round-1-5"><a href="#Math-round-1-5" class="headerlink" title="Math.round(-1.5)"></a>Math.round(-1.5)</h3><p>round 表示四舍五入，算法为 <code>Math.floor(x+0.5)</code> ，即将原来的数字加上 $0.5$ 后再向下取整，所以 <code>Math.round(1.5)</code> 的结果为 $2$，<code>Math.round(-1.5)</code> 的结果为 $-1$。</p><h3 id="两个二进制数的异或结果"><a href="#两个二进制数的异或结果" class="headerlink" title="两个二进制数的异或结果"></a>两个二进制数的异或结果</h3><p>两个二进制数异或结果是这两个二进制数差的绝对值。表达式如下：$a\bigoplus b = |a-b|$。</p><h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于，new Integer(123) 每次都会新建一个对象，而 Integer.valueOf(123) 可能会使用缓存对象，因此多次使用 Integer.valueOf(123) 会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 <code>valueOf()</code> 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 $-128$~$127$。</p><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 switch(expr 1) 中，expr1 只能是一个整数表达式或者枚举常量。而整数表达式可以是 int 基本数据类型或者 Integer 包装类型。由于，byte、short、char 都可以隐式转换为 int，所以，这些类型以及这些类型的包装类型也都是可以的。而 long 类型都不符合 switch 的语法规定，并且不能被隐式的转换为 int 类型，所以不能作用于 switch 语句中。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong>  和 <strong>Exception</strong>。其中 Error 一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防；Exception 分为两种：</p><ol><li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong> ：是运行时异常，如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。可以编译通过，但是一运行就崩溃，程序不会自己处理；</li></ol><p><img src="PPjwP.png" alt=""></p><h2 id="throw与throws"><a href="#throw与throws" class="headerlink" title="throw与throws"></a>throw与throws</h2><ul><li><p>throw：用在方法体内，用来抛出一个具体的异常类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception1,Exception3</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">                 ......</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">              <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(a!=b)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span>  Exception3(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throws 用在方法声明后面，用来声明一个方法可能产生的所有异常，不做任何处理而是将异常往上传，谁调用我我就抛给谁。throws 表示出现异常的一种可能性，并不一定会发生这些异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun()可能出现两种异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span><span class="keyword">throws</span> IOException,SQLException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用fun()时要准备处理两种异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="try-catch-finally-中，若-catch-中-return，finally-还执行吗？"><a href="#try-catch-finally-中，若-catch-中-return，finally-还执行吗？" class="headerlink" title="try-catch-finally 中，若 catch 中 return，finally 还执行吗？"></a>try-catch-finally 中，若 catch 中 return，finally 还执行吗？</h2><p>会执行。程序在执行到 return 时会首先将返回值存储在一个指定的位置，其次去执行 finally 块，最后再返回。因此，对基本数据类型，在 finally 块中改变 return 的值没有任何影响，直接覆盖掉；而对引用类型是有影响的，返回的是在 finally 对前面 return 语句返回对象的修改值。</p><h2 id="主线程可以捕获到子线程的异常吗？"><a href="#主线程可以捕获到子线程的异常吗？" class="headerlink" title="主线程可以捕获到子线程的异常吗？"></a>主线程可以捕获到子线程的异常吗？</h2><p>正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。如果想要在主线程中捕获子线程的异常，可以用如下的方式进行处理，使用 Thread 的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandle());</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。</p><p>自定义泛型类和方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">&quot;corn&quot;</span>);</span><br><span class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name class:&quot;</span> + name.getClass());      <span class="comment">// class test.Box</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age class:&quot;</span> + age.getClass());        <span class="comment">// class test.Box</span></span><br><span class="line">        System.out.println(name.getClass() == age.getClass());    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型类时，虽然传入不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然在逻辑上可以理解成多个不同的泛型类型。</p><p>Java 中泛型这一概念只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的 class 文件中是不包含任何泛型信息的。</p><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>Java 编译器生成的字节码不包含泛型信息，泛型类型信息将在编译处理时被擦除，这个过程被称为泛型擦除。</p><h2 id="泛型中的限定通配符和非限定通配符"><a href="#泛型中的限定通配符和非限定通配符" class="headerlink" title="泛型中的限定通配符和非限定通配符"></a>泛型中的限定通配符和非限定通配符</h2><p>两种限定通配符:</p><ul><li>&lt; ? extends T &gt; 通过确保类型必须是 T 的子类来设定类型的上界；</li><li>&lt; ? super T &gt; 通过确保类型必须是 T 的父类来设定类型的下界。</li></ul><p>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。<br>&lt; ? &gt; 表示非限定通配符，因为 &lt; ? &gt; 可以用任意类型来替代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;字节序&quot;&gt;&lt;a href=&quot;#字节序&quot; class=&quot;headerlink&quot; title=&quot;字节序&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://10185102110.github.io/2021/08/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://10185102110.github.io/2021/08/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-08-08T08:56:52.000Z</published>
    <updated>2021-08-28T04:49:00.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><h1 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给每个对象添加一个计数器，当有地方引用该对象时计数器加 $1$，当引用失效时计数器减 $1$。用对象计数器是否为 $0$ 来判断对象是否可被回收。</p><p>缺点：<strong>无法解决循环引用的问题</strong>。</p><p>例如创建一个字符串，<code>String m = new String(&quot;jack&quot;);</code>，这时候 “jack” 有一个引用，就是 m。然后将 m 设置为 null，这时候 “jack” 的引用次数为 $0$ ，在引用计数算法中，意味着这块内容需要被回收了。</p><p>引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。但 JVM 的垃圾回收就是 Stop-The-World(暂停整个程序) 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object instance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">&quot;objA&quot;</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">&quot;objB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最后这 $2$ 个对象已经不会再被访问了，但由于它们相互引用对方，导致它们的引用计数永远都不会为 $0$，通过引用计数算法无法通知 GC 收集器回收它们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>以 GC ROOT 的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收。</p><p><img src="2269232-97bf646f648d6ff7.webp" alt=""></p><p>可达性算法解决了引用计数所无法解决的循环依赖问题，只要对象无法与 GC Root 建立直接或间接的连接，系统就会将其判定为可回收对象。</p><p>Java 内存区域中可以作为 GC ROOT 的对象：</p><ul><li><p>虚拟机栈中引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 s 即为 GC Root，当 s 置空时，“example1” 对象也断掉了与 GC Root 的引用链，将被回收。</p></li><li><p>方法区中类静态属性引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MyType m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s.m = <span class="keyword">new</span> MyType(<span class="string">&quot;example2&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 s 即为 GC Root，s 置为 null，经过GC后，s 所指向的 “example1” 对象由于无法与 GC Root 建立关系被回收。而 m 作为类的静态属性，也属于 GC Root，“example2” 对象依然与 GC root 建立着连接，所以 “example2” 对象不会被回收。</p></li><li><p>方法区中常量引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MyType m = MyType(<span class="string">&quot;final&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m 即为方法区中的常量引用，也是 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。</p></li><li><p>本地方法栈中引用的对象</p><p>任何 native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，只是简单地动态连接并直接调用指定的本地方法。</p></li></ul><blockquote><p>引用类型</p></blockquote><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 中有四种强度不同的引用类型。引用由强到若分为：强引用、软引用、弱引用、虚引用。</p><ul><li><p><strong>强引用：</strong>使用 new 一个新对象的方式来创建强引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p><strong>软引用：</strong>一些还有用但并非必须的对象。软引用关联着的对象，在系统要发生内存溢出之前，会把这些对象进行垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用：</strong>也是描述一些非必须对象，强度比软引用更弱，只要发生垃圾回收，它就一定会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用：</strong>是最弱的一种引用。设置虚引用的唯一目的是能在这个对象被回收时会收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p><img src="2269232-5b023b00f7bf8f1b.webp" alt=""></p><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>缺点：<strong>内存碎片</strong>。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><img src="2269232-46c30f2ffb8c18af.webp" alt=""></p><p>复制算法（Copying）能解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。</p><p>缺点：内存利用率只有 $50\%$。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><img src="2269232-d7cb73cb0e50c060.webp" alt=""></p><p>标记-整理算法标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>标记整理算法解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。</p><p>缺点：对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上较差。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代收集算法融合上述3种基础的算法思想，根据对象存活周期的不同将内存划分为几块。</p><ul><li><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p><p>JVM 新生代采用这种算法，但并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>Eden 和 Survivor 大小比例默认为 $8:1$，保证了内存的利用率达到 $90\%$。</p></li><li><p>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记-清理算法</strong>或者<strong>标记-整理算法</strong>来进行回收。</p></li></ul><h1 id="内存区域与回收策略"><a href="#内存区域与回收策略" class="headerlink" title="内存区域与回收策略"></a>内存区域与回收策略</h1><h2 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h2><p>大多数情况下，对象会在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC。通过 Minor GC 之后，Eden 区中绝大部分对象会被回收，而那些存活对象，将会送到 Survivor 的 From 区（若 From 区空间不够，则直接进入 Old 区） 。</p><p><strong>Minor GC：</strong></p><p>当年轻代满时就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。通过<strong>复制算法</strong> ,回收垃圾。</p><p><strong>Major GC：</strong></p><p>Major GC 又称为 <strong>Full GC</strong>。当年老代空间不够用的时候，虚拟机会使用“<strong>标记-清除</strong>”或者“<strong>标记-整理</strong>”算法清理出连续的内存空间，分配对象使用。</p><p>调用 System.gc() 时，系统建议执行 Full GC，但是不必然执行。</p><h2 id="Survivor区"><a href="#Survivor区" class="headerlink" title="Survivor区"></a>Survivor区</h2><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲。Survivor 分为 $2$ 个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区中存活的对象放到 Survivor 的 From 区，而在 From 区中，仍存活的对象会根据他们的年龄值来决定去向。（From Survivor 和 To Survivor 的逻辑关系会发生颠倒：From 变 To ， To 变 From，目的是保证有连续的空间存放对方，避免碎片化的发生）</p><blockquote><p>Survivor 区存在的意义</p></blockquote><p>如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor的预筛选保证，只有经历 $16$ 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓大对象是指，需要大量连续内存空间的Java对象，典型的大对象就是很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。</p><p>虚拟机提供了一个 <code>XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中（正常情况下对象会不断的在Survivor的From与To区之间移动），并且对象年龄设为 $1$。对象在 Survivor 区中每经历一次 Minor GC，年龄就增加 $1$ 岁，当它的年龄增加到一定程度（默认 $15$ 岁），就会晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>XX:MaxPretenuringThreshold</code> 设置。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>为了能更好地适应不同程度的内存状况，虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxPretenuringThreshold</code> 才能晋升老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到 <code>MaxPretenuringThreshold</code>中要求的年龄。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-08-08T08:56:22.000Z</published>
    <updated>2021-08-28T05:02:11.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存结构，主要就是分析 JVM 运行时数据存储区域。</p><p>JVM 的运行时数据区主要包括：<strong>堆、栈、方法区、程序计数器</strong>等。</p><p>而 JVM 的优化问题主要在<strong>线程共享的数据区</strong>中：<strong>堆、方法区</strong>。</p><p><img src="2019040912492050.png" alt=""></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，<strong>一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行</strong>。</p><p>为了确保线程切换后（<strong>上下文切换</strong>）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。也就是说程序计数器是<strong>线程私有的内存</strong>。</p><p>如果线程执行 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，计数器值为 Undefined。</p><p>程序计数器<strong>不会发生内存溢出</strong>（OutOfMemoryError 即 OOM）问题。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>JVM 中的栈包括 <strong>Java 虚拟机栈</strong> 和 <strong>本地方法栈</strong>，两者的区别就是，Java 虚拟机栈为 JVM 执行 Java 方法服务，本地方法栈则为 JVM 使用到的 Native 方法服务。Java 虚拟机栈，以下简称栈。</p><blockquote><p>Native 方法是什么？</p></blockquote><p>JDK 中有很多方法是使用 <strong>Native</strong> 修饰的。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）。Native 方法可以理解为是与操作系统直接交互的。比如通知垃圾收集器进行垃圾回收的代码 System.gc()，就是使用 native 修饰的。</p><blockquote><p>栈是什么？​</p></blockquote><p>定义：限定仅在表头进行插入和删除操作的线性表。即压栈（入栈）和弹栈（出栈）都是对栈顶元素进行操作的。所以栈是后进先出的。</p><p>栈是<strong>线程私有的</strong>，他的生命周期与线程相同。每个线程都会分配一个栈的空间，即每个线程拥有独立的栈空间。</p><blockquote><p>栈中存储的是什么？</p></blockquote><p><strong>栈帧</strong>是栈的元素。每个方法在执行时都会创建一个栈帧。栈帧中存储了<strong>局部变量表、操作数、动态链接和返回地址</strong>等信息。每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。</p><p><img src="20190409182042686.png" alt=""></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（String、数组、对象等），但是<strong>不存储对象的内容</strong>。局部变量表所需的内存空间<strong>在编译期间完成分配</strong>，在方法运行期间不会改变局部变量表的大小。</p><p>局部变量的容量以<strong>变量槽（Slot）</strong>为最小单位，每个变量槽最大存储 $32$ 位的数据类型。对于 $64$ 位的数据类型（long、double），JVM 会为其分配两个连续的变量槽来存储。</p><p>JVM 通过索引定位的方式使用局部变量表，索引的范围从 $0$ 开始至局部变量表中最大的变量槽数量。普通方法与 static 方法在第 $0$ 个槽位的存储有所不同，非 static 方法的第 $0$ 个槽位存储方法所属对象实例的引用。</p><blockquote><p>Slot 复用？</p></blockquote><p>为了尽可能的节省栈帧空间，局部变量表中的 <strong>Slot 是可以复用</strong>的。方法中定义的局部变量，其作用域不一定会覆盖整个方法。当方法运行时，如果已经超出了某个变量的作用域，即变量失效了，那这个变量对应的 Slot 就可以交给其他变量使用，也就是所谓的 Slot 复用。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">66</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当虚拟机运行 test 方法，就会创建一个栈帧，并压入到当前线程的栈中。当运行到 <code>int a = 66</code> 时，在当前栈帧的局部变量中创建一个 Slot 存储变量 a，当运行到 <code>int b = 55</code> 时，此时已经超出变量 a 的作用域（变量 a 的作用域在{}所包含的代码块中），此时 a 就失效了，变量 a 占用的 Slot 可以交给 b 来使用，这就是 Slot 复用。</p><p>Slot 复用虽然节省了栈帧空间，但是会直接影响到系统的垃圾收集行为。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码很简单，先向内存中填充了 64M 的数据，然后通知虚拟机进行垃圾回收。为了更清晰的查看垃圾回收的过程，在虚拟机的运行参数中加上 <code>-verbose:gc</code>，这个参数的作用就是打印 GC 信息。</p><p><img src="afas.png" alt=""></p><p>打印的GC信息如下：</p><p><img src="reh.png" alt=""></p><p>箭头前后的数据分别表示垃圾收集 GC 前后所有存活对象使用的内存容量，说明有70M-68M=2M 的对象容量被回收，而虚拟机没有回收这 64M 内存。为什么没有被回收？当执行 System.gc() 方法时，变量 placeholder 还在作用域范围之内，虚拟机是不会回收的，它还是“有效”的。</p><p>对上面的代码稍作修改，使其作用域“失效”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是虚拟机还是没有回收 placeholder 变量占用的 64M 内存，再对代码稍作修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 System.gc() 方法之前，加入 <code>int a = 0</code>，再执行方法，查看垃圾回收情况。</p><p><img src="qfgh.png" alt=""></p><p>发现 placeholder 变量占用的 64M 内存空间被回收了。</p><p>第一次修改中，限定了 placeholder 的作用域，但之后并没有任何对局部变量表的读写操作，placeholder 变量在局部变量表中占用的 Slot 没有被其它变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。所以 placeholder 变量没有被回收。</p><p>第二次修改后，运行到 int a = 0 时，已经超过了 placeholder 变量的作用域，此时 placeholder 在局部变量表中占用的 Slot 可以交给其他变量使用。而变量a正好复用了 placeholder 占用的 Slot，至此局部变量表中的 Slot 已经没有 placeholder 的引用了，虚拟机就回收了 placeholder 占用的 64M 内存空间。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈的<strong>元素可以是任意的Java数据类型</strong>。方法刚开始执行时，操作数栈是空的，在方法执行过程中，通过字节码指令对操作数栈进行压栈和出栈的操作。</p><p>通常进行<strong>算数运算</strong>的时候是通过操作数栈来进行的，又或者是在调用其他方法的时候通过操作数栈进行<strong>参数传递</strong>。操作数栈可以理解为栈帧中用于计算的临时数据存储区。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStack</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        add(<span class="number">100</span>, <span class="number">98</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add 方法刚开始执行时，操作数栈是空的。首先把局部变量 $0$ 压栈，即 $100$ 入操作数栈。然后执行把局部变量 $1$ 压栈，即 $98$ 入操作数栈。接着执行弹出两个变量（$100$ 和 $98$ 出操作数栈），对 $100$ 和 $98$ 进行求和，然后将结果 $198$ 压栈。然后弹出结果（出栈）。<br>局部变量表和操作数栈的变化情况如下图：</p><p><img src="20190409205401344.jpg" alt=""></p><blockquote><p>栈中可能出现哪些异常？</p></blockquote><ul><li>StackOverflowError：如果采用固定大小的 Java 虚拟机栈，线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，则抛出栈溢出错误。</li><li>OutOfMemoryError：如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，则抛出内存不足。</li></ul><blockquote><p>如何设置栈参数？</p></blockquote><p>使用参数 <strong>-Xss</strong> 设置线程的最大栈空间。由于栈是<strong>线程私有</strong>的，线程数越多，占用栈空间越大。</p><p>栈的大小直接决定函数调用的最大可达深度，这也是慎用递归调用的原因。递归调用时，每次调用方法都会创建栈帧并压栈。当调用一定次数之后，所需栈的大小已经超过了虚拟机运行配置的最大栈参数，就会抛出 StackOverflowError 异常。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>堆是 Java 虚拟机所管理的内存中最大的一块存储区域。堆内存被所有<strong>线程共享</strong>。主要存放使用 <strong>new</strong> 关键字创建的对象。所有<strong>对象实例以及数组</strong>都要在堆上分配。垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间。</p><p>Java 堆分为<strong>年轻代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation）；年轻代又分为伊甸园（Eden）和幸存区（Survivor区）；幸存区又分为 From Survivor 空间和 To Survivor 空间。</p><p>老年代存储<strong>长期存活的对象和大对象</strong>。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发 <strong>Full GC</strong>。</p><p><strong>Full GC </strong>是清理整个堆空间，包括年轻代和老年代。如果 Full GC 之后，堆中仍然无法存储对象，就会抛出<strong>OutOfMemoryError </strong>异常。</p><p>Java 堆设置常用参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>堆内存初始大小</td></tr><tr><td>-Xmx（MaxHeapSize）</td><td>堆内存最大允许大小，一般不要大于物理内存的80%</td></tr><tr><td>-XX:NewSize（-Xns）</td><td>年轻代内存初始大小</td></tr><tr><td>-XX:MaxNewSize（-Xmn）</td><td>年轻代内存最大允许大小，也可以缩写</td></tr><tr><td>-XX:NewRatio</td><td>新生代和老年代的比值，值为4 表示新生代:老年代=1:4</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>年轻代中Eden区与Survivor区的容量比例值，默认为8</td></tr><tr><td>XX:+HeapDumpOnOutOfMemoryError</td><td>内存溢出时，导出堆信息到文件</td></tr><tr><td>-XX:MaxTenuringThreshold=7</td><td>表示如果在幸存区移动多少次没有被垃圾回收，进入老年代</td></tr></tbody></table></div><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区同 Java 堆一样是被所有<strong>线程共享</strong>的区间，用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。关闭 JVM 会释放方法区的内存。</p><p>JDK1.8 使用元空间 <strong>MetaSpace</strong> 替代方法区，元空间并不在 JVM 中，而是使用本地内存。元空间两个参数：</p><ul><li>MetaSpaceSize：初始化元空间大小，控制发生 GC 的阈值</li><li>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</li></ul><p>常量池是方法区的一部分，存储编译器生成的各种字面量和符号引用。</p><p>字面量就是 Java 中常量的意思，包括字符串，final 修饰的常量和基本数据类型的值。</p><p>符号引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符。</p><blockquote><p>常量池有什么用 ？</p></blockquote><p>常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><ul><li><strong>Integer 常量池</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestIntegerCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="number">66</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> integer(<span class="number">66</span>);</span><br><span class="line">        Integer i3 = <span class="number">66</span>;</span><br><span class="line">        Integer i4 = <span class="number">66</span>;</span><br><span class="line">        Integer i5 = <span class="number">150</span>;</span><br><span class="line">        Integer i6 = <span class="number">150</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i5 == i6);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i1 和 i2 使用 new 关键字，每 new 一次都会在堆上创建一个对象，所以 <code>i1 == i2</code> 为 false。</p><p><code>Integer i3 = 66</code> 实际上有一步<strong>装箱</strong>的操作，即将 int 型的 66 装箱成 Integer，通过 Integer 的 valueOf 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Integer 的 valueOf 方法判断变量是否在 <strong>IntegerCache</strong> 的最小值（$-128$）和最大值（$127$）之间，如果在，则返回常量池中的内容，否则 new 一个 Integer 对象。而 IntegerCache 是 Integer的静态内部类，作用就是将 $[-128,127]$ 之间的数”缓存”在 IntegerCache 类的 cache 数组中(这个 Integer 数组包含 $-128$ 到 $127$ 之间的所有值)，valueOf 方法就是调用常量池的 cache 数组，将 i3、i4 变量的引用指向常量池中，没有真正的创建对象。</p><p>而 <code>i5 == i6</code> 为 false，就是因为 $150$ 不在 Integer 常量池的最大最小值之间 $[-128,127]$，从而 new 了一个对象。</p><p>IntegerCache 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;<span class="comment">//最小值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;<span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];<span class="comment">//缓存数组</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//私有化构造方法，不让别人创建它。单例模式的思想</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//类加载的时候，执行静态代码块。作用是将-128到127之间的数缓冲在cache[]数组中</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];<span class="comment">//初始化cache数组，根据最大最小值确定</span></span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)<span class="comment">//遍历将数据放入cache数组中</span></span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一段<strong>拆箱</strong>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Integer i1 = <span class="keyword">new</span> Integer(<span class="number">4</span>);</span><br><span class="line">       Integer i2 = <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">       Integer i3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">       System.out.print(i3 == i1+i2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于 i1 和 i2 是 Integer 对象，是不能使用+运算符的。首先 i1 和 i2 进行自动拆箱操作，拆箱成int后再进行数值加法运算。i3 也是拆箱后再与之比较数值是否相等的。所以 <code>i3 == i1+i2</code> 其实是比较的 int 型数值是否相等，所以为 true。</p><ul><li>String 常量池</li></ul><p>String 是由 final 修饰的类，是不可以被继承的。通常有两种方式来创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则直接将 str 引用指向常量池中的“abcd”。</span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p>对于 String 类，equals 方法用于比较字符串内容是否相同；== 号用于比较内存地址是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       String str2 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在栈上存放变量引用 str1，然后通过符号引用去常量池中找是否有 abcd，没有，则将 abcd 存储在常量池中，然后将 str1 指向常量池的 abcd。创建 str2 对象时，在常量池中发现已经有 abcd 了，就将 str2 引用直接指向 abcd 。所以 <code>str1 == str2</code>，指向同一个内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str1 和 str2 使用 new 创建对象，两个引用指向堆中两个不同的对象，所以为 false。</p><blockquote><p>关于字符串 + 号连接问题</p></blockquote><p>对于字符串<strong>常量</strong>的 + 号连接，在程序编译期，JVM就会将其优化为 + 号连接后的值。所以在编译期其字符串常量的值就确定了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a1&quot;</span>;   </span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;   </span><br><span class="line">System.out.println((a == b)); <span class="comment">//result = true</span></span><br></pre></td></tr></table></figure><p>对于字符串<strong>引用</strong>的 + 号连接问题，由于字符串引用在编译期是无法确定下来的，在程序的运行期动态分配并创建新的地址存储对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    System.out.print(str2 == str3);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 jad 反编译工具反编译代码后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s2 = (<span class="keyword">new</span> StringBuilder()).append(s).append(<span class="string">&quot;b&quot;</span>).toString();</span><br><span class="line">        System.out.print(s1 = s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 new 了一个 StringBuilder 对象，然后使用 append 方法优化了 + 操作符。new 在堆上创建对象，而 <code>String s1=“ab”</code> 则是在常量池中创建对象，两个应用所指向的内存地址是不同的，所以 <code>s1 == s2</code> 结果为 false。</p><p><strong>在 for 循环中操作字符串的优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用+号连接字符串，每循环一次，就会新建StringBuilder对象，append后就“抛弃”了它。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果在循环外创建StringBuilder对象，在循环中使用append方法追加字符串，可以节省 n-1 次创建和销毁对象的时间。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>使用 final 修饰的字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        System.out.print(str2 == str3);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final 修饰的变量是一个常量，编译期就能确定其值，所以 <code>str1 + &quot;b&quot;</code> 就等同于 “a” + “b”，结果是 true。</p><p><strong>String 对象的 intern 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3.intern() == s);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s3 调用 intern 方法，返回的是s3的内容 “ab” 在常量池中的地址值。所以 <code>s3.intern() == s</code> 结果为 true。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运行时数据区&quot;&gt;&lt;a href=&quot;#运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区&quot;&gt;&lt;/a&gt;运行时数据区&lt;/h1&gt;&lt;p&gt;Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JMM&amp;volatile关键字</title>
    <link href="http://10185102110.github.io/2021/08/08/JMM-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://10185102110.github.io/2021/08/08/JMM-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-08-08T08:55:59.000Z</published>
    <updated>2021-09-14T13:53:20.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-内存模型-JMM"><a href="#Java-内存模型-JMM" class="headerlink" title="Java 内存模型 (JMM)"></a>Java 内存模型 (JMM)</h1><p><img src="1.png.jpg" alt=""></p><p>JMM 规定所有变量都存在主存中，每个线程又有自己的工作内存，可以理解成 CPU 上的高速缓存。所以，线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值同步回主存。</p><p><strong>主内存：</strong>主内存被所有的线程共享，对于一个共享变量，主内存中存储的就是它“本尊”。</p><p><strong>工作内存：</strong>每个线程都有自己的工作内存，对于共享变量来说，工作内存中存储的是它的“副本”。</p><p>在线程执行时，首先会从主存中 read 变量值，再 load 到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p><p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;  <span class="comment">// 假设i初值为0</span></span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span>： load i from 主存    <span class="comment">// i = 0</span></span><br><span class="line">        i + <span class="number">1</span>             <span class="comment">// i = 1</span></span><br><span class="line">线程<span class="number">2</span>： load i from主存     <span class="comment">// 因为线程1还没将i的值写回主存，所以i还是0</span></span><br><span class="line">        i + <span class="number">1</span>            <span class="comment">//i = 1</span></span><br><span class="line">线程<span class="number">1</span>:  save i to 主存</span><br><span class="line">线程<span class="number">2</span>： save i to 主存</span><br></pre></td></tr></table></figure><p>如果两个线程按照上面的执行流程，那么 i 最后的值居然是 $1$。如果最后的写回生效的慢，再读取 i 的值，都可能是 $0$，这就是缓存不一致问题。</p><p>JMM 主要就是围绕着如何在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这 $3$ 个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而 volatile 跟可见性和有序性都有关。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>Java 中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要么做完，要么就没有执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">2</span>; <span class="comment">// 读取操作，是原子的</span></span><br><span class="line">j = i; <span class="comment">// 先读取i的值，再赋值给j，不是原子的</span></span><br><span class="line">i++;   <span class="comment">// 读取i的值，定义常量1，i加1，写回内存，不是原子的</span></span><br><span class="line">i = i + <span class="number">1</span>; <span class="comment">// 等效于i++</span></span><br></pre></td></tr></table></figure><p>JMM 只实现了基本的原子性，像上面 i++ 那样的操作，必须借助于 synchronized 和 Lock 来保证整块代码的原子性。线程在释放锁之前，必然会把 i 的值刷回到主存的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>一个线程修改共享变量，能够被其它线程同时感知。</p><p>Java 利用 volatile 来提供可见性。 当一个变量被 volatile 修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。其实通过 synchronized 和 Lock 也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是 synchronized 和 Lock 的开销都更大。 </p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JMM 是允许编译器和处理器对指令重排序的，但是规定了 as-if-serial 语义，即不管怎么重排序，程序的执行结果不能改变。</p><p>比如下面的程序段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1</span>;        <span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> s= pi * r * r;<span class="comment">//C</span></span><br></pre></td></tr></table></figure><p>上面的语句，可以按照 A-&gt;B-&gt;C 执行，也可以按照 B-&gt;A-&gt;C 的顺序执行，因为 A、B 是两句独立的语句，而 C 则依赖于 A、B，所以 A、B 可以重排序，但是 C 却不能排到 A、B 的前面。JMM 保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">bool flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程 $1$ 先执行 write，随后线程 $2$ 再执行multiply，最后 ret 的值一定是 $4$ 吗？</p><p><img src="2.png.jpg" alt=""></p><p>如图所示，write 方法里的 $1$ 和 $2$ 做了重排序，线程 $1$ 先对 flag 赋值为 true，随后执行到线程 $2$，ret 直接计算出结果，再到线程 $1$，这时候 a 才赋值为 $2$。这时候可以为 flag 加上 volatile 关键字，禁止重排序，可以确保程序的<strong>有序性</strong>，也可以上重量级的 synchronized 和 Lock 来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p><h1 id="volatile-关键字如何满足并发编程的三大特性？"><a href="#volatile-关键字如何满足并发编程的三大特性？" class="headerlink" title="volatile 关键字如何满足并发编程的三大特性？"></a>volatile 关键字如何满足并发编程的三大特性？</h1><p>volatile 之所以能有这样的特性，得益于 Java 当中的先行发生原则。</p><p><strong>先行发生原则</strong>（happens-before）：如果一个事件必须发生在另一个事件之前，结果必须反映，即使这些事件是乱序执行的。这里的事件指的是各种指令操作，比如读写、初始化、锁。</p><p><code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code> 定义了如下 happens-before 规则：</p><ul><li><p>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</p></li><li><p>监视器锁规则：对一个线程的解锁，happens-before 于随后对这个线程的加锁。</p></li><li><p>volatile 变量规则： 对一个 volatile 域的写，happens-before 于后续对这个 volatile 域的读。</p></li><li><p>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C。</p></li><li><p>start() 规则： 如果线程 A 执行操作 ThreadB_start()(启动线程B) , 那么 A 线程的 ThreadB_start() happens-before 于 B 中的任意操作。</p></li><li><p>join()原则：如果 A 执行 ThreadB.join() 并且成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。</p></li><li><p>interrupt() 原则： 对线程 interrupt() 方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测是否有中断发生。</p></li><li><p>finalize() 原则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始。</p></li></ul><p>$(1)$ 规定线程每次修改变量副本后<strong>立刻同步到主内存</strong>中，用于保证其它线程可以看到自己对变量的修改。</p><p>$(2)$ 规定线程每次使用变量前，先从主内存中<strong>刷新最新的值</strong>到工作内存，用于保证能看见其它线程对变量修改的最新值。</p><p>$(3)$ 为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来<strong>防止指令重排序</strong>。</p><blockquote><p>总结 volatile 的两个特性</p></blockquote><ul><li>保证变量在线程之间的可见性，不能保证原子性。</li><li>阻止编译和运行时的指令重排，保证有序性。</li></ul><h1 id="volatile-底层实现机制"><a href="#volatile-底层实现机制" class="headerlink" title="volatile 底层实现机制"></a>volatile 底层实现机制</h1><p>生成汇编代码可以发现 volatile 关键字的代码多出一个 lock 前缀指令，它相当于一个内存屏障。</p><p>内存屏障提供了以下功能： </p><ul><li>重排序时不能把后面的指令重排序到内存屏障之前的位置 。</li><li>写入动作会引起别的 CPU 或者别的内核无效化其 Cache，相当于让新写入的值对别的线程可见。</li><li>使得本 CPU 的 Cache 写入内存。</li></ul><h1 id="volatile-和-synchronized-区别"><a href="#volatile-和-synchronized-区别" class="headerlink" title="volatile 和 synchronized 区别"></a>volatile 和 synchronized 区别</h1><ul><li>关键字 volatile 是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 要好，并且只能修改变量，而 synchronized 可以修饰方法，以及代码块。</li><li>多线程访问 volatile 不会发生阻塞，而 synchronized 会出现阻塞</li><li>volatile 能保证数据的可见性，但不能保证原子性；而 synchronized 可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步</li><li>关键字 volatile 解决的下变量在多线程之间的可见性；而 synchronized 解决的是多线程之间资源同步问题</li></ul><h1 id="volatile-的应用"><a href="#volatile-的应用" class="headerlink" title="volatile 的应用"></a>volatile 的应用</h1><p><strong>(1)</strong> 状态量标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> bool flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种对变量的读写操作，标记为 volatile 可以保证修改对线程立刻可见。比 synchronized,Lock 有一定的效率提升。</p><p><strong>(2)</strong> 单例模式，双重检查锁定(DCL)</p><ul><li><p>经典的懒汉式单例实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程的情况下，多个线程有可能会同时进入 <code>if (singleton == null)</code> ，执行了多次 <code>singleton = new Singleton()</code>，从而破坏单例。</p></li><li><p>允许指令重排序的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在检测到 <code>singleton==null</code> 后，会在同步块中再次判断，可以保证同一时间只有一个线程可以初始化单例。但仍然存在问题，原因就是 Java 中 <code>singleton = new Singleton()</code> 语句并不是一个原子指令，而是由三步组成：</p><ol><li>为对象分配内存</li><li>初始化对象</li><li>将对象的内存地址赋给引用</li></ol><p>但是经过<strong>指令重排序</strong>后，会变成：</p><ol><li>为对象分配内存</li><li>将对象的内存地址赋给引用（会使得 <code>singleton != null</code>）</li><li>初始化对象</li></ol><p>所以存在一种情况，当线程 A 已经将内存地址赋给引用时，但实例对象并没有完全初始化，同时线程 B 判断 singleton 已经不为 null，就会导致 B 线程<strong>访问到未初始化的变量</strong>从而产生错误。</p></li><li><p>避免初始化指令重排序的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码对 singleton 变量添加了 volatile 修饰，可以阻止局部指令重排序。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-内存模型-JMM&quot;&gt;&lt;a href=&quot;#Java-内存模型-JMM&quot; class=&quot;headerlink&quot; title=&quot;Java 内存模型 (JMM)&quot;&gt;&lt;/a&gt;Java 内存模型 (JMM)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;1.png.jpg&quot; a</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池&amp;Executor框架</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%E6%A1%86%E6%9E%B6/</id>
    <published>2021-08-08T08:55:31.000Z</published>
    <updated>2021-08-31T10:24:39.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Executor-框架基础"><a href="#Executor-框架基础" class="headerlink" title="Executor 框架基础"></a>Executor 框架基础</h1><blockquote><p>为什么需要线程池？</p></blockquote><p>在 Java中，使用线程来执行异步任务时，线程的创建和销毁需要一定的开销，如果我们为每一个任务创建一个新的线程来执行的话，那么这些线程的创建与销毁将消耗大量的计算资源，这样的方式可能会使处于高负荷状态的应用最终崩溃。</p><p>我们将在线程池中创建若干条线程，当有任务需要执行时就从该线程池中获取一条线程来执行任务，如果一时间任务过多，超出线程池的线程数量，那么后面的线程任务就进入一个等待队列进行等待，直到线程池有线程处于空闲时才从等待队列获取要执行的任务进行处理，这样就大大减少了线程创建和销毁的开销。</p><h2 id="两级调度模型"><a href="#两级调度模型" class="headerlink" title="两级调度模型"></a>两级调度模型</h2><p>在 Java 线程启动时会创建一个本地操作系统线程，当该 Java 线程终止时，这个操作系统线程也会被回收。而每一个 Java 线程都会被一对一映射为本地操作系统的线程，操作系统会调度所有的线程并将它们分配给可用的 CPU。</p><p>在上层，Java 多线程程序把应用分为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这种两级调度模型如下图所示：</p><p><img src="20160314222941341.png" alt=""></p><p>应用程序通过 Executor 框架控制上层的调度，而下层的调度由操作系统内核控制。</p><h2 id="Executor-框架的结构"><a href="#Executor-框架的结构" class="headerlink" title="Executor 框架的结构"></a>Executor 框架的结构</h2><p>Executor 框架的结构主要包括三部分：</p><ul><li>任务：包括被执行任务需要实现的接口：Runnable 接口或 Callable 接口。</li><li>任务的执行：包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 EexcutorService 接口。Executor 的两个关键类实现了 ExecutorService 接口（ThreadPoolExecutor 和ScheduledThreadPoolExecutor）。</li><li>异步计算的结果：包括接口 Future 和实现 Future 接口的 FutureTask 类。</li></ul><p><img src="20160314223043311.png" alt=""></p><p>Extecutor 是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来。<br>ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。<br>ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<br>Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果。<br>Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或者 ScheduledThreadPoolExecutor 执行。区别就是 Runnable 无法返回执行结果，而 Callable 可以返回执行结果。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor 是线程的真正实现，通常使用工厂类 Executors 来创建，但它的构造方法提供了一系列参数来配置线程池.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>corePoolSize</strong>：线程池的核心线程数，默认核心线程会一直在线程池中存活，即使它们处理闲置状态。</p><p><strong>maximumPoolSize</strong>：线程池所能容纳的最大线程数量，当活动线程数到达该数值后，后续的新任务将被阻塞。</p><p><strong>keepAliveTime</strong>：非核心线程闲置时的超时时长，超过时长非核心线程就会被回收。当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 true 时，keepAliveTime 同样会作用于核心线程。</p><p><strong>unit</strong>：用于指定 keepAliveTime 参数的时间单位。常用的有 TimeUnit.MILLISECONDS(毫秒)，TimeUnit.SECONDS(秒)以及 TimeUnit.MINUTES(分钟)等。</p><p><strong>workQueue</strong>：线程池中的任务队列，通过线程池的 execute 方法提交的 Runnable 对象会存储在这个队列中。</p><p><strong>threadFactory</strong>：线程工厂，为线程池提供创建新线程的功能。ThreadFactory 是一个接口，它只有一个方法：<code>Thread newThread(Runnable r)</code>。</p><p><strong>defaultHandler</strong>：RejectExecutionHandler，这个参数表示当 ThreadPoolExecutor 已经关闭或者已经饱和时，execute 方法将会调用 Handler 的 rejectExecution 方法来通知调用者，默认情况下是抛出一个RejectExecutionException 异常。</p><p>ThreadPoolExecutor 执行任务时的大致规则：</p><ol><li>如果线程池的数量还未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li><li>如果线程池中的线程数量已经达到或者超出核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li><li>如果在步骤 2 中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li><li>如果在步骤 3 中线程数量已经达到线程池规定的最大值，那么就会拒绝执行此任务， ThreadPoolExecutor 会调用 RejectExecutionHandler 的 rejectExecution方法来通知调用者。</li></ol><h1 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h1><h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>FixedThreadPool 模式会使用一个优先固定数目的线程来处理若干数目的任务。</p><p>创建 FixedThreadPool 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p> FixedThreadPool 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>corePoolSize 和 maximumPoolSize 参数都被设置为 nThreads，即核心线程数和最大线程数是一样的。</p><p>keepAliveTime 设置为 $0$L，就说明非核心线程会立即被终止。</p><p>FixedThreadPool 的 execute() 方法的运行流程：</p><p><img src="20160314223220078.png" alt=""></p><ol><li>如果当前运行线程数少 corePoolSize，则创建一个新的线程来执行任务。</li><li>如果当前线程池的运行线程数等于 corePoolSize，那么后面提交的任务将加入 LinkedBlockingQueue。</li><li>线程在执行完图中的 $1$ 后，会在循环中反复从 LinkedBlockingQueue 获取任务来执行。</li><li>FixedThreadPool 使用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列容量为Integer.MAX_VALUE），所以运行中的 FixedThreadPool 不会拒绝任务，那么也不会调用 RejectExecutionHandler 的 rejectExecution 方法抛出异常。</li></ol><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">3</span>;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;  <span class="comment">//线程号 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">my</span><span class="params">()</span> </span>&#123;&#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">my</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#Thread&quot;</span> + id + <span class="string">&quot;(&quot;</span> +   </span><br><span class="line">            (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">&quot;my!&quot;</span>) + <span class="string">&quot;) &quot;</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            System.out.println(status());   </span><br><span class="line">            Thread.yield();   </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;      </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//三个线程来执行五个任务   </span></span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;  </span><br><span class="line">        exec.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#Thread0(<span class="number">2</span>) </span><br><span class="line">#Thread1(<span class="number">2</span>) </span><br><span class="line">#Thread1(<span class="number">1</span>) </span><br><span class="line">#Thread1(my!) </span><br><span class="line">#Thread2(<span class="number">2</span>) </span><br><span class="line">#Thread3(<span class="number">2</span>) </span><br><span class="line">#Thread2(<span class="number">1</span>) </span><br><span class="line">#Thread2(my!) </span><br><span class="line">#Thread3(<span class="number">1</span>) </span><br><span class="line">#Thread0(<span class="number">1</span>) </span><br><span class="line">#Thread3(my!) </span><br><span class="line">#Thread4(<span class="number">2</span>) </span><br><span class="line">#Thread0(my!) </span><br><span class="line">#Thread4(<span class="number">1</span>) </span><br><span class="line">#Thread4(my!) </span><br></pre></td></tr></table></figure><h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><p>CachedThreadPool 首先会按照需要创建足够多的线程来执行任务。随着程序执行的过程，有的线程执行完任务可以被重新循环使用时，才不再创建新的线程。</p><p>创建 CachedThreadPool 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool=Executors.newCachedThreadPool(); </span><br></pre></td></tr></table></figure><p>CachedThreadPool 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool 的 corePoolSize 被设置为 $0$，而 maximumPoolSize 被设置 Integer.MAX_VALUE，即 maximumPoolSize 是无界的，而 keepAliveTime 被设置为 60L，单位为秒。也就是空闲线程等待时间最长为 $60$ 秒，超过该时间将会被终止。CachedThreadPool 使用的是没有容量的 SynchronousQueue 作为线程池的工作队列，但其 maximumPoolSize 是无界的，也就是意味着如果主线程提交任务的速度高于 maximumPoolSize 中线程处理任务的速度时 CachedThreadPool 将会不断的创建新的线程，在极端情况下， CachedThreadPool 会因为创建过多线程而耗尽 CPU 和内存资源。<br>CachedThreadPool 的 execute() 方法的运行流程：</p><p><img src="20160314223430065.png" alt=""></p><ol><li>首先执行 SynchronousQueue.offer(Runnable task)，添加一个任务。如果当前 CachedThreadPool 中有空闲线程正在执行 SynchronousQueue.poll，那么主线程执行 offer 操作与空闲线程执行 poll 操作配对成功，主线程把任务交给空闲线程执行，execute() 方法执行完成，否则进入第 2 步。</li><li>当 CachedThreadPool 初始线程数为空时，或者当前没有空闲线程，CachedThreadPool 会创建一个新的线程来执行任务， execute() 方法执行完成。</li><li>在步骤 2 中创建的新线程将任务执行完成后，会执行 SynchronousQueue.poll，这个 poll 操作会让空闲线程最多在 SynchronousQueue 中等待 $60$ 秒，如果 $60$ 秒内主线程提交了一个新任务，那么这个空闲线程将会执行主线程提交的新任务，否则，这个空闲线程将被终止。因此长时间保持空闲的 CachedThreadPool 是不会使用任何资源的。</li></ol><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;   </span><br><span class="line">        exec.shutdown();       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h2><p>SingleThreadExecutor 模式只会创建一个线程。如果多个任务被提交给 SingleThreadExecutor，那么这些任务会被保存在一个队列中，并且会按照任务提交的顺序，一个先执行完成再执行另外一个线程。这种特点可以用来处理共享资源的问题而不需要考虑同步问题。</p><p>创建 SingleThreadExecutor 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor(); </span><br></pre></td></tr></table></figure><p>SingleThreadExecutor 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从静态方法可以看出 SingleThreadExecutor 的 corePoolSize 和 maximumPoolSize 被设置为 $1$，其他参数则与 FixedThreadPool 相同。</p><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>FixedThreadPool：适合为了满足资源管理需求，而需要限制当前线程的数量的应用场景，它适用于负载比较重的服务器。</p><p>CachedThreadPool：大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。SingleThreadExecutor：适用于需要保证执行顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的场景。</p><h1 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h1><h2 id="ScheduledThreadPoolExecutor-运行机制"><a href="#ScheduledThreadPoolExecutor-运行机制" class="headerlink" title="ScheduledThreadPoolExecutor 运行机制"></a>ScheduledThreadPoolExecutor 运行机制</h2><p>ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor。它主要用来在给定的延迟之后执行任务，或者定期执行任务。ScheduledThreadPoolExecutor 的功能与 Timer 类似，但比 Timer 更强大，更灵活，Timer 对应的是单个后台线程，而 ScheduledThreadPoolExecutor 可以在构造函数中指定多个对应的后台线程数。</p><p>ScheduledThreadPoolExecutor 的运行机制：</p><p><img src="20160314223650662.png" alt=""></p><ol><li>当调用 ScheduledThreadPoolExecutor 的 <code>scheduleAtFixedRate()</code>方法或者 <code>scheduleWithFixedDelay()</code> 方法时，会向 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduleFutureTask。DelayQueue 是一个无界队列。</li><li>线程池中的线程从 DelayQueue 中获取 ScheduleFutureTask，然后执行任务。</li></ol><h2 id="ScheduledThreadPoolExecutor-的创建"><a href="#ScheduledThreadPoolExecutor-的创建" class="headerlink" title="ScheduledThreadPoolExecutor 的创建"></a>ScheduledThreadPoolExecutor 的创建</h2><p>Executors 可以创建两种类型的 ScheduledThreadPoolExecutor。</p><ul><li><p>ScheduledThreadPoolExecutor：可以执行多线程任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPoolExecutor=Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>SingleThreadScheduledExecutor：可以执行单条线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService singleThreadScheduledExecutor=Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure></li></ul><h2 id="ScheduledThreadPoolExecutor-案例"><a href="#ScheduledThreadPoolExecutor-案例" class="headerlink" title="ScheduledThreadPoolExecutor 案例"></a>ScheduledThreadPoolExecutor 案例</h2><p>首先创建一个 Runnable 对象，然后使用 ScheduledThreadPoolExecutor 的 Scheduled() 来执行延迟任务，输出执行时间。</p><p><strong>$(1)$ 延迟执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure><p><strong>command</strong>：一个实现 Runnable 接口的类。</p><p><strong>delay</strong>：延迟时间。</p><p><strong>unit</strong>： 用于指定 keepAliveTime 参数的时间单位。</p><p>这个方法会返回 ScheduledFuture 实例，用于获取线程状态信息和延迟时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Start. Time = &quot;</span>+getNowDate());</span><br><span class="line">     threadSleep();</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot; End. Time = &quot;</span>+getNowDate());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sleep 3秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadSleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNowDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line">  SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">  String ctime = formatter.format(currentTime); </span><br><span class="line">  <span class="keyword">return</span> ctime;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Current Time = &quot;</span>+getNowDate());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            my worker = <span class="keyword">new</span> my();</span><br><span class="line">            <span class="comment">//延迟10秒后执行</span></span><br><span class="line">            scheduledThreadPool.schedule(worker, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    scheduledThreadPool.shutdown();</span><br><span class="line">    <span class="keyword">while</span>(!scheduledThreadPool.isTerminated())&#123;</span><br><span class="line">        <span class="comment">//wait for all tasks to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNowDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line">  SimpleDateFormat formatter; </span><br><span class="line">    formatter = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">    String ctime = formatter.format(currentTime); </span><br><span class="line">  <span class="keyword">return</span> ctime;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Current Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">10</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">21</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">22</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">23</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">24</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">25</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">26</span></span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><p>线程任务确实在 $10$ 秒延迟后才开始执行，这就是 schedule() 方法的使用。</p><p><strong>$(2)$ 周期性执行</strong></p><ul><li><p>scheduleAtFixedRate 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit)</span><br></pre></td></tr></table></figure><p>scheduleAtFixedRate 方法的作用是预定在初始的延迟结束后，周期性地执行给定的任务，周期长度为 period，其中 initialDelay 为初始延迟。</p></li><li><p>scheduleWithFixedDelay 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> delay,TimeUnit unit);</span><br></pre></td></tr></table></figure><p>scheduleWithFixedDelay 方法的作用是预定在初始的延迟结束后周期性地执行给定任务，在一次调用完成和下一次调用开始之间有长度为 delay 的延迟， 其中 initialDelay 为初始延迟。</p></li></ul><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> ScheduledThreadPoolExecutor se = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ScheduledTask();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedPeriodSchedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设定可以循环执行的runnable,初始延迟为0，这里设置的任务的间隔为5秒</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">se.scheduleAtFixedRate(<span class="keyword">new</span> FixedSchedule(), <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fixedPeriodSchedule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSchedule</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  当前时间：&quot;</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-1  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-1  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Executor-框架基础&quot;&gt;&lt;a href=&quot;#Executor-框架基础&quot; class=&quot;headerlink&quot; title=&quot;Executor 框架基础&quot;&gt;&lt;/a&gt;Executor 框架基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为什么需要线程池？&lt;/p&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程安全</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2021-08-08T08:51:52.000Z</published>
    <updated>2021-08-28T04:48:05.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全等级"><a href="#线程安全等级" class="headerlink" title="线程安全等级"></a>线程安全等级</h1><p>根据线程的安全程度由强到弱，可以分为 $5$ 个等级。</p><ul><li><p>不可变</p><p>在 Java 中，不可变对象一定是线程安全的，比如 final 关键字修饰的数据不可修改，比如 String、Long、Integer。</p></li><li><p>绝对的线程安全</p><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。如 Random 、ConcurrentHashMap、Concurrent 集合、atomic。</p></li><li><p>相对的线程安全</p><p>通常来说线程是安全的，但对于一些特定顺序的连续调用就可能需要在调用端使用额外的同步手段来保证调用的正确性。大部分线程都属于这种类型，如 vector。</p></li><li><p>线程兼容</p><p>对象本身不提供线程安全机制，但是通过外部同步，可以在并发环境使用， 如 ArrayList、HashMap。</p><p>在使用这些对象的时候，都要考虑是否会发生线程安全问题。</p></li><li><p>线程对立</p><p>无论是否采用同步措施，都无法在并发中使用。</p></li></ul><h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><p><img src="20180315101631748.jpg" alt=""></p><h2 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h2><p>同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。</p><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>互斥是实现同步的一种手段，比如临界区、互斥量和信号量。</p><p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字。synchronized 是独占锁，可重入，加锁和解锁的过程自动进行，不必担心最后是否释放锁，易于操作，但不够灵活。synchronized 不可响应中断，一个线程获取不到锁就一直等着。</p><p>ReentrantLock 也是通过互斥来实现同步。ReentrantLock 也是独占锁，也可重入，加锁和解锁的过程需要手动进行，且次数需一样，否则其他线程无法获得锁，不易操作，但非常灵活。ReentrantLock 可以响应中断，可以实现公平锁机制(在锁上等待时间最长的线程将获得锁的使用权)。</p><p>ReentrantLock 的简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; test(),<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; test(),<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A获取锁</span><br><span class="line">线程A释放锁</span><br><span class="line">线程B获取锁</span><br><span class="line">线程B释放锁</span><br></pre></td></tr></table></figure><p>互斥同步最主要的问题就是进行<strong>线程阻塞和唤醒</strong>所带来的性能问题，因此这种同步也成为阻塞同步。</p><p>互斥同步属于一种<strong>悲观的并发策略</strong>，无论共享数据是否真的会出现竞争，它都要进行加锁。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p><strong>CAS</strong>：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，是一种<strong>乐观的并发策略</strong>。</p><p>CAS 是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换。</p><p>CAS机制当中使用了3个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。</p><p>举个例子：</p><p>在内存地址 $V$ 中，存储着值为 $10$ 的变量。此时线程 $1$ 想把变量的值 $+1$，对线程 $1$ 来说，旧的预期值 $A=10$ ，要修改的新值 $B=11$。在线程 $1$ 要提交更新之前，线程 $2$ 抢先一步，把内存地址 $V$ 中的变量值更新成 $11$。线程 $1$ 开始提交更新，发现 $A$ 不等于 $V$ 的实际值，提交失败。线程 $1$ 重新获取内存地址 $V$ 的当前值，并重新计算想要修改的新值。此时对线程 $1$ 来说，$A=11$，$B=12$，这个重新尝试的过程被称为自旋。这次比较幸运，没有其他线程改变地址 $V$ 的值。线程 $1$ 进行 Compare，发现 $A$ 和地址 $V$ 的实际值是相等的。线程 $1$ 进行 SWAP，把地址 $V$ 的值替换为 $B$，也就是 $12$。</p><p><strong>Atomic</strong> 包下的原子类是基于 CAS 实现的。原子操作类，指的是 java.util.concurrent.atomic 包下，一系列以 Atomic 开头的包装类。例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>。它们分别用于<code>Boolean</code>，<code>Integer</code>，<code>Long</code>类型的原子性操作。</p><p>下面是一个无阻塞多线程争抢资源的模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyType my = <span class="keyword">new</span> MyType();</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  flag:&quot;</span>+flag.get());</span><br><span class="line">        <span class="keyword">if</span> (flag.compareAndSet(<span class="keyword">true</span>,<span class="keyword">false</span>))&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始操作并使flag为&quot;</span>+flag.get());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            flag.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重试机制:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  flag:&quot;</span>+flag.get());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">0</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">0</span>开始操作并使flag为<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">1</span>开始操作并使flag为<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p><code>compareAndSet(true,false)</code> 方法要拆成 compare(true) 方法和 Set(false) 方法理解，是 compare(true) 等于 true 后，就马上设置共享内存为 false。</p><p>CAS 的缺点：</p><ol><li>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给 CPU 带来很大的压力。</li><li>CAS 机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 $3$ 个变量共同进行原子性的更新，就不得不使用 Synchronized 了。</li><li>无法解决 ABA 问题。ABA 就是一个值由 A 变为 B，再由 B 变为 A，使用 CAS 操作无法感知到该种情况下出现的变化，带来的后果很严重，比如银行内部员工，从系统挪走一百万，之后还了回来，系统却感知不到。</li></ol><p>解决 ABA 可以使每一次修改都带上时间戳，以记录版本号的形式使得 CAS 感知到这种狸猫换太子的操作。Java 提供了 AtomicStampedReference 类来解决，该类除了指定旧值与期盼值，还要指定旧的版本号与期盼的版本号。该类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>如果一个方法不涉及共享数据，那它自然不需要任何同步操作去保证正确性，因此有一些代码天生就是线程安全的。</p><h3 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h3><p>可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>如果一段代码中所需的数据必须与其他代码共享，那就看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的<strong>可见范围</strong>限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。</p><p>如“生产者-消费者”模式、Web交互模型中的“一个请求对应一个服务器线程“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程安全等级&quot;&gt;&lt;a href=&quot;#线程安全等级&quot; class=&quot;headerlink&quot; title=&quot;线程安全等级&quot;&gt;&lt;/a&gt;线程安全等级&lt;/h1&gt;&lt;p&gt;根据线程的安全程度由强到弱，可以分为 $5$ 个等级。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不可变&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-08T08:51:27.000Z</published>
    <updated>2021-08-28T04:47:37.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程，线程，多线程"><a href="#进程，线程，多线程" class="headerlink" title="进程，线程，多线程"></a>进程，线程，多线程</h1><ul><li>进程是资源分配的最小单位，有自己独立的地址空间，一个进程可以创建多个线程。</li><li>线程是程序执行和CPU调度的最小单位，线程共享本进程的地址空间，分为用户级线程和内核级线程。</li><li>一个进程如果只有一个线程，称为单线程程序；如果有多个线程，称为多线程程序。</li></ul><h1 id="多线程的创建与启动"><a href="#多线程的创建与启动" class="headerlink" title="多线程的创建与启动"></a>多线程的创建与启动</h1><p>创建多线程有两种方法，一种是继承Thread类重写run方法，另一种是实现Runnable接口重写run方法。</p><ul><li><p>继承Thread类重写run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByEx</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I&#x27;m a thread that extends Thread!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I&#x27;m a thread that implements Runnable !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//继承Thread启动的方法</span></span><br><span class="line">ThreadByEx t1=<span class="keyword">new</span> ThreadByEx();</span><br><span class="line">t1.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Runnable启动线程的方法</span></span><br><span class="line">ThreadByRunnable r = <span class="keyword">new</span> ThreadByRunnable();</span><br><span class="line">Thread t2 =<span class="keyword">new</span> Thread(r);</span><br><span class="line">t2.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>start()</code> 方法后并不是是立即的执行多线程的代码，而是使该线程变为可运行态，什么时候运行多线程代码是由操作系统决定的。</p></li></ul><h1 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h1><p>线程的 <code>thread.interrupt()</code> 方法向线程发送中断请求，将会设置该线程的中断状态位，即设置为 <code>true</code>，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为 <code>true</code>）。它并不像 <code>stop</code> 方法那样会中断一个正在运行的线程。(在 Java 早期版本中有一个 <code>stop</code> 方法，其他线程可以调用它终止线程，但是这个方法现在已经被弃用了，因为会造成一些线程不安全的问题)</p><p>判断线程是否被中断：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread.currentThread().isInterrupted()方法不会清除中断标示位，而Thread.interrupted()方法调用后会将中断标示位清除，即重新设置为false来判断。</span></span><br></pre></td></tr></table></figure><p>如果一个线程处于阻塞状态，即线程在检查中断标示时发现中断标示为 <code>true</code>，则会在阻塞方法（<code>sleep</code>、<code>join</code>、<code>wait</code>、1.5 中的 <code>condition.await</code> 及可中断的通道上的 I/O 操作方法）调用处抛出<code>InterruptedException</code> 异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为<code>false</code>。  </p><p>中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断。某些线程非常重要，以至于它们应该不理会中断，而是在处理完抛出的异常之后继续执行。但是更普遍的情况是，一个线程将把中断看作一个终止请求，这种线程的 <code>run()</code> 方法遵循如下形式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">//线程在wait或sleep期间被中断了</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//线程结束前做一些清理工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>try</code> 在 <code>while</code> 循环里时，应该在 <code>catch</code> 块里重新设置一下中断标示，因为抛出 <code>InterruptedException</code> 异常后，中断标示位会自动清除，此时应该这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            sleep(delay); <span class="comment">//Thread.sleep()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();<span class="comment">//重新设置中断标示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层中断异常的处理</strong>，最好是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>Thread.interrupt()</code> 中断非阻塞状态线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example1 thread = <span class="keyword">new</span> Example1();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        <span class="comment">// 发出中断请求</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔一秒检测是否设置了中断标示</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis(); <span class="comment">// 获取系统时钟</span></span><br><span class="line">            <span class="comment">// 使用while循环模拟 sleep</span></span><br><span class="line">            <span class="keyword">while</span> ((System.currentTimeMillis() - time &lt; <span class="number">1000</span>) ) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Starting thread...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Asking thread to stop...</span><br><span class="line">Thread exiting under request...</span><br><span class="line">Stopping application...</span><br></pre></td></tr></table></figure><p><strong>使用信号量中断非阻塞状态的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;<span class="comment">// 线程中断信号量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example2 thread = <span class="keyword">new</span> Example2();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); </span><br><span class="line">        <span class="comment">//sleep()方法阻塞当前进程，如果使用在main线程执行代码中，则阻塞的是main线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置中断信号量</span></span><br><span class="line">        thread.stop = <span class="keyword">true</span>;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔一秒检测一下中断信号量</span></span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 使用while循环模拟 sleep 方法，这里不要使用 sleep，否则在阻塞时会抛</span></span><br><span class="line"><span class="comment">             * InterruptedException异常而退出循环，这样while检测stop条件就不会执行.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> ((System.currentTimeMillis() - time &lt; <span class="number">1000</span>)) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>thread.interrupt()</code> 中断阻塞状态线程</strong></p><p><code>Thread.interrupt()</code> 的作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</p><p>具体来说，当对一个线程，调用 <code>interrupt()</code> 时，</p><ul><li>如果线程处于被阻塞状态（例如处于 sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个 InterruptedException 异常。</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example3 thread = <span class="keyword">new</span> Example3();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        thread.interrupt();<span class="comment">// 等中断信号量设置后再调用</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果线程阻塞，将不会去检查中断信号量stop变量，所以thread.interrupt()</span></span><br><span class="line"><span class="comment">                 * 会使阻塞线程从阻塞的地方抛出异常，让阻塞线程从阻塞状态逃离出来，并</span></span><br><span class="line"><span class="comment">                 * 在异常块进行相应的处理</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">// 线程阻塞，如果线程收到中断操作信号将抛出异常</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread interrupted...&quot;</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果线程在调用 Object.wait()方法，或者该类的 join() 、sleep()方法</span></span><br><span class="line"><span class="comment">                 * 过程中受阻，则其中断状态将被清除</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.isInterrupted());<span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">//中不中断由自己决定，如果需要真中断线程，则需要重新设置中断位，如果</span></span><br><span class="line">                <span class="comment">//不需要，则不用调用</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.isInterrupted());<span class="comment">// true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>interrupt()</code> 方法是不能中断死锁线程的，因为锁定的位置根本无法抛出异常。</p><p><strong>中断I/O操作</strong></p><p>尽管 <code>interrupt()</code> 被调用，线程也不会退出被阻塞状态，比如 ServerSocket的 <code>accept</code> 方法根本不抛出异常。所以需要调用阻塞该线程的套接字的 <code>close()</code> 方法，如果线程被 I/O 操作阻塞，当调用该套接字的 close 方法时，该线程在调用 accept 地方法将接收到一个SocketException (IOException 的子异常）异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> ServerSocket socket;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example4 thread = <span class="keyword">new</span> Example4();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        Thread.currentThread().interrupt();<span class="comment">// 调用interrupt方法</span></span><br><span class="line">        thread.socket.close();<span class="comment">// 再调用close方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not create the socket...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting for connection...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.accept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;accept() failed or interrupted...&quot;</span>);</span><br><span class="line">                Thread.currentThread().interrupt();<span class="comment">//重新设置中断标示位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>守护线程的唯一作用是为其他线程提供服务。计时线程就是一个典型的例子，它定时地发送“计时器滴答”信号告诉其他线程去执行某项任务。当只剩下守护线程时，虚拟机就退出了。另外 JVM 的垃圾回收、内存管理等线程都是守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.test;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@decrition</span> 守护线程代码示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demon</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread deamon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(),<span class="string">&quot;DaemonRunner&quot;</span>);</span><br><span class="line">deamon.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程</span></span><br><span class="line">deamon.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//在命令行打印异常信息在程序中出错的位置及原因</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;finally的代码在java虚拟机退出时不一定会执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 虚拟机退出时 Daemon线程中的 <code>finally</code> 代码块并不一定会执行，因此在构建 Daemon 线程时，不能依靠 <code>finally</code> 代码块中的内容来确保执行关闭或清理资源的逻辑。</p><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>在 Java 线程中，通过一个整型的成员变量 <code>Priority</code> 来控制线程优先级 ，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以用 <code>setPriority</code> 方法提高或降低任何一个线程优先级。可以将优先级设置在 <code>MIN_PRIORITY</code>（在 Thread 类定义为 1）与 <code>MAX_PRIORITY</code>（在 Thread 类定义为 10）之间的任何值。线程的默认优先级为 <code>NORM_PRIORITY</code>（在 Thread 类定义为 5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序。</p><h1 id="线程的转换关系"><a href="#线程的转换关系" class="headerlink" title="线程的转换关系"></a>线程的转换关系</h1><ul><li><p>新建状态</p><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p></li><li><p>就绪状态</p><p>当线程对象调用了 <strong>start()</strong> 方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。</p></li><li><p>运行状态</p><p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>阻塞状态</p><p>如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态</p><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p></li></ul><p><img src="20160313163538263.png" alt=""></p><p>图中的方法解析：</p><ul><li>Thread.sleep(long)：使当前线程进入阻塞状态，在指定时间内不会执行。 </li><li>Object.wait()：调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁。</li><li>Object.notifyAll()：从对象等待池中唤醒所有等待线程。</li><li>Object.notify()：通知一个在对象上等待的线程，使其从wait()返回，而返回的前提是该线程获取到了对象的锁。wait() 和 notify() 必须在 synchronized 函数或 synchronized 中进行调用。</li><li>Thread.yield()： 暂停当前正在执行的线程对象。</li><li>Thread.Join()：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</li></ul><p><strong>通过 wait()/notify() 实现等待/通知机制的示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A等待获取lock锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A获取了lock锁&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A将要运行lock.wait()方法进行等待&quot;</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A等待结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B等待获取lock锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B获取了lock锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B将要运行lock.notify()方法进行通知&quot;</span>);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程A等待获取lock锁</span><br><span class="line">线程A获取了lock锁</span><br><span class="line">线程B等待获取lock锁</span><br><span class="line">线程A将要运行lock.wait()方法进行等待</span><br><span class="line">线程B获取了lock锁</span><br><span class="line">线程B将要运行lock.notify()方法进行通知</span><br><span class="line">线程A等待结束</span><br></pre></td></tr></table></figure><h1 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h1><p>创建线程的方式有两种，一种是实现 Runnable 接口，另一种是继承 Thread，但是这两种方式都有个缺点，那就是在任务执行完成之后无法获取返回结果。从 JAVA SE 5.0 开始引入 Callable 和 Future，通过它们构建的线程，在任务执行完成后就可以获取执行结果。</p><p>线程创建的第三种方式就是实现 Callable 接口。</p><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable<V>接口</h2><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">      <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>该接口声明了一个 call() 方法，这个方法有返回值 V，也可以抛出异常。</p><p>无论是 Runnable 接口的实现类还是 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行，ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 都实现了  ExcutorService 接口，因此 Callable 需要和 Executor 框架中的 ExcutorService 结合使用。</p><p>ExecutorService 提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且指定了调用Future的get方法时返回的result对象</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p>除了自己实现 Callable 对象外，还可以使用工厂类 Executors 把一个 Runnable 对象包装成 Callable 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future<V>接口</h2><p>Future<V>接口是用来获取异步计算结果的，其实就是对 Runnable 或者 Callable 对象任务执行的结果进行获取 get()，取消 cancel()，判断是否完成 isDone() 等操作。</p><p>Future 接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法解析</p><ul><li><strong>V get()</strong> ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</li><li><strong>V get</strong>(Long timeout , TimeUnit unit) ：同上，但是有时间限制，如果阻塞时间超过设定的 timeout 时间，该方法将抛出异常。</li><li><strong>boolean isDone()</strong> ：如果任务执行结束，无论是正常结束或中途取消还是发生异常，都返回 true。</li><li><strong>boolean isCanceller()</strong> ：如果任务完成前被取消，则返回 true。</li><li><strong>boolean cancel</strong>(boolean mayInterruptRunning) ：如果任务还没开始，执行 cancel(…) 方法将返回 false；如果任务已经启动，执行 cancel(true) 方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回 true；当任务已经启动，执行 cancel(false) 方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回 false；当任务已经完成，执行cancel(…)方法将返回 false。</li></ul><h2 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h2><p>Future 只是一个接口，无法直接创建对象，因此需要其实现类 FutureTask。</p><p>FutureTask 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure><p>FutureTask 类实现了 RunnableFuture 接口，那么 RunnableFuture 接口的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 的两种构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 可以直接提交给 Executor 执行，也可以调用线程直接执行 <code>FutureTask.run()</code>。</p><p>FutureTask 的方法执行示意图：</p><p><img src="20160315150014001.png" alt=""></p><p>当 FutureTask 处于未启动或已启动状态时，如果此时执行 FutureTask.get() 方法将导致调用线程阻塞；当 FutureTask 处于已完成状态时，执行 FutureTask.get() 方法将导致调用线程立即返回结果或者抛出异常。</p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><ul><li><p>使用 Callable+Future 获取执行结果</p><p>Callable 实现类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable线程开始计算&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">sum=sum+i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable线程计算结束&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>submit</strong> 提交 Callable 任务，调用的是 execute(Runnable command) 方法，execute 执行 FutureTask 对象中的 run 方法，在 run 方法中调用 callable 中的 call 方法。总结一下，首先创建一个实现 Future 和 Runnable 的 FutureTask 对象并且把 Callable 对象通过构造函数注入到对象中，然后把 FutureTask 对象传入 execute 方法中，之后直接返回FutureTask对象。execute 方法执行完会把执行结果放入 FutureTask 对象，我们从对象中获得返回值。</p><p>Callable 执行测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建Callable对象任务</span></span><br><span class="line">my calTask=<span class="keyword">new</span> my();</span><br><span class="line"><span class="comment">//提交任务并获取执行结果</span></span><br><span class="line">Future&lt;Integer&gt; future =es.submit(calTask);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">es.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程在执行其他任务&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(future.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;future.get()--&gt;&quot;</span>+future.get());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;future.get()未获取到结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable线程开始计算</span><br><span class="line">主线程在执行其他任务</span><br><span class="line">Callable线程计算结束</span><br><span class="line">futureTask.get()--&gt;12497500</span><br><span class="line">主线程执行完成</span><br></pre></td></tr></table></figure></li><li><p>使用 Callable+FutureTask 获取执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建Callable对象任务</span></span><br><span class="line">my calTask=<span class="keyword">new</span> my();</span><br><span class="line"><span class="comment">//创建FutureTask</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(calTask);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">es.submit(futureTask);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">es.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程在执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;futureTask.get()--&gt;&quot;</span>+futureTask.get());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;futureTask.get()未获取到结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程，线程，多线程&quot;&gt;&lt;a href=&quot;#进程，线程，多线程&quot; class=&quot;headerlink&quot; title=&quot;进程，线程，多线程&quot;&gt;&lt;/a&gt;进程，线程，多线程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程是资源分配的最小单位，有自己独立的地址空间，一个进程可以创建多个线程</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E5%AE%B9%E5%99%A8/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2021-08-08T08:50:56.000Z</published>
    <updated>2021-08-28T04:47:56.965Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>容器主要包括 Collection 和 Map 两种。</p><p>Collection：存放独立元素的序列。</p><p>Map：存放key-value型的元素对。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Collection 接口包含 List、Set 以及 Queue 子接口。</p><p><img src="20190801230729141.png" alt=""></p><p><strong>Collection 和 Collections 有什么区别？</strong></p><p>Collection 是一个接口，它是 Set、List 等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>存储的元素是无序的，不可重复的。</p><ul><li><p>HashSet：基于哈希实现，支持快速查找，但它不保证元素的迭代顺序。</p></li><li><p>TreeSet：基于红黑树实现，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logN)；</p></li><li><p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。</p></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>存储的元素是有序的，可重复的。</p><ul><li><p>ArrayList：基于动态数组实现，随机访问的效率较高；</p></li><li><p>Vector：和 ArrayList 类似，每次扩容为 $2$ 倍空间，性能不如 ArrayList，但它用了 Synchronized 来实现线程同步。</p></li><li><p>LinkedList：基于双向循环链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。此外，LinkedList 还可以用作栈、队列和双端队列。</p></li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul><li><p>LinkedList：可以用它来支持双向队列；</p></li><li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先级队列。</p></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="20190801232854703.png" alt=""></p><ul><li><p>HashMap：基于哈希实现；</p></li><li><p>HashTable：和 HashMap 类似，但它是线程安全的，现在已被淘汰。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p></li><li><p>LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p></li><li><p>TreeMap：基于红黑树实现。</p></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><img src="Iterator-1.jpg" alt=""></p><p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p><p>Iterator 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的用法：</p><ol><li>使用方法 iterator() 要求容器返回一个 Iterator。第一次调用 Iterator 的 next() 方法时返回序列的第一个元素。</li><li>使用 next() 获得序列中的下一个元素。　</li><li>使用 hasNext() 检查序列中是否还有元素。　　</li><li>使用 remove() 将迭代器新返回的元素删除。　</li></ol><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>使用 <code>Arrays.asList()</code> 方法可以很方便地将数据转换为集合，但是转换后的集合不能使用修改的相关操作（add，remove，clear）等。</p><p><code>Arrays.asList()</code> 是泛型方法，传入的对象必须是对象数组。因此不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a); <span class="comment">//直接创建了一个ArrayList</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList(E[] array) &#123;</span><br><span class="line">     a = Objects.requireNonNull(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只是简单判断一下数组是否为null，如果不为null，就将array的地址赋值给a</span></span><br></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 将数组转换为集合后，底层其实还是数组。因此如果更改子列表的值，原数组也会发生变化。当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身，此时 List 的唯一元素就是这个数组。将 int 改成 Integer 就可以正常遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><h1 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>实现了 RandomAccess 接口，因此支持随机访问。</p><p>基于数组实现，ArrayList 具有动态扩容特性。</p><p>数组的默认大小为 $10$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>删除元素时需要调用 <code>System.arraycopy()</code> 对元素进行复制，因此删除操作成本很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加元素时使用 <code>ensureCapacity()</code> 方法来保证容量足够，如果不够时，需要使用 <code>grow()</code> 方法进行扩容，使得新容量为旧容量的 $1.5$ 倍（oldCapacity + (oldCapacity &gt;&gt; 1))。扩容操作需要把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>modCount</code> 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行<strong>序列化</strong>(把对象转化为可传输的字节序列过程)或者<strong>迭代</strong>等操作时，需要比较操作前后 modCount 是否改变，如果改变则需要抛出 ConcurrentModificationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap-原理"><a href="#HashMap-原理" class="headerlink" title="HashMap 原理"></a>HashMap 原理</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>使用拉链法来解决冲突，内部包含了一个 Entry 类型的数组 table，数组中的每个位置被当成一个桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><p>其中，Entry 就是存储数据的键值对，它包含了四个字段。从 next 字段我们可以看出 Entry 是一个链表，即每个桶会存放一个链表。</p><p><img src="8fe838e3-ef77-4f63-bf45-417b6bc5c6bb.png" alt=""></p><p>JDK 1.8 使用 Node 类型存储一个键值对，它继承自 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拉链法原理"><a href="#拉链法原理" class="headerlink" title="拉链法原理"></a>拉链法原理</h2><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，计算 K1 的 hashCode 为 $115$，使用除留余数法得到所在的桶下标 $115\%16=3$。</li><li>插入 &lt;K2,V2&gt; 键值对，计算 K2 的 hashCode 为 $118$，使用除留余数法得到所在的桶下标 $118\%16=6$。</li><li>插入 &lt;K3,V3&gt; 键值对，计算 K3 的 hashCode 为 $118$，使用除留余数法得到所在的桶下标 $118\%16=6$，插在 &lt;K2,V2&gt; 后面。</li></ul><p><img src="07903a31-0fb3-45fc-86f5-26f0b28fa4e7.png" alt=""></p><p>查找需要分成两步进行：</p><ul><li><p>计算键值对所在的桶；</p></li><li><p>在链表上顺序查找。</p></li></ul><p>时间复杂度显然和链表的长度成正比。</p><p>从 JDK 1.8 开始，<strong>一个桶存储的链表长度大于 $8$ 时会将链表转换为红黑树</strong>。</p><blockquote><p><strong>计算桶下标</strong></p></blockquote><p>$(1)$ hashCode 通过调用 Key 的 <code>hashCode()</code> 方法得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$(2)$ 高位运算</p><p>将 hashCode 的高 $16$ 位和低 $16$ 位进行异或操作，使得数组比较小时也能保证高低位都参与到哈希计算中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$(3)$ 除留余数法</p><p>令 $x = 1&lt;&lt;4$，即 $x$ 为 $2$ 的 $4$ 次方，它具有以下性质：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure><p>令一个数 $y$ 与 $x-1$ 做与运算，可以去除 $y$ 位级表示的第 $4$ 位及以上数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>结果和 $y$ 对 $x$ 取模是一样的：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">y   : 10110010</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><p>位运算的代价比求模运算小的多，因此在进行这种计算时能用位运算的话能带来更高的性能。</p><p>拉链法需要使用除留余数法来得到桶下标，需要进行以下计算：hash%capacity，如果能保证 capacity 为 $2$ 的幂次方，那么就可以将这个操作转换为位运算。</p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>设 HashMap 的 table 长度为 $M$，需要存储的键值对数量为 $N$，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 $N/M$，因此平均查找次数的数量级为 $O(N/M)$。为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>相关参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">capacity</td><td style="text-align:left">table 的容量大小，默认为 16，需要注意的是 capacity 必须保证为 2 的次方。</td></tr><tr><td style="text-align:center">size</td><td style="text-align:left">table 的实际使用量。</td></tr><tr><td style="text-align:center">threshold</td><td style="text-align:left">size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</td></tr><tr><td style="text-align:center">load_factor</td><td style="text-align:left">table 能够使用的比例，threshold = capacity * load_factor。</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>当需要扩容时，令 capacity 为原来的 $2$ 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容使用 <code>resize()​</code> 实现，但它需要把旧 table 的所有键值对插入新的 table 中，因此这一步是很费时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 允许有一个 Node 的 Key 为 null，该 Node 一定会放在第 $0$ 个桶的位置，因为这个 Key 无法计算 hashCode()，所以只能规定一个桶让它存放。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>==JDK 1.7 版本==</p><p>数据结构：ReentrantLock+Segment+HashEntry</p><p>ConcurrentHashMap(并发哈希表) 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁，每个分段锁维护着几个桶，多个线程可以同时访问不同分段锁上的桶。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问，在同一时间点只能有一个线程能访问容器。</p><p>存储结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承自 ReentrantLock(可重入锁)，每个 Segment 维护着多个 HashEntry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的并发级别为 $16$，也就是说默认创建 $16$ 个 Segment。</p><p>查询：二次哈希，第一次定位到 Segment，第二次定位到元素所在链表的头部。</p><p><img src="image005.jpg" alt=""></p><p>==JDK 1.8 版本==</p><p>数据结构：synchronized+CAS+Node+红黑树。</p><p>查找、替换、赋值操作都使用 CAS。</p><p>使用了内置锁 synchronized 代替 Segment，Segment 属于重入锁 ReentrantLock。主要是出于以下考虑：</p><ul><li>synchronized 的锁粒度更低，JDK1.7版本锁的粒度是基于 Segment 的，包含多个 HashEntry，而 JDK1.8 锁的粒度就是 HashEntry (首节点)；</li><li>基于 JVM 的 synchronized 优化空间更大，使用内嵌的关键字比使用 API 更加自然；</li><li>在大量的数据操作下，基于 API 的 ReentrantLock 会开销更多的内存。</li></ul><h1 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h1><h2 id="排序，查找，替换操作"><a href="#排序，查找，替换操作" class="headerlink" title="排序，查找，替换操作"></a>排序，查找，替换操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//返回target在list中第一次出现的索引，找不到则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h2 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h2><p>Collections 提供了多个 <code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。HashSet，TreeSet，ArrayList，LinkedList，HashMap，TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定collection支持的同步(线程安全的)collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步(线程安全的)List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步(线程安全的)Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定set支持的同步(线程安全的)set。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最好不要用这些方法，效率非常低，需要线程安全的集合类型时考虑使用 JUC 包下的并发集合。</p><h1 id="fail-fast-amp-fail-safe"><a href="#fail-fast-amp-fail-safe" class="headerlink" title="fail-fast &amp; fail-safe"></a>fail-fast &amp; fail-safe</h1><p>$(1)$ 快速失败(fail-fast)</p><p>快速失败(fail-fast) 是 Java 集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 <code>ConcurrentModificationException</code> 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</p><p>每当迭代器使用 <code>hashNext()</code>/<code>next()</code>遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否为 <code>expectedModCount</code> 值，是的话就返回遍历；否则抛出异常，终止遍历。如果我们在集合被遍历期间对其进行修改的话，就会改变 <code>modCount</code> 的值，进而导致 <code>modCount != expectedModCount</code> ，进而抛出 <code>ConcurrentModificationException</code> 异常。</p><p>注：通过 Iterator 的方法修改集合的话会修改到 <code>expectedModCount</code> 的值，所以不会抛出异常。</p><p>$(2)$ 安全失败(fail-safe)</p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 <code>ConcurrentModificationException</code> 异常。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Array-和-ArrayList-的区别？"><a href="#Array-和-ArrayList-的区别？" class="headerlink" title="Array 和 ArrayList 的区别？"></a>Array 和 ArrayList 的区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 指定固定大小，而 ArrayList 大小是自动扩展的。</li></ul><h2 id="ArrayList-和-LinkedList-的区别？"><a href="#ArrayList-和-LinkedList-的区别？" class="headerlink" title="ArrayList 和 LinkedList 的区别？"></a>ArrayList 和 LinkedList 的区别？</h2><p>ArrayList：底层是基于数组实现的。查找快，增删较慢；</p><p>LinkedList：底层是基于链表实现的。查找慢、增删快。</p><p><strong>ArrayList 的增删未必比 LinkedList 慢：</strong></p><ol><li>如果增删都是在末尾来操作（每次调用的都是 remove() 和 add()），此时 ArrayList 就不需要移动和复制数组。如果数据量有百万级，速度会比 LinkedList 要快。</li><li>如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上（底层调用的是 arrayCopy() 方法，是 native 方法）。LinkedList 的遍历速度是慢于 ArrayList 的复制移动速度的。如果数据量有百万级，还是 ArrayList 要快。</li></ol><h2 id="ArrayList-实现-RandomAccess-接口有何作用？"><a href="#ArrayList-实现-RandomAccess-接口有何作用？" class="headerlink" title="ArrayList 实现 RandomAccess 接口有何作用？"></a>ArrayList 实现 RandomAccess 接口有何作用？</h2><p>RandomAccess 接口只是一个标志接口，只要 List 集合实现这个接口，就能支持快速随机访问。</p><p>实现 RandomAccess 接口的 List 集合采用一般的 for 循环遍历，而未实现这接口则采用迭代器，即 ArrayList 一般采用 for 循环遍历，而 LinkedList 一般采用迭代器遍历。</p><p>ArrayList 用 for 循环遍历比 iterator 迭代器遍历快，LinkedList 用 iterator 迭代器遍历比 for 循环遍历快。</p><h2 id="HashMap-的-get-方法能否判断某个元素是否在-map-中？"><a href="#HashMap-的-get-方法能否判断某个元素是否在-map-中？" class="headerlink" title="HashMap 的 get 方法能否判断某个元素是否在 map 中？"></a>HashMap 的 get 方法能否判断某个元素是否在 map 中？</h2><p>HashMap 的 get 函数的返回值不能判断一个 key 是否包含在 map 中，因为 get 返回 null 有可能不包含该 key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。</p><h2 id="HashMap-与-HashTable-的区别"><a href="#HashMap-与-HashTable-的区别" class="headerlink" title="HashMap 与 HashTable 的区别"></a>HashMap 与 HashTable 的区别</h2><ol><li>HashTable 不允许 key 和 value 为 null；</li><li>HashTable 是线程安全的。但是 HashTable 线程安全的策略实现代价太大，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</li><li>HashMap 不是线程安全的，但可以通过 Collections.synchronizedMap(hashMap)，使其实现同步。</li></ol><h2 id="HashTable-和-ConcurrentHashMap-的区别"><a href="#HashTable-和-ConcurrentHashMap-的区别" class="headerlink" title="HashTable 和 ConcurrentHashMap 的区别"></a>HashTable 和 ConcurrentHashMap 的区别</h2><p>HashTable 和 ConcurrentHashMap 相比，效率低。 Hashtable 之所以效率低主要是使用了 synchronized 关键字对 put 等操作进行加锁，而 synchronized 关键字加锁是对整张 Hash 表的，即每次锁住整张表让线程独占，致使效率低下，而 ConcurrentHashMap 在对象中保存了一个 Segment 数组，即将整个 Hash 表划分为多个分段；而每个 Segment 元素，即每个分段则类似于一个Hashtable；这样在执行 put 操作时首先根据 hash 算法定位到元素属于哪个 Segment，然后对该 Segment 加锁即可。</p><h2 id="HashSet-的实现原理"><a href="#HashSet-的实现原理" class="headerlink" title="HashSet 的实现原理"></a>HashSet 的实现原理</h2><p>HashSet 的实现依赖 HashMap，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，value 则是 PRESENT 变量，这个变量只作为放入 map 时的一个占位符而存在，当存储的值已经存在时返回 false。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;容器主要包括 Collection 和 Map 两种。&lt;/p&gt;
&lt;p&gt;Collection：存放独立元素的序列。&lt;/p&gt;
&lt;p&gt;Map：存放key-value型的元素对。&lt;/p&gt;
&lt;h1 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Coll</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于分布式HBase的数据分析</title>
    <link href="http://10185102110.github.io/2021/07/15/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FHBase%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://10185102110.github.io/2021/07/15/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FHBase%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</id>
    <published>2021-07-15T13:05:50.000Z</published>
    <updated>2021-08-28T04:54:46.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 14.04</p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><ul><li>三台阿里云 CentOS 轻量级服务器</li><li>Xshell 终端模拟软件</li><li>WinSCP 文件操作软件</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul><li>Ubuntu下Java, Hadoop与HBase的安装及伪分布式的部署；</li><li>使用Java API对HBase进行基本操作 ；</li><li>基于Hadoop实现MapReduce；</li><li>使用 TensorFlow 框架，对摩拜单车数据集的经纬度进行分析，并可视化。</li></ul><h2 id="HBase-简介"><a href="#HBase-简介" class="headerlink" title="HBase 简介"></a>HBase 简介</h2><p>HBase是一个构建在HDFS上的分布式列存储系统； </p><p>HBase是基于Google BigTable模型开发的，典型 的key/value系统；</p><p>HBase是Apache Hadoop生态系统中的重要一员，主要用于海量结构化数据存储； </p><p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文 “Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System） 所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。</p><p>HBase是Apache 的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据 库。另一个不同的是HBase基于列的而不是基于行的模式。</p><h3 id="分布式Hbase协调工作说明"><a href="#分布式Hbase协调工作说明" class="headerlink" title="分布式Hbase协调工作说明"></a>分布式Hbase协调工作说明</h3><h4 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h4><p>1.保证任何时候，集群中只有一个master </p><p>2.存贮所有Region的寻址入口 </p><p>3.实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master </p><p>4.存储Hbase的schema，包括有哪些table，每个table有哪些column family</p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>1.为Region server分配region </p><p>2.负责region server的负载均衡 </p><p>3.发现失效的region server并重新分配其上的region </p><p>4.GFS上的垃圾回收 </p><p>5.处理schema更新请求</p><h4 id="Region-server"><a href="#Region-server" class="headerlink" title="Region server"></a>Region server</h4><p>1.Region server 维护Master分配给它的region，处理对这些region的IO请求。 </p><p>2.Region server 负责切分在运行过程中变得过大的region。 可以看到，client访问hbase上数据的过程并不需要master参与（寻址访问zookeeper和region server，数据读写访问region server）, master仅仅维护着table和region的元数据信息，负载很低。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol><li><p>安装 Java</p><p>安装 JRE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install default-jre</span><br></pre></td></tr></table></figure><p>安装 OpenJDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install default-jdk</span><br></pre></td></tr></table></figure><p>安装 OracleJDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line">sudo apt-get install oracle-java8-set-default</span><br></pre></td></tr></table></figure></li><li><p>安装 SSH</p><p>在 Hadoop 运行过程中，主从机之间是通过SSH进行通信的，所以需要对所有主机进行SSH的安装和配置 工作。</p><p>安装ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install openssh-server</span><br></pre></td></tr></table></figure><p>使用下面的命令来查看SSH是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure><p><strong>配置免密登录 SSH</strong></p><p>在master主机上进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -keygen -t rsa</span><br></pre></td></tr></table></figure><p>将公钥（<code>~/.ssh/id_rsa.pub</code>中的内容）复制到文件 <code>authorized_keys</code> 中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>将 master 上的 <code>~/.ssh/authorized_keys</code> 通过 scp 命令复制到从机 slave1,slave2 中去。</p><p>但发现通过ssh命令仍不能实现三台主机之间的免密登录，查阅资料我们知道：ssh对目录权限有要求， 代码中要设置新生成的config文件75，其中~目录权限值为750，~/.ssh的是700，~/.ssh/*是600，因此 我们需要给它赋值600，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>安装 Zookeeper</p><p>选择一个版本的 Zookeeper 进行下载安装，用 winSCP 将文件传到服务器根目录下，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp zookeeper-3.5.6-bin.tar.gz hadoop@47.101.139.207:~/</span><br></pre></td></tr></table></figure><p>进入服务器根目录下，将zookeeper-3.5.6-bin.tar.gz解压至 /usr/local/cluster中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf ~/zookeeper-3.5.6-bin-tar.gz -C /usr/local/cluter/</span><br></pre></td></tr></table></figure><p>这里解压之后形成的文件夹名为zookeeper-3.5.6，为了方便后续操作，我们将之改名为zookeeper 设置环境变量，在 <code>~/.bashrc</code> 中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#zookeeper</span><br><span class="line">export ZOOKEEPER=/usr/local/cluster/zookeeper</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER/bin</span><br></pre></td></tr></table></figure><p>使环境变量生效，并为 zookeeper 配置数据和日志文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>当三台主机全部配置完成之后，尝试启动zookeeper：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/cluster/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="1"></p><p>查看 zookeeper 启动状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/cluster/zookeeper/bin/zkServer.sh status</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="2"></p><p>发现 error contacting 经过研究发现，在zoo.cfg配置文件中加上如下一行代码，即可解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quorumListenOnALLIPS=true</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>完成配置</p></li><li><p>安装 Hadoop 和 HBase</p><p>基本过程与安装 zookeeper 相似，在此省略。</p><p>在hadoop的配置过程中由于java的问题，要注意我们JAVA_HOME的环境变量路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#java</span><br><span class="line"> export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</span><br><span class="line"> export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p>接下来进行伪分布式的配置。Hadoop可以在单节点上以伪分布式的方式运行。Hadoop进程以分离的Java进程来运行。需要对hadoop/etc/hadoop中的两个配置文件进行修改。</p><p><img src="5.png" alt="5"></p><p><img src="6.png" alt="6"></p><p>修改完成后对NameNode进行格式化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>启动 hadoop：</p><p><img src="4.png" alt="4"></p><p>用 jps 判断是否启动成功</p><p><img src="7.png" alt="7"></p><p>可以看到，出现 NameNode, DataNode 和 SecondaryNameNode 三个进程，说明启动成功。</p><p>在 50069 端口可以查看节点信息</p><p><img src="8.png" alt="8"></p><p>通过16010端口查看 HBase 运行情况</p><p><img src="9.png" alt="9"></p></li></ol><h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>使用Hbase Shell导入数据：</p><p><img src="10.png" alt="10"></p><p>在 HBase 内, 数据按照 <code>&lt;行键&gt;&lt;列族1: 列1-1, 列1-2&gt;&lt;列族2: 列2-1, 列2-2&gt;</code> 这样的类型进行存储的。且, 其一, 其中行键的排列顺序是按照字典顺序排序的, 这点对于搜索非常重要。其二, 同一行键的相同列族中列的值, 是可能变化的, 并且按照时间戳进行排序的(当然, 有些数据在合并的时候, 会被删除) 。其中, 相应的模块知识, 如下所示:</p><ul><li><p>Row Key </p><p><code>Row Key</code> , 行键. 是用来检索记录的主键. 访问 <code>HBase Table</code> 中的行, 主要有三种方式. 单个row key 进行访问 / 通过 row key 正则匹配 / 全表扫描 . Row Key 的值可以是任意字符串(最大长度为64KB, 实际使用经常为10-100byte) .其中, 行键的排列顺序是按照字典顺序排序的, 这点对于搜索非常重要. (PS: 字典顺序: <code>1 10 12 6 7 9</code> 中, <code>11</code> 排在 <code>9</code> 之前.) </p></li><li><p>Columns Family </p><p><code>Columns Famil</code>y 列族. HBase 内的每个列, 都属于一个列族. 列族是 Schema 一部分(即表设计), 而 列不是(列可以在插入数据时, 动态添加). 列族是需要在使用之前进行提前定义的. 列名都以列族为前缀, 如<code>course:namecourse:age</code>. </p></li><li><p>Cell </p><p><code>Cell</code> , 数据单元. 有唯一确定的单元. Cell 内的数据是没有类型的, 全部都是字节码进行存储的. </p></li><li><p>Time Stamp </p><p>每个 Cell 存储一个数据的多个版本. 版本号, 通过时间戳进行索引(时间精确到毫秒). 时间戳类型为 64位整数类型. 时间戳按照时间类型倒叙排序. </p><p>回收版本机制: <code>&lt;保存数据的最后n个版本&gt; / &lt;保存最近一段时间的版本(如最近七天)&gt;</code></p></li></ul><p>操作流程</p><ol><li><p>将服务器本地文件(.csv)上传到hdfs的根目录下,然后导入数据到hbase</p></li><li><p>进入hbase shell 创建表 bicycle,列族为info</p></li><li><p>执行文件导入（Hadoop用户中执行）</p><p>格式：hbase [类] [分隔符] [行键，列族] [表] [导入文件] （默认分隔符为空格）</p></li><li><p>导入完成后，可以使用 scan  来查看是否导入成功</p></li></ol><p><img src="11.png" alt="11"></p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>对数据清洗之后得到若干组经纬度坐标，对坐标进行聚类，采用以下四种算法：</p><ol><li><p>K-Means (K均值) 聚类</p><p>步骤： </p><p>(1) 选择一些类/组，并随机初始化它们各自的中心点。中心点是与每个数据点向量长度相同的位置（需 要提前预知类的数量，即中心点的数量)。 </p><p>(2) 计算每个数据点到中心点的距离，数据点距离哪个中心点最近就划分到哪一类中。 </p><p>(3) 计算每一类中中心点作为新的中心点。 </p><p>(4) 重复以上步骤，直到每一类中心在每次迭代后变化不大为止。也可以多次随机初始化中心点，然后 选择运行结果最好的一个。</p><p>优点： </p><p>(1) 速度快 </p><p>(2) 计算简便</p><p>缺点： </p><p>(1) 需要提前知道数据有多少类 </p><p>(2) 摩拜单车数据量庞大，并不知道一共可以分成多少类，存在一定误差，但在中小规模数据下可以适 用。</p></li><li><p>均值漂移聚类</p><p>步骤： </p><p>(1) 确定滑动窗口半径r，以随机选取的中心点C半径为r的圆形滑动窗口开始滑动。均值漂移类似一种爬 山算法，在每一次迭代中向密度更高的区域移动，直到收敛。 </p><p>(2) 每一次滑动到新的区域，计算滑动窗口内的均值来作为中心点，滑动窗口内的点的数量为窗口内的 密度。在每一次移动中，窗口会想密度更高的区域移动。 </p><p>(3) 移动窗口，计算窗口内的中心点以及窗口内的密度，知道没有方向在窗口内可以容纳更多的点，即 一直移动到圆内密度不再增加为止。 </p><p>(4) 步骤一到三会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数 据点所在的滑动窗口进行聚类。</p><p>优点： </p><p>(1) 不需要设定一共有多少组 </p><p>(3) 受均值影响小 </p><p>缺点： </p><p>r 的选择可能并不重要，在本次实验中并没有好的预期效果。</p></li><li><p>基于密度的聚类方法 (DBSCAN)</p><p>步骤： </p><p>(1) 首先确定半径 r 和 minPoints。从一个没有被访问过的任意数据点开始，以这个点为中心，r 为半径 的圆内包含的点的数量是否大于或等于 minPoints，如果大于或等于 minPoints 则改点被标记为 central point ,反之则会被标记为 noise point。 </p><p>(2) 重复 (1) 的步骤，如果一个 noise point 存在于某个 central point 为半径的圆内，则这个点被标记为 边缘点，反之仍为 noise point。重复步骤 ，直到所有的点都被访问过。</p><p>优点： </p><p>不需要设定一共有多少组。</p><p>缺点： </p><p>需要频繁改动距离 r 和 minPoints，来获得较好的预期效果。</p></li><li><p>用高斯混合模型（GMM）的最大期望（EM）聚类</p><p>步骤： </p><p>(1) 选择簇的数量 (与K-Means类似) 并随机初始化每个簇的高斯分布参数 (均值和方差) 。也可以先观察 数据给出一个相对精确的均值和方差。 </p><p>(2) 给定每个簇的高斯分布，计算每个数据点属于每个簇的概率。一个点越靠近高斯分布的中心就越可 能属于该簇。 </p><p>(3) 基于这些概率我们计算高斯分布参数使得数据点的概率最大化，可以使用数据点概率的加权来计算 这些新的参数，权重就是数据点属于该簇的概率。 重复迭代 (2) 和 (3) 直到在迭代中的变化不大。</p><p>优点：</p><p>(1) 使用均值和标准差，簇可以呈现出椭圆形而不是仅仅限制于圆形 </p><p>(2) 使用概率，所有一个数据点可以属于多个簇 </p><p>缺点： </p><p>目的为确认单车的密度分布，并不太适用此算法。</p></li></ol><p>代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> cholesky</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle  <span class="comment"># 用于打乱数据</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zc_read_csv</span>():</span></span><br><span class="line">    zc_dataframe = pd.read_csv(<span class="string">&quot;C:/Users/HP/Desktop/mobike/mobike/1/123.csv&quot;</span>, sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    x = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> zc_index <span class="keyword">in</span> zc_dataframe.index:</span><br><span class="line">        zc_row = zc_dataframe.loc[zc_index]</span><br><span class="line">        x.append([zc_row[<span class="number">6</span>],zc_row[<span class="number">7</span>]])</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">x = zc_read_csv()</span><br><span class="line">y = tf.convert_to_tensor(x,name=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">z = tf.to_double(y, name=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    srcdata = sess.run(z)</span><br><span class="line"><span class="built_in">print</span>(srcdata)</span><br><span class="line"><span class="comment"># 画出当前的所有点</span></span><br><span class="line">plt.plot(srcdata[:, <span class="number">0</span>], srcdata[:, <span class="number">1</span>], <span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义K-means算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义K-means算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">vectors, k_num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 TensorFlow 实现K-Means 算法</span></span><br><span class="line"><span class="string">    :param vectors: 是一个 n * k 的Numpy数组，n代表k维向量的数量，也就是模拟产生的数据点的Tensor</span></span><br><span class="line"><span class="string">    :param k_num: 表示需要分类的个数,是一个整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将 k 转换为整数</span></span><br><span class="line">    k_num = <span class="built_in">int</span>(k_num)</span><br><span class="line">    <span class="comment"># 异常处理，防止后续数组下标越界,防止出现分类个数大于实际的点的个数</span></span><br><span class="line">    <span class="keyword">assert</span> k_num &lt; <span class="built_in">len</span>(vectors)</span><br><span class="line">    <span class="comment"># 找出每个向量的维度,平面点的维度为2(x,y)，空间点维度为3(x,y,z)</span></span><br><span class="line">    dim = <span class="built_in">len</span>(vectors[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 获取 vectors 长度大小的随机数据(本例中为1000)</span></span><br><span class="line">    vector_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(vectors)))</span><br><span class="line">    <span class="comment"># 打乱 vector_indices 中的所有数据，能够更好的泛化</span></span><br><span class="line">    shuffle(vector_indices)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图</span></span><br><span class="line">    <span class="comment"># 我们创建了一个默认的计算流的图用于整个算法中，这样就保证了当函数被多次调用时，始终使用的     # 是默认的图</span></span><br><span class="line">    graph = tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> graph.as_default():</span><br><span class="line">        <span class="comment"># 创建会话</span></span><br><span class="line">        tf.compat.v1.disable_eager_execution()</span><br><span class="line">        <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">            <span class="comment"># 构建基本的计算的元素</span></span><br><span class="line">            <span class="comment"># 首先我们需要保证每个中心点都会存在一个Variable矩阵</span></span><br><span class="line">            <span class="comment"># 从现有的点集合中抽取出前 k_num 个数据作为默认的中心点,并且定义为 tf 的变量,</span></span><br><span class="line">            <span class="comment"># 用于后续的中心点的运算</span></span><br><span class="line">            centroids = [tf.Variable((vectors[vector_indices[i]]))<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_num)]</span><br><span class="line">            <span class="comment"># 创建一个placeholder用于存放各个分类的中心点</span></span><br><span class="line">            centroid_value = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 给 k_num 个中心点向量进行赋值,cent_assigns 用于保存中心点的位置信息</span></span><br><span class="line">            cent_assigns = []</span><br><span class="line">            <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids:</span><br><span class="line">                cent_assigns.append(tf.assign(centroid, centroid_value))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># assignments 用于保存 sampleNo 个点的经过计算分类后位置</span></span><br><span class="line">            assignments = [tf.Variable(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors))]</span><br><span class="line">            <span class="comment"># 存储每个单独的点到 k_num 个分类的最短距离</span></span><br><span class="line">            assignment_value = tf.placeholder(dtype=tf.int32)</span><br><span class="line">            <span class="comment"># cluster_assigns 存储的是每个点到 k_num 个中心点中的最小的一个距离</span></span><br><span class="line">            cluster_assigns = []</span><br><span class="line">            <span class="comment"># 初始化 cluster_assigns</span></span><br><span class="line">            <span class="keyword">for</span> assignment <span class="keyword">in</span> assignments:</span><br><span class="line">                cluster_assigns.append(tf.assign(assignment, assignment_value))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 下面创建用于计算平均值的操作节点</span></span><br><span class="line">            <span class="comment"># 输入的placeholder</span></span><br><span class="line">            mean_input = tf.placeholder(dtype=tf.float64, shape=[<span class="literal">None</span>, dim])</span><br><span class="line">            <span class="comment"># 节点/OP接受输入，并且计算0维度的平均值，如输入的向量列表</span></span><br><span class="line">            mean_op = tf.reduce_mean(mean_input, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用于计算欧几里得距离的节点 distance = ((x1 - x2)^2 + (y1 - y2)^2)^(1/2)</span></span><br><span class="line">            v1 = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line">            v2 = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line">            </span><br><span class="line">            euclid_dist = tf.sqrt(tf.reduce_sum(tf.<span class="built_in">pow</span>(tf.subtract(v1, v2), <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这个OP会决定应该将向量归属到哪个节点</span></span><br><span class="line">            <span class="comment"># 基于向量到中心点的欧几里得距离</span></span><br><span class="line">            <span class="comment"># Placeholder for input</span></span><br><span class="line">            centroid_distances = tf.placeholder(dtype=tf.float64, shape=[k_num])</span><br><span class="line">            <span class="comment"># cluster_assignment 计算 k_num 个中心点的最短欧几里得距离</span></span><br><span class="line">            cluster_assignment = tf.argmin(centroid_distances, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 初始化所有的状态值</span></span><br><span class="line">            init_op = tf.global_variables_initializer()</span><br><span class="line">            <span class="comment"># 初始化所有的变量</span></span><br><span class="line">            sess.run(init_op)</span><br><span class="line">            <span class="comment"># 创建tensor图,并保存在当前的log目录下</span></span><br><span class="line">            tf.summary.FileWriter(<span class="string">&quot;./log&quot;</span>, sess.graph)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 集群遍历</span></span><br><span class="line">            <span class="comment"># 接下来在K-Means聚类迭代中使用最大期望算法。为了简单起见，只让它执行固</span></span><br><span class="line">            <span class="comment"># 定的训练的次数为20次，而不设置一个终止条件</span></span><br><span class="line">            noofiterations = <span class="number">20</span></span><br><span class="line">            <span class="keyword">for</span> iteration_n <span class="keyword">in</span> <span class="built_in">range</span>(noofiterations):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 期望步骤</span></span><br><span class="line">                <span class="comment"># 基于上次迭代后算出的中心点的位置</span></span><br><span class="line">                <span class="comment"># 1.首先遍历所有的向量,len(vectors)在此案例中值为 sampleNo = 1000</span></span><br><span class="line">                <span class="comment"># 计算每个点到 k_num 个分类中心点的最短距离,并存储在 cluster_assigns 中</span></span><br><span class="line">                <span class="keyword">for</span> vector_n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors)):</span><br><span class="line">                    <span class="comment"># 获取第 vector_n 个向量,取值范围在[0,999]</span></span><br><span class="line">                    vect = vectors[vector_n]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 当前点与 k_num 个分类的中心点欧几里得距离</span></span><br><span class="line">                    distances = [sess.run(euclid_dist, feed_dict=&#123;</span><br><span class="line">                        v1: vect, v2: sess.run(centroid)&#125;) <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 获取当前点到 k_num 个分类中心点的最短距离,目的是为了后续选择最近距离的中心点</span></span><br><span class="line">                    assignment = sess.run(cluster_assignment, feed_dict=&#123;</span><br><span class="line">                        centroid_distances: distances&#125;)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 接下来为每个向量分配合适的值</span></span><br><span class="line">                    sess.run(cluster_assigns[vector_n], feed_dict=&#123;</span><br><span class="line">                        assignment_value: assignment&#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 2.将所有点进行分类</span></span><br><span class="line">                <span class="comment"># 基于上述的期望步骤，计算每个新的中心点的距离从而使集群内的平方和最小</span></span><br><span class="line">                <span class="keyword">for</span> cluster_n <span class="keyword">in</span> <span class="built_in">range</span>(k_num):</span><br><span class="line">                    <span class="comment"># 收集 k_num 个分类中,对应每个分类的数据</span></span><br><span class="line">                    assigned_vects = [vectors[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors))</span><br><span class="line">                                      <span class="keyword">if</span> sess.run(assignments[i]) == cluster_n]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 采用平均值的计算方式重新计算每个分类集群新的中心点</span></span><br><span class="line">                    new_location = sess.run(mean_op, feed_dict=&#123;</span><br><span class="line">                        mean_input: array(assigned_vects)&#125;)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 为 k_num 个分类分配新的中心点</span></span><br><span class="line">                    sess.run(cent_assigns[cluster_n], feed_dict=&#123;</span><br><span class="line">                        centroid_value: new_location&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回 k_num 个中心节点</span></span><br><span class="line">            centroids = sess.run(centroids)</span><br><span class="line">            <span class="comment"># 返回 k_num 个分组</span></span><br><span class="line">            assignments = sess.run(assignments)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> centroids, assignments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义聚类的个数,并使用kmeans算法去计算</span></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">center, result = kmeans(srcdata, k)</span><br><span class="line"><span class="built_in">print</span>(np.shape(result))</span><br><span class="line"><span class="comment"># 打印 k 个中心点</span></span><br><span class="line"><span class="built_in">print</span>(center)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整理结果,并使用 seaborn 画图</span></span><br><span class="line">res = &#123;<span class="string">&quot;x&quot;</span>: [], <span class="string">&quot;y&quot;</span>: [], <span class="string">&quot;kmeans_res&quot;</span>: []&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">    res[<span class="string">&quot;x&quot;</span>].append(srcdata[i][<span class="number">0</span>])</span><br><span class="line">    res[<span class="string">&quot;y&quot;</span>].append(srcdata[i][<span class="number">1</span>])</span><br><span class="line">    res[<span class="string">&quot;kmeans_res&quot;</span>].append(result[i])</span><br><span class="line"></span><br><span class="line">pd_res = pd.DataFrame(res)</span><br><span class="line">sns.lmplot(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, data=pd_res, fit_reg=<span class="literal">False</span>, height=<span class="number">5</span>, hue=<span class="string">&quot;kmeans_res&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>对聚类出的经纬度数据聚类后，为了方便检测聚类结果，我们直接采用 python 的 matplotlib 库以经 纬度为坐标画出聚类结果，但发现这种方式对于聚类结果的显示并不是很直观，无法发现聚类结果和实 际地形的关联。于是想到使用高德地图的 API，希望可以将聚类结果直接在实际的地图上投影，在参阅 了高德地图官方 API 实例之后，发现其提供的海量点，点聚合可以实现我们的需求。申请成为高德地图 开放平台的个人开发者，得到 key，然后利用其中的 API 进行可视化。如下图所示：</p><p><img src="12.png" alt="12"></p><p><img src="13.png" alt="13"></p><p><img src="14.png" alt="14"></p><p><img src="15.png" alt="15"></p><p><img src="16.png" alt="16"></p><p>可视化后可以发现上海区域地图上呈现若干密集点，通过调整地图的大小，可以调整密集点的大小， 根据需求可以知道不同区域摩拜单车的密集度。这些密集度说明哪些区域会使用更多的摩拜单车，为了 符合人们用车需求应当调整不同区域摩拜单车的数量，才能更好地满足人们的需求。</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0, user-scalable=no, width=device-width&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>点聚合<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">25rem</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">7rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: .<span class="number">7rem</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> <span class="selector-class">.btn</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;map&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>聚合点效果切换<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;默认样式&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add0&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(0)&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;自定义图标&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add1&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(1)&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;完全自定义&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add2&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(2)&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./china.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://webapi.amap.com/maps?v=1.4.15&amp;key=2b373ec81fe728db4bf6b57baea1138d&amp;plugin=AMap.MarkerClusterer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cluster, markers = [];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">&quot;container&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">resizeEnable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">center</span>: [<span class="number">105</span>, <span class="number">34</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">zoom</span>: <span class="number">4</span></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        markers.push(<span class="keyword">new</span> AMap.Marker(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">position</span>: points[i][<span class="string">&#x27;lnglat&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="attr">content</span>: <span class="string">&#x27;&lt;div style=&quot;background-color: hsla(180, 100%, 50%, 0.7); height: 24px; width: 24px; border: 1px solid hsl(180, 100%, 40%); border-radius: 12px; box-shadow: hsl(180, 100%, 50%) 0px 0px 1px;&quot;&gt;&lt;/div&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">15</span>, -<span class="number">15</span>)</span></span><br><span class="line"><span class="javascript">        &#125;))</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> count = markers.length;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _renderClusterMarker = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> factor = <span class="built_in">Math</span>.pow(context.count / count, <span class="number">1</span> / <span class="number">18</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> Hue = <span class="number">180</span> - factor * <span class="number">180</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bgColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,50%,0.7)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> fontColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,20%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> borderColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,40%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> shadowColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,50%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.backgroundColor = bgColor;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> size = <span class="built_in">Math</span>.round(<span class="number">30</span> + <span class="built_in">Math</span>.pow(context.count / count, <span class="number">1</span> / <span class="number">5</span>) * <span class="number">20</span>);</span></span><br><span class="line"><span class="javascript">        div.style.width = div.style.height = size + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.border = <span class="string">&#x27;solid 1px &#x27;</span> + borderColor;</span></span><br><span class="line"><span class="javascript">        div.style.borderRadius = size / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.boxShadow = <span class="string">&#x27;0 0 1px &#x27;</span> + shadowColor;</span></span><br><span class="line"><span class="javascript">        div.innerHTML = context.count;</span></span><br><span class="line"><span class="javascript">        div.style.lineHeight = size + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.color = fontColor;</span></span><br><span class="line"><span class="javascript">        div.style.fontSize = <span class="string">&#x27;14px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.textAlign = <span class="string">&#x27;center&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        context.marker.setOffset(<span class="keyword">new</span> AMap.Pixel(-size / <span class="number">2</span>, -size / <span class="number">2</span>));</span></span><br><span class="line"><span class="javascript">        context.marker.setContent(div)</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    addCluster(<span class="number">2</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">addCluster</span>(<span class="params">tag</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (cluster) &#123;</span></span><br><span class="line"><span class="javascript">            cluster.setMap(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (tag == <span class="number">2</span>) &#123;<span class="comment">//完全自定义</span></span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">gridSize</span>: <span class="number">80</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">renderClusterMarker</span>: _renderClusterMarker</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag == <span class="number">1</span>) &#123;<span class="comment">//自定义图标</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> sts = [&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/blue.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">32</span>, <span class="number">32</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">16</span>, -<span class="number">16</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/green.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">32</span>, <span class="number">32</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">16</span>, -<span class="number">16</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/orange.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">36</span>, <span class="number">36</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">18</span>, -<span class="number">18</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/red.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">48</span>, <span class="number">48</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">24</span>, -<span class="number">24</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/darkRed.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">48</span>, <span class="number">48</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">24</span>, -<span class="number">24</span>)</span></span><br><span class="line"><span class="javascript">            &#125;];</span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">styles</span>: sts,</span></span><br><span class="line"><span class="javascript">                <span class="attr">gridSize</span>: <span class="number">80</span></span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//默认样式</span></span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;<span class="attr">gridSize</span>: <span class="number">80</span>&#125;);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码地址：</p><p><a href="https://github.com/10185102110/HBase">https://github.com/10185102110/HBase</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h2&gt;&lt;p&gt;Ubuntu 14.04&lt;/p&gt;
&lt;h2 id=&quot;实验设备&quot;&gt;&lt;a href=&quot;#实验设备&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Server" scheme="http://10185102110.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>KDD竞赛基准系统</title>
    <link href="http://10185102110.github.io/2021/07/15/KDD%E7%AB%9E%E8%B5%9B%E5%9F%BA%E5%87%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://10185102110.github.io/2021/07/15/KDD%E7%AB%9E%E8%B5%9B%E5%9F%BA%E5%87%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-15T11:39:25.000Z</published>
    <updated>2021-08-28T04:49:08.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>给定作者 ID 和论文 ID，判断该作者是否写了这篇论文。</p><h2 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h2><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p><h2 id="数据集描述"><a href="#数据集描述" class="headerlink" title="数据集描述"></a>数据集描述</h2><ul><li><u>作者数据集</u> : <code>Author.csv</code>。包含作者的编号（Id），名字（Name），单位（affiliation） 信息。相同 的作者可能在 <code>Author.csv</code> 数据集中出现多次，因为作者在不同会议／期刊上发表论文的名字可 能有多个版本。例如：J. Doe, Jane Doe, 和 J. A. Doe 指的均是同一个人。此外，Affiliation 信息可能为空。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">Id</td><td style="text-align:left">int</td><td style="text-align:left">作者编号</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:left">string</td><td style="text-align:left">作者名称</td></tr><tr><td style="text-align:left">Affiliation</td><td style="text-align:left">string</td><td style="text-align:left">隶属单位</td></tr></tbody></table></div><ul><li><u>论文数据集</u> : <code>Paper.csv</code>。包含论文的标题(title)，会议／期刊信息, 关键字(keywords)。 同一论文可 能会通过不同的数据来源获取，因此在 <code>Paper.csv</code> 中会存在多个副本。此外， Keyword 信息可能为空。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">Id</td><td style="text-align:left">int</td><td style="text-align:left">论文编号</td></tr><tr><td style="text-align:left">Title</td><td style="text-align:left">string</td><td style="text-align:left">论文标题</td></tr><tr><td style="text-align:left">Year</td><td style="text-align:left">int</td><td style="text-align:left">论文年份</td></tr><tr><td style="text-align:left">ConferenceId</td><td style="text-align:left">int</td><td style="text-align:left">论文发表的会议Id</td></tr><tr><td style="text-align:left">JournalId</td><td style="text-align:left">int</td><td style="text-align:left">论文发表的期刊Id</td></tr><tr><td style="text-align:left">Keywords</td><td style="text-align:left">string</td><td style="text-align:left">论文关键字</td></tr></tbody></table></div><ul><li><u>(论文-作者)数据集</u> : <code>PaperAuthor.csv</code>。包含 (论文 Id-作者 Id)对 的信息。该数据集包含 噪声 (noisy)，即存在不正确的(论文 Id-作者 Id)对，意味着 <code>PaperAuthor.csv</code> 包含的(论 文 Id-作者 Id) 对 中的作者 Id 并不一定写了该论文 Id。这是因为，作者名字存在歧义， 可能存在同名的不 同人或作者名字有多个版本（如上面的例子：J. Doe, Jane Doe 和 J. A. Doe 指的均是同一个人）。 此外，Affiliation 信息可能为空。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">PaperId</td><td style="text-align:left">int</td><td style="text-align:left">论文编号</td></tr><tr><td style="text-align:left">AuthorId</td><td style="text-align:left">int</td><td style="text-align:left">作者编号</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:left">string</td><td style="text-align:left">作者名称</td></tr><tr><td style="text-align:left">Affiliation</td><td style="text-align:left">string</td><td style="text-align:left">隶属单位</td></tr></tbody></table></div><ul><li><u>会议和期刊数据集</u> ：<code>Conference.csv, Journal.csv</code>。每篇论文发表在会议或者期刊上。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">Id</td><td style="text-align:left">int</td><td style="text-align:left">会议/期刊编号</td></tr><tr><td style="text-align:left">ShortName</td><td style="text-align:left">string</td><td style="text-align:left">简称</td></tr><tr><td style="text-align:left">Fullname</td><td style="text-align:left">string</td><td style="text-align:left">全称</td></tr><tr><td style="text-align:left">Homepage</td><td style="text-align:left">string</td><td style="text-align:left">主页</td></tr></tbody></table></div><ul><li><p>共同作者的信息：<code>coauthor.json</code>。该文件内容是从 <code>PaperAuthor.csv</code> 中抽取出来共同作者的信息， 该文件的生成可以通过运行 <code>model_trainer</code> 下的 <code>coauthor.py</code> 。</p><p><code>coauthor.json</code> 文件的内容格式形如： {“A 作者 ID”: {“B1 作者 ID”: 合作次数, “B2 作者 ID”: 合作次数}} 第一层的 key 为作者的 ID，对应的 value 为共同作者信息（同样为 key-value 形式，key 为 共 同作者的 ID，value 为合作次数）。 </p><p>目前，<code>coauthor.json</code> 文件给出每个作者合作频率最高的 10 个共同作者，该文件的格式为 json。 可以通过修改 <code>coauthor.py</code> 中 <code>get_top_k_coauthors (paper_author_path, k, to_file)</code>方法中 的 k 值 来获取最高的 k 个共同作者，即 top k： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">10</span>  </span><br><span class="line">get_top_k_coauthors(os.path.join(config.DATASET_PATH,<span class="string">&quot;PaperAuthor.csv&quot;</span>),  k, os.path.join(config.DATA_PATH, <span class="string">&quot;coauthor.json&quot;</span>)) </span><br></pre></td></tr></table></figure><p>例 如 ， 获 取 作 者 ID 为 ‘742736’ 的 共 同 作 者 信 息 ， 可 以 通 过 以 下 代 码 获 取 ， coauthor[“742736”] 值对应的是 ID 为 ‘742736’ 作者的共同作者信息。u’823230’: 3 表 示 ID 为 ‘742736’ 的作者 与 ID 为 ‘823230’ 的作者共合作过 3 次： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> json  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coauthor = json.load(<span class="built_in">open</span>(<span class="string">&quot;coauthour.json&quot;</span>))  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coauthor[<span class="string">&quot;742736&quot;</span>] &#123;<span class="string">u&#x27;823230&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;647433&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;1691202&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;891164&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;1910552&#x27;</span>:  <span class="number">3</span>, <span class="string">u&#x27;607259&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;2182818&#x27;</span>: <span class="number">7</span>, <span class="string">u&#x27;1355775&#x27;</span>: <span class="number">4</span>, <span class="string">u&#x27;2097154&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;1108518&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><u>论文&amp;作者 pair 字符串信息</u> ：<code>paperIdAuthorId_to_name_and_affiliation.json</code>。该文件内容是从 <code>Paper-Author.csv</code> 提取的，该文件可以通过运行 <code>model_trainer</code> 文件夹下的<code>stringDistance.py</code> 来获取。</p><p>将 <code>Paper-Author.csv</code> 中相同的论文 ID 和作者 ID 对的 name 和 affiliation 合并，文件内容为 key-value 形式， key 为 论 文 ID 和作者 ID 对 ： ‘paperid|authorid’, value 为 {“name”:  “name1##name2##name3”, “affiliation”: “aff1##aff2##aff3”}。 {“A 作者 ID”: {“B1 作者 ID”: 合作次 数, “B2 作者 ID”: 合作次数}} </p><p>例如，获取 ID 为 ‘1156615’ 的论文和 ID 为 ‘2085584’ 的作者 name 和 affiliation 信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pa_name_aff = json.load(<span class="built_in">open</span>(<span class="string">&quot;paperIdAuthorId_to_name_and_affiliation.json&quot;</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pa_name_aff[<span class="string">&#x27;1156615|2085584&#x27;</span>] </span><br><span class="line">&#123;<span class="string">u&#x27;affiliation&#x27;</span>: <span class="string">u&#x27;Huawei##Microsoft Research Asia&#x27;</span>, <span class="string">u&#x27;name&#x27;</span>: <span class="string">u&#x27;Hang Li##Hang Li&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><u>训 练 集</u>  ：<code>Train.csv</code> 。 ComfirmedPaperIds 列 对 应 的 表 示 该 作 者 写 了 这 些 论 文 的 列 表 ， DeletedPaperIds 列对应的表示该作者没有写这些论文论文。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">AuthorId</td><td style="text-align:left">int</td><td style="text-align:left">作者ID</td></tr><tr><td style="text-align:left">ComfirmedPaperIds</td><td style="text-align:left">string</td><td style="text-align:left">以空格分割的论文列表</td></tr><tr><td style="text-align:left">DeletedPaperIds</td><td style="text-align:left">string</td><td style="text-align:left">以空格分割的论文列表</td></tr></tbody></table></div><ul><li><u>验证集</u> ： <code>Valid.csv</code>文件的格式如下：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">AuthorId</td><td style="text-align:left">int</td><td style="text-align:left">作者ID</td></tr><tr><td style="text-align:left">PaperIds</td><td style="text-align:left">string</td><td style="text-align:left">以空格分割的论文列表，待测的论文列表</td></tr></tbody></table></div><ul><li><p><u>测试集</u> ：<code>Test.csv</code>。测试集 <code>Test.csv</code>文件的格式与验证集 <code>Valid.csv</code> 格式相同。</p></li><li><p>数据集的统计：</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">数据集</th><th style="text-align:left">（作者-论文）对个数</th></tr></thead><tbody><tr><td style="text-align:left">训练集</td><td style="text-align:left">11263</td></tr><tr><td style="text-align:left">验证集</td><td style="text-align:left">2347</td></tr><tr><td style="text-align:left">测试集</td><td style="text-align:left">1300</td></tr></tbody></table></div><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>根据任务的目标，从给定的数据集合中构造出训练正负样本/测试样本；</li><li>从给定的数据集合中，对构造出的训练样本/测试样本进行特征的设计和抽取，并针对每个训练样本/测试样本生成相应的特征集合；</li><li>选择分类算法，在训练样本生成的特征集合上构造分类器；</li><li>使用分类器对测试样本的特征集合进行预测，并将分类器的预测结果转换为任务要求的提交格式。</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li><p>构造训练/测试的正负样本</p><ul><li>构建训练样本。 系统从 <code>data/dataset/train_set/Train.csv</code> 中构建训练集的正负样本。 <ul><li>将 authorId 与 ConfirmedPaperIds 中的每个 paperId 组合，作为正样本（label 为 1）； </li><li>将 authorId 与 DeletedPaperIds 中的每个 paperId 组合，作为负样本（label 为 0）。</li></ul></li><li>构建测试样本。系统从 <code>data/dataset/valid_set/Valid.csv</code> 或 <code>data/dataset/test_set/Test.csv</code>  中构建测试样本。 由于测试集的类标是待预测的，这里直接将其赋值为 -1。</li></ul></li><li><p>构造特征</p><p>分 别 为 每 一 个 训 练 ／ 测 试 样 本 设 计 并 抽 取 特 征 。 特 征 抽 取 函 数 位 于 <code>model_trainer/feature_functions.py</code> 中。</p><p>目前基准系统实现的特征有：</p><ul><li><p>共作者特征（共作者的相似度特征） </p><p>一篇论文会存在多个作者，根据 <code>PaperAuthor.csv</code> 统计每一个作者的 top 10（也可以是 top 20 或者其他 top K）的共作者 coauthor（本系统从 <code>PaperAuthor.csv</code> 获取了每个作 者 top 10 的 共作者，保存在 <code>coauthor.json</code> 文件中。）。对于一个作者论文对（aid，pid）， 计算 PaperId 为 pid 的论文作者是否出现在 AuthorId 为 aid 的作者的 top 10 coauthor  中。有两种计算方式：</p><ul><li>计算 PaperId 为 pid 的论文的作者在 AuthorId 为 aid 的作者的 top 10 coauthor 中出现的 人（个）数，作为一个特征。</li><li>计算 PaperId 为 pid 的论文的作者，与在 AuthorId 为 aid 的作者的 top 10 coauthor  中的 作者的合作次数进行累加，将累加后的次数作为一个特征。</li></ul></li><li><p>字符串距离特征（计算作者名字和单位相似度特征）</p><p>假设当前的作者论文对是(aid,pid), 从 <code>paperIdAuthorId_to_name_and_affiliation.json</code>  里得到 的 name 串和 affiliation 串分别为 name1##name2##name3, aff1##aff2##aff3,  根据 aid 从 <code>Author.csv</code> 表找到的 name 和 affliction 分别为 name-a，affliction-a，这样 我们可以计算字符串的距离。</p><p>特征计算方式有两种：</p><ul><li>计算 name-a 与,name1##name2##name3 的距离；类似地，计算 affliction-a  和,aff1##aff2##aff3 的距离。</li><li>分别计算 name-a 与 name1，name2 和 name3 的各自距离，然后对这三个距 离取平 均；类似地，计算 affliction-a 和,aff1，aff2，aff3 的平均距离。</li></ul><p>距离（相似度）的度量实现以下四种：</p><ul><li>编辑距离</li><li>最长公共子序列（LCS）</li><li>最长公共子串（LSS）</li><li>余弦相似度</li></ul></li><li><p>作者 aid 之前发表的论文的 journal 和 conference，与当前的论文 pid 的 journal 和 conference 之间的相似度。</p></li><li><p>论文的 keyword 相似度</p><p>作者 A 写过的论文的 keyword 构成一个集合 X，一篇论文 B 的 keyword 构成一个集合 Y， 这里 的 keyword 指的是论文的 title 和 keyword 分词后得到的单词，对于一个作者论文对（A， B） 计算他们的 keyword 的交集或者相似度：X∩Y。 每个单词可以计算类似于 tf-idf 的分数， 最后 把属于 X∩Y 的单词的分数累加起来作为一维特征。</p></li></ul></li><li><p>分类器选择</p><p>每一种分类器，对应于一个类（class），目前系统实现的分类器有：</p><ul><li>Decision Tree</li><li>Naive Bayes</li><li>KNN</li><li>SVM</li><li>Logister Regreation</li><li>Random Forest</li><li>AdaBoost</li><li>VotingClassifier</li></ul></li><li><p>数据预处理</p><p>主要是数据清洗和集成。</p></li></ol><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>经过多次实验，发现用了 boost 思想的 adaboost，和 bagging 思想的 vote 准确率是最高的。</p><p><img src="4.png" alt="4"></p><p>代码地址：</p><p><a href="https://github.com/10185102110/KDD/tree/main/KDD_Benchmark">https://github.com/10185102110/KDD/tree/main/KDD_Benchmark</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验任务&quot;&gt;&lt;a href=&quot;#实验任务&quot; class=&quot;headerlink&quot; title=&quot;实验任务&quot;&gt;&lt;/a&gt;实验任务&lt;/h2&gt;&lt;p&gt;给定作者 ID 和论文 ID，判断该作者是否写了这篇论文。&lt;/p&gt;
&lt;h2 id=&quot;目录介绍&quot;&gt;&lt;a href=&quot;#目录介绍</summary>
      
    
    
    
    
    <category term="数据挖掘" scheme="http://10185102110.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>基于GaussDB的招聘与就业信息管理系统</title>
    <link href="http://10185102110.github.io/2021/07/12/%E5%9F%BA%E4%BA%8EGaussDB%E7%9A%84%E6%8B%9B%E8%81%98%E4%B8%8E%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://10185102110.github.io/2021/07/12/%E5%9F%BA%E4%BA%8EGaussDB%E7%9A%84%E6%8B%9B%E8%81%98%E4%B8%8E%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-12T08:24:40.000Z</published>
    <updated>2021-08-28T04:50:12.774Z</updated>
    
    <content type="html"><![CDATA[<p>基于云数据库 GaussDB(for MySQL)实现，使用华为云账号进行操作。</p><h2 id="系统描述"><a href="#系统描述" class="headerlink" title="系统描述"></a>系统描述</h2><p>大学毕业生要就业，企业要吸收新鲜血液，学校作为两者之间的桥梁，需要进行信息的集成和管理，便于对毕业生就业与企业招聘信息进行管理和调研。 </p><p>本系统主要面对三种用户，学校管理机构、毕业生、企业。 </p><ul><li><p>管理机构人员可以对本校毕业生、面向本校的招聘会和参会企业的基本信息进行查询和修改，同时对毕业生参会、面试、聘用情况进行查询， 最后获得企业用人倾向和毕业生择业倾向的统计分析结果。 </p></li><li><p>毕业生可以对个人信息修改，对企业和招聘会的信息进行查询。 </p></li><li><p>企业可以对本企业信息和招聘会投递岗位信息进行修改和查询。 </p></li></ul><p>本系统集成了学校、毕业生、企业三方信息，便于学生了解和参与本校与企业合作提供的招聘会，同时方便学校做信息调研。</p><h2 id="应用程序功能"><a href="#应用程序功能" class="headerlink" title="应用程序功能"></a>应用程序功能</h2><p>(1) 对所有用户开放：</p><p> 招聘会基本信息的查询 </p><p>招聘会参会企业的查询</p><p> (2) 对学生开放： </p><p>自己基本信息的编辑 </p><p>自己学业信息的编辑 </p><p>报名招聘会 </p><p>(3) 对企业开放： </p><p>本企业信息的编辑 </p><p>毕业生的面试和聘用情况的录入</p><p> (4) 对学校开放： </p><p>招聘与就业信息的查询、统计和分析</p><h2 id="系统-rm-E-R-图"><a href="#系统-rm-E-R-图" class="headerlink" title="系统 $\rm{E-R}$ 图"></a>系统 $\rm{E-R}$ 图</h2><p><img src="1.png" alt="1"></p><h2 id="关系模式设计"><a href="#关系模式设计" class="headerlink" title="关系模式设计"></a>关系模式设计</h2><p>根据概念结构设计得到的 E-R 图和转换规则，得到如下关系模式（主键用下 划线标出，外键予以说明）：</p><ul><li>基本信息：学号、姓名、籍贯、出生日期、性别、身份证号、政治面貌、 民族、婚姻状况、户口所在地、联系电话、电子邮箱。 </li><li>学业信息：学号、学院、专业、最高学历、均绩、英语水平、计算机水平、普通话水平、实习经历、竞赛经历、项目经历。学号外键参考基本信息。 </li><li>招聘会：编号、名称、日期、地址。 </li><li>企业：编号、名称、类型、社会信用代码、城市、邮政代码、联系地址。 </li><li>参会：学号、招聘会编号。学号外键参考基本信息，招聘会编号外键参考招聘会。 </li><li>招聘信息包括：招聘会编号、企业编号、岗位、人数、薪资。 招聘会编号外键参考招聘会，企业编号外键参考企业。 </li><li>面试： 学号、企业编号、岗位、聘用、薪资。学号外键参考基本信息， 企业编号外键参考企业。 </li><li>账户：账号、密码、权限。</li></ul><h2 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h2><video src="http://qw4inwd8e.hd-bkt.clouddn.com/video/%E7%89%9F%E8%83%9C%E6%9D%B0_%E7%99%BD%E5%A3%AB%E5%86%9B_%E9%99%88%E5%89%91%E9%9D%92%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"> your browser does not support the video tag </video><p>代码地址：</p><p><a href="https://github.com/10185102110/Recruitment-and-employment-information-management-system">10185102110/Recruitment-and-employment-information-management-system (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于云数据库 GaussDB(for MySQL)实现，使用华为云账号进行操作。&lt;/p&gt;
&lt;h2 id=&quot;系统描述&quot;&gt;&lt;a href=&quot;#系统描述&quot; class=&quot;headerlink&quot; title=&quot;系统描述&quot;&gt;&lt;/a&gt;系统描述&lt;/h2&gt;&lt;p&gt;大学毕业生要就业，企业要吸收</summary>
      
    
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于openpose的手势识别</title>
    <link href="http://10185102110.github.io/2021/06/13/%E5%9F%BA%E4%BA%8Eopenpose%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
    <id>http://10185102110.github.io/2021/06/13/%E5%9F%BA%E4%BA%8Eopenpose%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/</id>
    <published>2021-06-13T07:31:03.000Z</published>
    <updated>2021-08-28T04:50:30.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多视图引导的手部关键点检测"><a href="#多视图引导的手部关键点检测" class="headerlink" title="多视图引导的手部关键点检测"></a>多视图引导的手部关键点检测</h3><p>作者提出了一种称为 Multiview Bootstrapping 的手部关键点检测迭代改进算法。</p><h4 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h4><p>首先，采用少量标注的人手部关键点图像数据集训练网络，用31个高清摄像头从不同的视角对人手部进行拍摄，</p><p>将拍摄图像送入手部关键点检测器，初步得到粗略的关键点检测结果，再将这些关键点根据摄像机位姿构建三角，</p><p>得到关键点的3D位置，然后将计算得到的3D点位置重投影到每一幅不同视角的2D图像，最后用这些2D图像和关</p><p>键点进一步训练网络，经过几次迭代就能得到较为精确的手部关键点检测模型。</p><h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><p>(1) 定义一个检测器d，I表示图像，$X_p$表示预测关键点坐标，$C_p$表示置信度，P表示点的个数；</p><p>(2) 对于初始化训练集$T_0$：f表示图像帧，每帧$N_0$个视图，y表示真实标签；</p><p>(3) 初始化检测器d；</p><p>(4) 对于未标定数据集$T_1$，用$d_0$进行预测标记，得到检测器$d_1$。用$d_0$标记$T_1$时需要基于多视图几何进行监督，至</p><p>少存在2个视图检测成功，才能保证$T_1$中不包含$T_0$已经存在的信息；</p><p>(5) 预测每一个视图；</p><p>(6) 最小化重投影误差，三角化3D关键点；</p><p>(7) 根据置信度的和对视图排序，只选择成功的视图进行三维重建；</p><p>(8) 重投影到失败视图，生成N帧视图，用于迭代训练检测器。</p><script type="math/tex; mode=display">\begin{align*}  & d(\rm{I})\rightarrow \{(X_p,C_p)\ \rm{for}\ \ p \in [1\dots\it{P}\rm{]}\}\tag{1}\\  & T_0:=\{(I^f,\{y_p^f\})\ \rm{for}\ f\in[1\dots \it{N_0}\rm{]}\}\tag{2}\\  & d_0\leftarrow \rm{train}(T_0)\tag{3}\\  & d_1\leftarrow \rm{train}(T_0\cup T_1)\tag{4}\\  & D\leftarrow\{d_i(\rm{I}_v^f)\ \rm{for}\ \it{v}\in\rm{[}1\dots V]\}\tag{5}\\  & \rm{X}_p^f=arg\ \underset{X}min\sum\limits_{v\in I_p^f}||\it{P}_v\rm{(X)}-X_p^v||_2^2\tag{6}\\  & \rm{score}(\{X_p^f\})=\sum\limits_{p\in[1\dots P]}\sum\limits_{v\in I_p^f}c_p^v\tag{7}\\  & T_{i+1}=\{\rm{(I_v^{Sn}},\{P_v(X_p^{Sn}):v\in [1\dots V],p\in [1\dots P]\})\ for\ n\in[1\dots N\}\tag{8}\end{align*}</script><p><img src="2.png" alt=""></p><p><img src="0.png" alt=""></p><h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>采用CPM (Convolutional Pose Machines) 网络：</p><p>CPM是由全卷积网络组成的序列化结构，卷积网络直接在前一阶段的置信图操作，输出越来越精细化的关节点位</p><p>置估计结果。</p><p><img src="1.png" alt=""></p><p>流程：</p><ul><li>基于每个尺度，计算网络预测的各关节点的热力图</li><li>累加各个关节点对应的所有尺度的热力图，取最大值所在位置为关节点位置</li></ul><p><img src="3.png" alt=""></p><p>文中提出的模型可生成22个关键点，其中21个点是人手部的，第22个点代表背景。</p><p><img src="line.png" alt=""></p><p><img src="dot.png" alt=""></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protoFile = <span class="string">r&quot;C:\Users\AveBai\Desktop\model\pose_deploy.prototxt&quot;</span></span><br><span class="line">weightsFile = <span class="string">r&quot;C:\Users\AveBai\Desktop\model\pose_iter_102000.caffemodel&quot;</span></span><br><span class="line">nPoints = <span class="number">22</span></span><br><span class="line">POSE_PAIRS = [ [<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">0</span>,<span class="number">9</span>],[<span class="number">9</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">11</span>],[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">0</span>,<span class="number">13</span>],[<span class="number">13</span>,<span class="number">14</span>],[<span class="number">14</span>,<span class="number">15</span>],[<span class="number">15</span>,<span class="number">16</span>],[<span class="number">0</span>,<span class="number">17</span>],[<span class="number">17</span>,<span class="number">18</span>],[<span class="number">18</span>,<span class="number">19</span>],[<span class="number">19</span>,<span class="number">20</span>] ]</span><br><span class="line"></span><br><span class="line">threshold = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line">input_source = <span class="string">r&quot;C:\Users\AveBai\Desktop\img\1.mp4&quot;</span></span><br><span class="line">cap = cv2.VideoCapture(input_source)</span><br><span class="line">hasFrame, frame = cap.read()</span><br><span class="line"></span><br><span class="line">frameWidth = frame.shape[<span class="number">1</span>]</span><br><span class="line">frameHeight = frame.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">aspect_ratio = frameWidth/frameHeight</span><br><span class="line"></span><br><span class="line">inHeight = <span class="number">368</span></span><br><span class="line">inWidth = <span class="built_in">int</span>(((aspect_ratio*inHeight)*<span class="number">8</span>)//<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">vid_writer = cv2.VideoWriter(<span class="string">r&#x27;C:\Users\AveBai\Desktop\res\output.avi&#x27;</span>,cv2.VideoWriter_fourcc(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;G&#x27;</span>), <span class="number">15</span>, (frame.shape[<span class="number">1</span>],frame.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">net = cv2.dnn.readNetFromCaffe(protoFile, weightsFile)</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    k+=<span class="number">1</span></span><br><span class="line">    t = time.time()</span><br><span class="line">    hasFrame, frame = cap.read()</span><br><span class="line">    frameCopy = np.copy(frame)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasFrame:</span><br><span class="line">        cv2.waitKey()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    inpBlob = cv2.dnn.blobFromImage(frame, <span class="number">1.0</span> / <span class="number">255</span>, (inWidth, inHeight),    <span class="comment"># 图像归一化</span></span><br><span class="line">                              (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), swapRB=<span class="literal">False</span>, crop=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    net.setInput(inpBlob)  <span class="comment"># 将图片输入到caffe网络中</span></span><br><span class="line"></span><br><span class="line">    output = net.forward()   <span class="comment"># 前向传播</span></span><br><span class="line"></span><br><span class="line">    points = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nPoints):</span><br><span class="line">        <span class="comment"># 置信度</span></span><br><span class="line">        probMap = output[<span class="number">0</span>, i, :, :]</span><br><span class="line">        probMap = cv2.resize(probMap, (frameWidth, frameHeight))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 精确定位</span></span><br><span class="line">        minVal, prob, minLoc, point = cv2.minMaxLoc(probMap)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prob &gt; threshold :</span><br><span class="line">            cv2.circle(frameCopy, (<span class="built_in">int</span>(point[<span class="number">0</span>]), <span class="built_in">int</span>(point[<span class="number">1</span>])), <span class="number">6</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>, lineType=cv2.FILLED)</span><br><span class="line">            cv2.putText(frameCopy, <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i), (<span class="built_in">int</span>(point[<span class="number">0</span>]), <span class="built_in">int</span>(point[<span class="number">1</span>])), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">.8</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, lineType=cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line">            points.append((<span class="built_in">int</span>(point[<span class="number">0</span>]), <span class="built_in">int</span>(point[<span class="number">1</span>])))</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            points.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pair <span class="keyword">in</span> POSE_PAIRS:</span><br><span class="line">        partA = pair[<span class="number">0</span>]</span><br><span class="line">        partB = pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> points[partA] <span class="keyword">and</span> points[partB]:</span><br><span class="line">            cv2.line(frame, points[partA], points[partB], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>, lineType=cv2.LINE_AA)</span><br><span class="line">            cv2.circle(frame, points[partA], <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>, lineType=cv2.FILLED)</span><br><span class="line">            cv2.circle(frame, points[partB], <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>, lineType=cv2.FILLED)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;time a frame = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(time.time() - t))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Output&#x27;</span>, frame)</span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;total time= &#123;&#125;&quot;</span>.<span class="built_in">format</span>(time.time() - t))</span><br><span class="line"></span><br><span class="line">    vid_writer.write(frame)</span><br><span class="line"></span><br><span class="line">vid_writer.release()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h4><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=546123557&bvid=BV1uq4y1L7X9&cid=353519444&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul><li><p>Hand Keypoint Detection in Single Images using Multiview Bootstrapping</p><p><a href="https://arxiv.org/pdf/1704.07809.pdf">https://arxiv.org/pdf/1704.07809.pdf</a></p></li><li><p>Convolutional Pose Machines</p><p><a href="https://arxiv.org/pdf/1602.00134.pdf">https://arxiv.org/pdf/1602.00134.pdf</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多视图引导的手部关键点检测&quot;&gt;&lt;a href=&quot;#多视图引导的手部关键点检测&quot; class=&quot;headerlink&quot; title=&quot;多视图引导的手部关键点检测&quot;&gt;&lt;/a&gt;多视图引导的手部关键点检测&lt;/h3&gt;&lt;p&gt;作者提出了一种称为 Multiview Bootst</summary>
      
    
    
    
    <category term="Tracker" scheme="http://10185102110.github.io/categories/Tracker/"/>
    
    
    <category term="Tracker" scheme="http://10185102110.github.io/tags/Tracker/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记</title>
    <link href="http://10185102110.github.io/2021/05/16/CPP%E7%AC%94%E8%AE%B0/"/>
    <id>http://10185102110.github.io/2021/05/16/CPP%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-16T09:13:40.000Z</published>
    <updated>2021-08-28T04:46:39.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector 是C++ STL的一个重要成员，使用它时需要包含头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>;</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>有五种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量，但没有给出初值。</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量,且给出每个元素的初值为1</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//用b向量来创建a向量，整体复制性赋值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>; <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>)</span></span>; <span class="comment">//从数组中获得初值</span></span><br></pre></td></tr></table></figure><h4 id="重要操作"><a href="#重要操作" class="headerlink" title="重要操作"></a>重要操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//a只含4个元素，且每个元素为2</span></span><br><span class="line">a.<span class="built_in">back</span>(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在</span></span><br><span class="line">a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//判断a是否为空，空则返回ture,否则返回false</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素的位置插入b的第3个元素到第5个元素</span></span><br><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">a.<span class="built_in">capacity</span>(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，避免内存自动进行容量扩充操作</span></span><br><span class="line">a.<span class="built_in">swap</span>(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br></pre></td></tr></table></figure><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li><p>添加元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>从数组中选择元素添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=a.<span class="built_in">begin</span>();it&lt;a.<span class="built_in">end</span>();it++)</span><br><span class="line">    b.<span class="built_in">push_back</span>(*it);</span><br></pre></td></tr></table></figure></li><li><p>从文件读取元素并添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; in&gt;&gt;i)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>通过下标读取元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=b.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">    cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="重要算法"><a href="#重要算法" class="headerlink" title="重要算法"></a>重要算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括）到a.end()（不包括）的元素进行从小到大排列</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括）到a.end()（不包括）的元素倒置</span></span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括）到a.end()（不包括）的元素复制到b中，从b.begin()+1的位置（包括）开始复制，覆盖原有元素</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括）到a.end()（不包括）的元素中查找10，若存在返回其在向量中的位置</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是STL的一个关联容器，它提供一对一的hash。</p><p>map内部的实现是自建一颗红黑树，这颗树具有对数据自动排序的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; m;</span><br></pre></td></tr></table></figure><h4 id="重要操作-1"><a href="#重要操作-1" class="headerlink" title="重要操作"></a>重要操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>));</span><br><span class="line">m[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line">iter = m.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);<span class="comment">//返回查找元素的位置否则返回map::end()位置</span></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(iter);</span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());<span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">clear</span>();<span class="comment">//清空</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="keyword">int</span> n = m.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//如果map为空则返回true</span></span><br><span class="line"><span class="built_in">lower_bound</span>()<span class="comment">//返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line"><span class="built_in">max_size</span>()    <span class="comment">//返回可以容纳的最大元素个数</span></span><br><span class="line"><span class="built_in">swap</span>()   <span class="comment">//交换两个map</span></span><br><span class="line"><span class="built_in">count</span>(key)  <span class="comment">//查询关键字为key的元素的个数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector 是C++ S</summary>
      
    
    
    
    <category term="C++" scheme="http://10185102110.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://10185102110.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>DNS的配置与管理</title>
    <link href="http://10185102110.github.io/2021/05/14/DNS%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>http://10185102110.github.io/2021/05/14/DNS%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-14T14:14:36.000Z</published>
    <updated>2021-08-28T04:47:05.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS的配置与管理"><a href="#DNS的配置与管理" class="headerlink" title="DNS的配置与管理"></a>DNS的配置与管理</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><ol><li><h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h3></li></ol><ul><li>全称：Domain Name System /域名系统</li><li>使域名和 IP 地址相互映射</li><li>域名解析：通过主机名，最终得到该主机名对应的IP地址的过程</li></ul><ol><li><h3 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h3></li></ol><ul><li><p>概念：与网络上的数字型IP地址相对应的字符型地址</p></li><li><p>一般结构：主机名.三级域名.二级域名.顶级域名</p><p>– 顶级域名：cn、jp … edu、org …</p><p>– 二级域名：ibm、yahoo … com、edu、net、gov、top …</p><p>– 三级域名：A-Z, a-z, 0-9, 连接符 -</p></li></ul><ol><li><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3></li></ol><ul><li>第0步：检查本地缓存</li><li>第1步：向本地DNS服务器请求</li><li>第2步：向根域名服务器请求</li><li>第3步：向顶级域名服务器请求</li><li>第4步：向权威域名服务器请求</li><li>一旦成功：返回结果，缓存留作备用，解析过程中止</li></ul><ol><li><h3 id="DNS查询模式"><a href="#DNS查询模式" class="headerlink" title="DNS查询模式"></a>DNS查询模式</h3></li></ol><ul><li>递归查询：若自身不能，则以客户身份请求其他，客户机和服务器之间属于递归查询</li><li><p>循环查询：若自身不能，则指导客户请求其他，一般DNS服务器之间属于循环查询</p></li><li><p>正向解析：通过域名查 ip</p></li><li>反向解析：通过 ip 查域名</li></ul><ol><li><h3 id="DNS服务器类型"><a href="#DNS服务器类型" class="headerlink" title="DNS服务器类型"></a>DNS服务器类型</h3></li></ol><ul><li>主域名服务器 master </li><li>辅助域名服务器 slave </li><li>缓存服务器 Caching-only</li></ul><ol><li><h3 id="DNS资源记录"><a href="#DNS资源记录" class="headerlink" title="DNS资源记录"></a>DNS资源记录</h3></li></ol><ul><li>SOA记录（Start Of Authority record）起始授权记录</li><li>NS 记录(Name Server record)当前区域的DNS服务器</li><li>A 和 AAAA 记录（Adress record）</li><li>PTR 记录（PoinTer Record）全限定域名</li><li>CNAME（Canonical Name record）别名记录</li><li>MX 记录（Mail eXchange record）邮件交换器</li></ul><h2 id="二、项目实施"><a href="#二、项目实施" class="headerlink" title="二、项目实施"></a>二、项目实施</h2><ol><li><h3 id="安装-DNS-服务软件"><a href="#安装-DNS-服务软件" class="headerlink" title="安装 DNS 服务软件"></a>安装 DNS 服务软件</h3></li></ol><ul><li><p>bind：DNS服务主程序，仅服务器端需要</p></li><li><p>bind-utils：辅助工具，用于测试 DNS，服务器和客户端都需要</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install bind bind-utils</span><br><span class="line">注：本实验基于上次的DHCP，先把网络连接方式改成NAT，再将ifcfg-enp0s3文件恢复原样，</span><br><span class="line">最后重启网卡：service network restart ，安装成功再改回DHCP的配置</span><br></pre></td></tr></table></figure></li></ul><ol><li><h3 id="修改主服务器主配置文件：-etc-named-conf"><a href="#修改主服务器主配置文件：-etc-named-conf" class="headerlink" title="修改主服务器主配置文件：/etc/named.conf"></a>修改主服务器主配置文件：/etc/named.conf</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">  listen-on port 53 &#123; any; &#125;; // 在本机所有网卡的#53端口监听</span><br><span class="line">  ……</span><br><span class="line">  directory &quot;/var/named&quot;;</span><br><span class="line">  ……</span><br><span class="line">  allow-query &#123; any; &#125;; // 允许所有客户端请求</span><br><span class="line">  ……</span><br><span class="line">&#125;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><h3 id="主服务器扩展配置文件：-etc-named-rfc1912-zones"><a href="#主服务器扩展配置文件：-etc-named-rfc1912-zones" class="headerlink" title="主服务器扩展配置文件：/etc/named.rfc1912.zones"></a>主服务器扩展配置文件：/etc/named.rfc1912.zones</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在前面添加如下代码</span></span><br><span class="line">zone &quot;ecnu.edu&quot; IN &#123; // 正向解析信息</span><br><span class="line">type master; // 主服务器</span><br><span class="line">file &quot;ecnu.edu.zone&quot;; // 区域文件名</span><br><span class="line">allow-update &#123;192.168.100.2;&#125;; // 填写从服务器，若无，则填 none</span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;100.168.192.in-addr.arpa&quot; IN &#123; // 反向解析信息</span><br><span class="line">type master; // 主服务器</span><br><span class="line">file &quot;192.168.100.arpa&quot;; // 区域文件名</span><br><span class="line">allow-update &#123;192.168.100.2;&#125;; // 从服务器</span><br><span class="line">&#125;;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><h3 id="正向解析文件：-var-named-ecnu-edu-zone"><a href="#正向解析文件：-var-named-ecnu-edu-zone" class="headerlink" title="正向解析文件：/var/named/ecnu.edu.zone"></a>正向解析文件：/var/named/ecnu.edu.zone</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv named]#cp -a named.localhost ecnu.ed</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$TTL 1D</span><br><span class="line">@ IN SOA ns1.ecnu.edu. admin.ecnu.edu. ( // ns1:DNS服务器 // 联系 admin@ecnu.edu</span><br><span class="line">  0 ; serial</span><br><span class="line">  1D ; refresh</span><br><span class="line">  1H ; retry</span><br><span class="line">  1W ; expire</span><br><span class="line">  3H ); minimum</span><br><span class="line"><span class="code">      IN NS ns1.ecnu.edu. // DNS服务器</span></span><br><span class="line"><span class="code">dhcp  IN A 192.168.100.1 // 定义域名与IP地址的映射</span></span><br><span class="line"><span class="code">ns1   IN A 192.168.100.1</span></span><br><span class="line"><span class="code">ns2   IN A 192.168.100.2</span></span><br><span class="line"><span class="code">ftp   IN A 192.168.100.10</span></span><br><span class="line"><span class="code">www   IN A 192.168.100.20</span></span><br><span class="line"><span class="code">mail  IN A 192.168.100.30</span></span><br></pre></td></tr></table></figure></li><li><h3 id="反向解析文件：-var-named-192-168-100-arpa"><a href="#反向解析文件：-var-named-192-168-100-arpa" class="headerlink" title="反向解析文件：/var/named/192.168.100.arpa"></a>反向解析文件：/var/named/192.168.100.arpa</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv named]#cp -a named.loopback 192.168.100.arpa</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$TTL 1D</span><br><span class="line">@ IN SOA ns1.ecnu.edu. admin.ecnu.edu. ( // ns1:DNS服务器 // 联系 admin@ecnu.edu</span><br><span class="line">  0 ; serial</span><br><span class="line">  1D ; refresh</span><br><span class="line">  1H ; retry</span><br><span class="line">  1W ; expire</span><br><span class="line">  3H ); minimum</span><br><span class="line"><span class="code">      IN NS ns1.ecnu.edu. // DNS服务器</span></span><br><span class="line"><span class="code">ns1   IN A 192.168.100.1</span></span><br><span class="line"><span class="code">1     IN PTR dhcp.ecnu.edu. // 定义IP地址与域名的映射</span></span><br><span class="line"><span class="code">1     IN PTR ns1.ecnu.edu.</span></span><br><span class="line"><span class="code">2     IN PTR ns2.ecnu.edu.</span></span><br><span class="line"><span class="code">10    IN PTR ftp.ecnu.edu.</span></span><br><span class="line"><span class="code">20    IN PTR www.ecnu.edu.</span></span><br><span class="line"><span class="code">30    IN PTR mail.ecnu.edu.</span></span><br></pre></td></tr></table></figure></li><li><h3 id="本机测试"><a href="#本机测试" class="headerlink" title="本机测试"></a>本机测试</h3></li></ol><ul><li><p>启动服务器</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv ~]# systemctl start named</span><br></pre></td></tr></table></figure></li><li><p>确保服务器指向本机</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv ~]# cat /etc/resolv.conf</span><br><span class="line">nameserver 192.168.100.1</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="1.png" alt=""></p></li></ul><ol><li><h3 id="异机测试"><a href="#异机测试" class="headerlink" title="异机测试"></a>异机测试</h3><p>即开启DHCP服务后，结果同上</p></li><li><h3 id="配置辅助DNS服务器及测试"><a href="#配置辅助DNS服务器及测试" class="headerlink" title="配置辅助DNS服务器及测试"></a>配置辅助DNS服务器及测试</h3></li></ol><ul><li><p>复制虚拟机 Srv2</p></li><li><p>关闭 Srv 和 Srv2 的防火墙</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li><li><p>修改 /etc/resolv.conf 将客户端 DNS 改为192.168.100.2</p></li><li><p>修改 /etc/named.rfc1912.zones</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;ecnu.edu&quot; IN &#123;</span><br><span class="line">  type slave;</span><br><span class="line">  file &quot;slaves/ecnu.edu.zone&quot;;</span><br><span class="line">  masters &#123;192.168.100.1;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;100.168.192.in-addr.arpa&quot; IN &#123;</span><br><span class="line">  type slave;</span><br><span class="line">  file &quot;slaves/192.168.100.arpa&quot;;</span><br><span class="line">  masters &#123;192.168.100.1;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>重启服务器，/var/named/slaves 中已同步正/反向解析文件</p></li><li><p>测试</p><p><img src="2.png" alt=""></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DNS的配置与管理&quot;&gt;&lt;a href=&quot;#DNS的配置与管理&quot; class=&quot;headerlink&quot; title=&quot;DNS的配置与管理&quot;&gt;&lt;/a&gt;DNS的配置与管理&lt;/h1&gt;&lt;h2 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Server" scheme="http://10185102110.github.io/categories/Server/"/>
    
    
    <category term="Server" scheme="http://10185102110.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>DHCP的配置与管理</title>
    <link href="http://10185102110.github.io/2021/05/14/DHCP%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>http://10185102110.github.io/2021/05/14/DHCP%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-14T13:46:49.000Z</published>
    <updated>2021-08-28T04:46:48.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DHCP的配置与管理"><a href="#DHCP的配置与管理" class="headerlink" title="DHCP的配置与管理"></a>DHCP的配置与管理</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><ol><li><h3 id="什么是DHCP"><a href="#什么是DHCP" class="headerlink" title="什么是DHCP"></a>什么是DHCP</h3><p>– 全称：Dynamic Host Configuration Protocol ，动态主机配置协议 </p><p>– 是一个局域网的网络协议，使用UDP协议工作 </p><p>– 中、大型网络中手动分配IP地址的方法不合适 ，DHCP可高效分配IP地址 </p></li><li><h3 id="DHCP的主要功能"><a href="#DHCP的主要功能" class="headerlink" title="DHCP的主要功能"></a>DHCP的主要功能</h3><p>–为内部网络自动分配IP地址 </p><p>– 中央管理所有计算机的手段</p></li><li><h3 id="DHCP服务优点"><a href="#DHCP服务优点" class="headerlink" title="DHCP服务优点"></a>DHCP服务优点</h3><p>– 集中验证IP地址等参数，不必检查每个主机</p><p>– 不会分配相同IP给不同主机 </p><p>– 约束特定计算机使用特定IP </p><p>– 为DHCP作用域设置各种选项</p><p>– 子网间移动主机不需重设IP</p></li><li><h3 id="DHCP服务缺点"><a href="#DHCP服务缺点" class="headerlink" title="DHCP服务缺点"></a>DHCP服务缺点</h3><p>– 不能发现非DHCP客户机IP </p><p>– 多DHCP服务器难联动分配 </p><p>– DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发</p></li><li><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><p>– DHCP服务器：提供DHCP服务的计算机 </p><p>– DHCP客户端：启用DHCP设置的计算机 </p><p>– 作用域：完整连续的可用IP地址范围 </p><p>– 排除范围：作用域内从DHCP服务中排除的有限IP地址序列 </p><p>– 地址池：定义作用域并应用排除范围后剩余的地址 </p><p>– 租约：客户机可使用动态分配IP地址的时间 </p><ul><li><p>客户机发出租约后：此租约被看作是活动的 </p></li><li><p>租约终止前：客户机可向DHCP服务器请求更新租约 </p></li><li><p>租约到期或被删后：此租约变为不活动的 </p></li></ul></li></ol><p>– 预约：客户机指定永久租约</p><ol><li><h3 id="DCHP的工作流程"><a href="#DCHP的工作流程" class="headerlink" title="DCHP的工作流程"></a>DCHP的工作流程</h3><p>– 发现阶段：客户机寻找服务器 </p><p>– 提供阶段：服务器提供IP地址 </p><p>– 选择阶段：客户机选择某台服务器提供的IP地址 </p><p>– 确认阶段：服务器确认所提供的IP地址 </p><p>– 重新登录</p><ul><li>客户机重新登录网络时，不需再发送DHCPdiscover发现信息</li><li>直接发送包含前一次所分配的IP地址的DHCPrequest请求信息 </li></ul><p>– 更新租约</p><ul><li>出租IP有租借期限，期满后便收回</li><li>如要延长租约，则须更新租约</li></ul></li><li><h3 id="DHCP分配地址的方法"><a href="#DHCP分配地址的方法" class="headerlink" title="DHCP分配地址的方法"></a>DHCP分配地址的方法</h3><p>– 自动分配</p><ul><li>服务器为客户机指定永久IP地址</li><li>第一次成功租到IP地址后就可永久使用 </li></ul><p>– 动态分配</p><ul><li>服务器为客户机指定具时间限制的IP地址</li><li>到期或明确放弃该地址时可被其他客户机使用</li></ul><p>– 手工分配：客户机IP地址由网管指定</p></li></ol><h2 id="二、项目实施"><a href="#二、项目实施" class="headerlink" title="二、项目实施"></a>二、项目实施</h2><ol><li><h3 id="准备-3-台机器"><a href="#准备-3-台机器" class="headerlink" title="准备 3 台机器"></a>准备 3 台机器</h3><p>– 安装好 1 台CentOS虚拟机 </p><p>– 使用链接复制的方式复制3台 </p><ul><li>命名分别为 Srv、CliCent1和CliCent2</li><li>分别用作DHCP服务器、测试用客户端1和测试用客户端2 </li></ul><p><img src="1.png" alt=""></p><p><img src="2.png" alt=""></p><p>– 修改3台虚拟机的主机名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname [MYHOSTNAME]</span><br></pre></td></tr></table></figure><p>– 修改 3 台虚拟机的唯一编号</p><ul><li><p>/etc/machine-id</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uuidgen &gt;/etc/machine-id</span><br></pre></td></tr></table></figure></li><li><p>/etc/sysconfig/network-scripts/ifcfg-enp0s3</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/^UUID=[0-9a-z\-]<span class="emphasis">*$/UUID=`uuidgen`/g&quot; /etc/sysconfig/network-scripts/ifcfg-enp0s3</span></span><br></pre></td></tr></table></figure></li><li><p>uuidgen命令可产生唯一标识UUID</p></li></ul><p><img src="3.png" alt=""></p></li><li><h3 id="安装DHCP"><a href="#安装DHCP" class="headerlink" title="安装DHCP"></a>安装DHCP</h3><p>– yum安装命令 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install dhcp</span><br></pre></td></tr></table></figure><p>– 安装完后会生成主配置文件：/etc/dhcp/dhcpd.conf</p><p>– 确保客户机上安装有DHCP客户端程序 dhcp-clien</p></li><li><h3 id="配置DHCP"><a href="#配置DHCP" class="headerlink" title="配置DHCP"></a>配置DHCP</h3><p>– Srv主配置文件</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ddns-update-style none;</span><br><span class="line">option domain-name-servers 192.168.100.1;</span><br><span class="line">subnet 192.168.100.0 netmask 255.255.255.0 &#123;</span><br><span class="line">range 192.168.100.101 192.168.100.200;</span><br><span class="line">option routers 192.168.100.1;</span><br><span class="line">option subnet-mask 255.255.255.0;</span><br><span class="line">&#125;</span><br><span class="line">DHCPDARGS=&quot;enp0s3&quot;;</span><br><span class="line"><span class="section">#服务器IP是192.168.100.1</span></span><br><span class="line"><span class="section">#分本的地址是该网段的 192.168.100.101~192.168.100.200</span></span><br><span class="line"><span class="section">#绑定在 enp0s3网卡上</span></span><br></pre></td></tr></table></figure><p><img src="4.png" alt=""></p><p>– 修改Srv的网络配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=static   # 将IP地址设为静态</span><br><span class="line">IPADDR=192.168.100.1</span><br><span class="line">NETMASK=255.255.255.0</span><br></pre></td></tr></table></figure><p><img src="5.png" alt=""></p><p>– 客户机CliCent1和CliCent2 维持原状</p><p>– 改虚拟机的网络为内部网络并刷新网卡物理地址</p><p><img src="6.png" alt=""></p></li><li><p>启动服务器</p><p>– 在Srv上启动DHCP服务器</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dhcp</span><br></pre></td></tr></table></figure><p><img src="7.png" alt=""></p><p>– 重启客户机CliCent1和CliCent2</p><ul><li>查看其IP地址</li><li>相互Ping检查是否相通</li></ul><p><img src="8.png" alt=""></p><p><img src="9.png" alt=""></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DHCP的配置与管理&quot;&gt;&lt;a href=&quot;#DHCP的配置与管理&quot; class=&quot;headerlink&quot; title=&quot;DHCP的配置与管理&quot;&gt;&lt;/a&gt;DHCP的配置与管理&lt;/h1&gt;&lt;h2 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;</summary>
      
    
    
    
    <category term="Server" scheme="http://10185102110.github.io/categories/Server/"/>
    
    
    <category term="Server" scheme="http://10185102110.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>基于CF的单目标追踪</title>
    <link href="http://10185102110.github.io/2021/05/12/%E5%9F%BA%E4%BA%8ECF%E5%8D%95%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"/>
    <id>http://10185102110.github.io/2021/05/12/%E5%9F%BA%E4%BA%8ECF%E5%8D%95%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/</id>
    <published>2021-05-12T04:46:49.000Z</published>
    <updated>2021-08-28T04:50:00.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Correlation-Filter-based-tracker（相关滤波器）"><a href="#Correlation-Filter-based-tracker（相关滤波器）" class="headerlink" title="Correlation Filter based tracker（相关滤波器）"></a>Correlation Filter based tracker（相关滤波器）</h2><h4 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h4><p>寻找一个滤波模版 H，与输入图像 F 求相关性，得到相关图 G。相关图 G 描述目标响应，越接近时值越大，使得当 H 作用在跟踪目标上时，得到的响应最大。</p><h4 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h4><script type="math/tex; mode=display">\begin{eqnarray*}&&g=f\bigodot h^{*} \tag{1} \\&&F(g)=F(f⨀h^{*})=F(f)\cdot F(h)^{*} \tag{2}\\&&G=F\cdot H^{*} \tag{3}\\&&H^{*}=\frac{G}{F} \tag{4}\\&&\underset{H^{*}}{min}\sum\limits_{i}|F_{i}⊙H^{∗} − G_{i}|^{2}\tag{5}\\&&0=\frac{∂}{∂H^{*}_{ων}}\sum\limits_{i}|F_{iων}H^{∗}_{ων} − G_{iων}|^{2}\tag{6}\\&& H=\frac{\sum_i G_{i}⊙F^{∗}_i}{\sum_i F_{i}⊙F^{∗}_i}\tag{7}\\&&H^{*}_i=η\frac{G_{i}⊙F^{∗}_i}{F_{i}⊙F^{∗}_i}+(1-η)H^∗_{i−1}=\frac{A_i}{B_i} \tag{8}\\&&A_i=ηG_i ⊙ F^∗_i + (1 − η)A_{i−1}\\&&B_i=ηF_i ⊙ F^∗_i + (1 − η)B_{i−1}\end{eqnarray*}</script><ol><li><p>g 表示响应输出，f 表示输入图像，h 表示滤波模板，$h^{*}$表示复共轭(实部不变，虚部取反)；</p></li><li><p>为加快计算速度，根据卷积定理可知，函数互相关的傅里叶变换等于函数傅里叶变换的乘积；</p></li><li><p>由(2)得到；</p></li><li>由(3)得到，$H^{*}$就是所求滤波器；</li><li>MOSSE 采用最小化平方和误差；</li><li>将图像展开到像素，最小化求偏导等于 0；</li><li>最终得到求解公式；</li><li>在线更新策略，根据当前帧不断进行调整。</li></ol><h4 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h4><ul><li>run.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> basetracker</span><br><span class="line"></span><br><span class="line">initTracking = <span class="literal">True</span></span><br><span class="line">ix, iy, cx, cy = -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">w, h = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">inteval = <span class="number">1</span></span><br><span class="line">duration = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">cap = cv2.VideoCapture(<span class="string">&quot;CarScale.avi&quot;</span>)</span><br><span class="line"><span class="comment">#获取cap的视频帧</span></span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line"><span class="comment"># 获取cap视频流的每帧大小</span></span><br><span class="line">size = (<span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),<span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line"><span class="comment"># 定义视频格式，参数搭配固定，不同的编码格式对应不同的参数</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义视频文件输入对象</span></span><br><span class="line">outVideo = cv2.VideoWriter(<span class="string">&quot;result.mp4&quot;</span>, fourcc, fps, size,isColor=<span class="literal">True</span>)</span><br><span class="line">inteval = <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">tracker = basetracker.BaseTracker(<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>)  <span class="comment"># hog, fixed_window, multiscale</span></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;tracking&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">ret, frame = cap.read()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(initTracking):</span><br><span class="line">r = cv2.selectROI(<span class="string">&#x27;tracking&#x27;</span>,frame)   <span class="comment">#????</span></span><br><span class="line">ix, iy, w, h = r</span><br><span class="line">tracker.init([ix,iy,w,h], frame)</span><br><span class="line">initTracking = <span class="literal">False</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">t0 = time()</span><br><span class="line">boundingbox = tracker.update(frame)</span><br><span class="line">t1 = time()</span><br><span class="line"></span><br><span class="line">boundingbox = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, boundingbox))</span><br><span class="line">cv2.rectangle(frame,(boundingbox[<span class="number">0</span>],boundingbox[<span class="number">1</span>]), (boundingbox[<span class="number">0</span>]+boundingbox[<span class="number">2</span>],boundingbox[<span class="number">1</span>]+boundingbox[<span class="number">3</span>]), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">duration = <span class="number">0.8</span>*duration + <span class="number">0.2</span>*(t1-t0)</span><br><span class="line"><span class="comment">#duration = t1-t0</span></span><br><span class="line">cv2.putText(frame, <span class="string">&#x27;FPS: &#x27;</span>+<span class="built_in">str</span>(<span class="number">1</span>/duration)[:<span class="number">4</span>].strip(<span class="string">&#x27;.&#x27;</span>), (<span class="number">8</span>,<span class="number">20</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.6</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用VideoWriter类中的write(frame)方法，将图像帧写入视频文件</span></span><br><span class="line">outVideo.write(frame)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;tracking&#x27;</span>, frame)</span><br><span class="line">c = cv2.waitKey(inteval) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">outVideo.release()</span><br><span class="line"><span class="comment">#cv2.waitKey()</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><ul><li>basetracker.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># recttools</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x2</span>(<span class="params">rect</span>):</span></span><br><span class="line">    <span class="keyword">return</span> rect[<span class="number">0</span>] + rect[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y2</span>(<span class="params">rect</span>):</span></span><br><span class="line">    <span class="keyword">return</span> rect[<span class="number">1</span>] + rect[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limit</span>(<span class="params">rect, limit</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">0</span>] + rect[<span class="number">2</span>] &gt; limit[<span class="number">0</span>] + limit[<span class="number">2</span>]):</span><br><span class="line">        rect[<span class="number">2</span>] = limit[<span class="number">0</span>] + limit[<span class="number">2</span>] - rect[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">1</span>] + rect[<span class="number">3</span>] &gt; limit[<span class="number">1</span>] + limit[<span class="number">3</span>]):</span><br><span class="line">        rect[<span class="number">3</span>] = limit[<span class="number">1</span>] + limit[<span class="number">3</span>] - rect[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">0</span>] &lt; limit[<span class="number">0</span>]):</span><br><span class="line">        rect[<span class="number">2</span>] -= (limit[<span class="number">0</span>] - rect[<span class="number">0</span>])</span><br><span class="line">        rect[<span class="number">0</span>] = limit[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">1</span>] &lt; limit[<span class="number">1</span>]):</span><br><span class="line">        rect[<span class="number">3</span>] -= (limit[<span class="number">1</span>] - rect[<span class="number">1</span>])</span><br><span class="line">        rect[<span class="number">1</span>] = limit[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">2</span>] &lt; <span class="number">0</span>):</span><br><span class="line">        rect[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">3</span>] &lt; <span class="number">0</span>):</span><br><span class="line">        rect[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> rect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getBorder</span>(<span class="params">original, limited</span>):</span></span><br><span class="line">    res = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    res[<span class="number">0</span>] = limited[<span class="number">0</span>] - original[<span class="number">0</span>]</span><br><span class="line">    res[<span class="number">1</span>] = limited[<span class="number">1</span>] - original[<span class="number">1</span>]</span><br><span class="line">    res[<span class="number">2</span>] = x2(original) - x2(limited)</span><br><span class="line">    res[<span class="number">3</span>] = y2(original) - y2(limited)</span><br><span class="line">    <span class="keyword">assert</span> (np.<span class="built_in">all</span>(np.array(res) &gt;= <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subwindow</span>(<span class="params">img, window, borderType=cv2.BORDER_CONSTANT</span>):</span></span><br><span class="line">    cutWindow = [x <span class="keyword">for</span> x <span class="keyword">in</span> window]</span><br><span class="line">    cutWindow = limit(cutWindow, [<span class="number">0</span>, <span class="number">0</span>, img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]])  <span class="comment"># modify cutWindow</span></span><br><span class="line">    <span class="keyword">assert</span> (cutWindow[<span class="number">2</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> cutWindow[<span class="number">3</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    border = getBorder(window, cutWindow)</span><br><span class="line">    res = img[cutWindow[<span class="number">1</span>]:cutWindow[<span class="number">1</span>] + cutWindow[<span class="number">3</span>], cutWindow[<span class="number">0</span>]:cutWindow[<span class="number">0</span>] + cutWindow[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (border != [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]):</span><br><span class="line">        res = cv2.copyMakeBorder(res, border[<span class="number">1</span>], border[<span class="number">3</span>], border[<span class="number">0</span>], border[<span class="number">2</span>], borderType)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># KCF tracker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTracker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hog=<span class="literal">False</span>, fixed_window=<span class="literal">True</span>, multiscale=<span class="literal">False</span></span>):</span></span><br><span class="line">        self._interp_factor = <span class="number">0.0075</span>  <span class="comment"># model updating rate</span></span><br><span class="line">        self._tmpl_sz = np.array([<span class="number">50</span>, <span class="number">50</span>])  <span class="comment"># the fixed model size</span></span><br><span class="line">        self._roi = [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]  <span class="comment"># cv::Rect2f, [left_up_x,left_up_y,width,height]</span></span><br><span class="line">        self._tmpl = <span class="literal">None</span>  <span class="comment"># our model</span></span><br><span class="line">        self.G = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># self._scale_pool = [1]</span></span><br><span class="line">        self._scale_pool = [<span class="number">0.985</span>, <span class="number">0.99</span>, <span class="number">0.995</span>, <span class="number">1.0</span>, <span class="number">1.005</span>, <span class="number">1.01</span>, <span class="number">1.015</span>]</span><br><span class="line"></span><br><span class="line">        self.padding = <span class="number">2.5</span>  <span class="comment"># extra area surrounding the target</span></span><br><span class="line">        self.output_sigma_factor = <span class="number">0.125</span>  <span class="comment"># bandwidth of gaussian target</span></span><br><span class="line">        self.lambdar = <span class="number">0.0001</span>  <span class="comment"># regularization</span></span><br><span class="line"></span><br><span class="line">        self.ishog = <span class="literal">False</span></span><br><span class="line">        winSize = (<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        blockSize = (<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        blockStride = (<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        cellSize = (<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        nbins = <span class="number">32</span></span><br><span class="line">        self.hog = cv2.HOGDescriptor(winSize, blockSize, blockStride, cellSize, nbins)</span><br><span class="line"></span><br><span class="line">        self._cos_win = np.hamming(self._tmpl_sz[<span class="number">0</span>]).reshape(self._tmpl_sz[<span class="number">0</span>], <span class="number">1</span>) @ \</span><br><span class="line">                        np.hamming(self._tmpl_sz[<span class="number">0</span>]).reshape(<span class="number">1</span>, self._tmpl_sz[<span class="number">0</span>])</span><br><span class="line">        self._cos_win = self._cos_win[..., np.newaxis]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">linear_correlation</span>(<span class="params">self, x1, x2</span>):</span></span><br><span class="line">        res = x1 * x2.conjugate()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createGaussianPeak</span>(<span class="params">self, sizey, sizex</span>):</span></span><br><span class="line">        syh, sxh = sizey / <span class="number">2</span>, sizex / <span class="number">2</span></span><br><span class="line">        output_sigma = np.sqrt(sizex * sizey) / self.padding * self.output_sigma_factor</span><br><span class="line">        mult = -<span class="number">0.5</span> / (output_sigma * output_sigma)</span><br><span class="line">        y, x = np.ogrid[<span class="number">0</span>:sizey, <span class="number">0</span>:sizex]</span><br><span class="line">        y, x = (y - syh) ** <span class="number">2</span>, (x - sxh) ** <span class="number">2</span></span><br><span class="line">        gaussian_res = np.exp(mult * (y + x))</span><br><span class="line">        <span class="keyword">return</span> np.fft.fft2(gaussian_res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subPixelPeak</span>(<span class="params">self, left, center, right</span>):</span></span><br><span class="line">        divisor = <span class="number">2</span> * center - right - left  <span class="comment"># float</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> <span class="keyword">if</span> <span class="built_in">abs</span>(divisor) &lt; <span class="number">1e-3</span> <span class="keyword">else</span> <span class="number">0.5</span> * (right - left) / divisor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFeatures</span>(<span class="params">self, image, roi, needed_size</span>):</span></span><br><span class="line">        roi = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, roi))  <span class="comment"># ensure that everything is int</span></span><br><span class="line">        z = subwindow(image, roi, cv2.BORDER_REPLICATE)  <span class="comment"># sample a image patch</span></span><br><span class="line">        <span class="keyword">if</span> z.shape[<span class="number">1</span>] != needed_size[<span class="number">0</span>] <span class="keyword">or</span> z.shape[<span class="number">0</span>] != needed_size[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> self.ishog:</span><br><span class="line">                z = cv2.resize(z, <span class="built_in">tuple</span>(needed_size * <span class="number">4</span>))  <span class="comment"># resize to template size</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                z = cv2.resize(z, <span class="built_in">tuple</span>(needed_size)) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.ishog:</span><br><span class="line">            FeaturesMap = self.hog.compute(z).reshape(needed_size[<span class="number">0</span>], needed_size[<span class="number">1</span>], -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># if z.ndim == 3 and z.shape[2] == 3:</span></span><br><span class="line">            <span class="comment">#    FeaturesMap = cv2.cvtColor(z, cv2.COLOR_BGR2GRAY)</span></span><br><span class="line">            <span class="comment"># elif z.ndim == 2:</span></span><br><span class="line">            FeaturesMap = z  <span class="comment"># (size_patch[0],size_patch[1]) #np.int8 #0~255</span></span><br><span class="line">            FeaturesMap = FeaturesMap.astype(np.float32) / <span class="number">255.0</span> - <span class="number">0.5</span></span><br><span class="line">        FeaturesMap = FeaturesMap * self._cos_win</span><br><span class="line">        <span class="keyword">return</span> FeaturesMap</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">track</span>(<span class="params">self, search_region, img</span>):</span> </span><br><span class="line">        global_max = <span class="number">0</span></span><br><span class="line">        global_loc = []</span><br><span class="line">        ind_s = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> it_s <span class="keyword">in</span> self._scale_pool:</span><br><span class="line">            search_region_s = <span class="built_in">list</span>(search_region)</span><br><span class="line">            search_region_s[<span class="number">2</span>] = search_region[<span class="number">2</span>] * it_s</span><br><span class="line">            search_region_s[<span class="number">3</span>] = search_region[<span class="number">3</span>] * it_s</span><br><span class="line">            search_region_s = <span class="built_in">map</span>(<span class="built_in">float</span>, search_region_s)</span><br><span class="line">            s_patch = self.getFeatures(img, search_region_s, self._tmpl_sz)  <span class="comment"># sample the search patch</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># patch=self.getFeatures(img,search_region,self._tmpl_sz)</span></span><br><span class="line">            F_new = np.fft.fft2(s_patch, axes=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            res = F_new * self._tmpl</span><br><span class="line">            res = np.fft.ifft2(res, axes=(<span class="number">0</span>, <span class="number">1</span>)).real</span><br><span class="line">            res = np.<span class="built_in">sum</span>(res, axis=<span class="number">2</span>)</span><br><span class="line">            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> max_val &gt; global_max:</span><br><span class="line">                global_max = max_val</span><br><span class="line">                global_loc = max_loc</span><br><span class="line">                ind_s = it_s</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> global_loc[<span class="number">0</span>], global_loc[<span class="number">1</span>], ind_s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_model</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        F_new = np.fft.fft2(x, axes=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        new_tmp = self.linear_correlation(self.G, F_new) / (self.linear_correlation(F_new, F_new) + self.lambdar)</span><br><span class="line">        self._tmpl = (<span class="number">1</span> - self._interp_factor) * self._tmpl + self._interp_factor * new_tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">self, roi, image</span>):</span></span><br><span class="line">        self._roi = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, roi))</span><br><span class="line">        <span class="keyword">assert</span> (roi[<span class="number">2</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> roi[<span class="number">3</span>] &gt; <span class="number">0</span>)</span><br><span class="line">        self.G = self.createGaussianPeak(self._tmpl_sz[<span class="number">0</span>], self._tmpl_sz[<span class="number">1</span>])</span><br><span class="line">        self.G = self.G[..., np.newaxis]</span><br><span class="line"></span><br><span class="line">        cx = self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">        cy = self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">        search_rect = [cx - self._roi[<span class="number">2</span>], cy - self._roi[<span class="number">3</span>], self._roi[<span class="number">2</span>] * <span class="number">2</span>, self._roi[<span class="number">3</span>] * <span class="number">2</span>]</span><br><span class="line">        f = self.getFeatures(image, search_rect, self._tmpl_sz)</span><br><span class="line">        F = np.fft.fft2(f, axes=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        self._tmpl = self.linear_correlation(self.G, F) / (self.linear_correlation(F, F) + self.lambdar)</span><br><span class="line">        <span class="built_in">print</span>(self._tmpl.shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, image</span>):</span></span><br><span class="line">        <span class="comment"># some check boundary here</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] &lt;= <span class="number">0</span>):  self._roi[<span class="number">0</span>] = -self._roi[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] &lt;= <span class="number">0</span>):  self._roi[<span class="number">1</span>] = -self._roi[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">0</span>] &gt;= image.shape[<span class="number">1</span>] - <span class="number">1</span>):  self._roi[<span class="number">0</span>] = image.shape[<span class="number">1</span>] - <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">1</span>] &gt;= image.shape[<span class="number">0</span>] - <span class="number">1</span>):  self._roi[<span class="number">1</span>] = image.shape[<span class="number">0</span>] - <span class="number">2</span></span><br><span class="line">        <span class="comment"># center position of our target</span></span><br><span class="line">        cx = self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">        cy = self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">        <span class="comment"># we double the searching region compared to the selected region</span></span><br><span class="line">        search_rect = [cx - self._roi[<span class="number">2</span>], cy - self._roi[<span class="number">3</span>], self._roi[<span class="number">2</span>] * <span class="number">2</span>, self._roi[<span class="number">3</span>] * <span class="number">2</span>]</span><br><span class="line">        <span class="comment"># the delta in search region</span></span><br><span class="line">        loc_pos = self.track(search_rect, image)</span><br><span class="line">        <span class="built_in">print</span>(loc_pos)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># delta_x and delta_y we want to estimate</span></span><br><span class="line">        delta = (np.array(loc_pos[:<span class="number">2</span>]) - self._tmpl_sz / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># scale between the search_roi and our template</span></span><br><span class="line">        scale = loc_pos[<span class="number">2</span>] * np.array(search_rect[<span class="number">2</span>:]).astype(<span class="built_in">float</span>) / (np.array(self._tmpl_sz) * <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># back to the original size</span></span><br><span class="line">        delta = delta * scale</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add the delta to original position</span></span><br><span class="line">        self._roi[<span class="number">0</span>] = self._roi[<span class="number">0</span>] + delta[<span class="number">0</span>]</span><br><span class="line">        self._roi[<span class="number">1</span>] = self._roi[<span class="number">1</span>] + delta[<span class="number">1</span>]</span><br><span class="line">        self._roi[<span class="number">2</span>] = self._roi[<span class="number">2</span>] * loc_pos[<span class="number">2</span>]</span><br><span class="line">        self._roi[<span class="number">3</span>] = self._roi[<span class="number">3</span>] * loc_pos[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># some check boundary here</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">0</span>] &gt;= image.shape[<span class="number">1</span>] - <span class="number">1</span>:  self._roi[<span class="number">0</span>] = image.shape[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">1</span>] &gt;= image.shape[<span class="number">0</span>] - <span class="number">1</span>:  self._roi[<span class="number">1</span>] = image.shape[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] &lt;= <span class="number">0</span>:  self._roi[<span class="number">0</span>] = -self._roi[<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] &lt;= <span class="number">0</span>:  self._roi[<span class="number">1</span>] = -self._roi[<span class="number">3</span>] + <span class="number">2</span></span><br><span class="line">        <span class="keyword">assert</span> (self._roi[<span class="number">2</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> self._roi[<span class="number">3</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        cx = cy = self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">        cy = self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">        search_rect = [cx - self._roi[<span class="number">2</span>], cy - self._roi[<span class="number">3</span>], self._roi[<span class="number">2</span>] * <span class="number">2</span>, self._roi[<span class="number">3</span>] * <span class="number">2</span>]</span><br><span class="line">        <span class="comment"># update the template</span></span><br><span class="line">        x = self.getFeatures(image, self._roi, self._tmpl_sz)  <span class="comment"># new observation</span></span><br><span class="line">        self.update_model(x)</span><br><span class="line">        <span class="keyword">return</span> self._roi</span><br></pre></td></tr></table></figure><h4 id="四、测试结果"><a href="#四、测试结果" class="headerlink" title="四、测试结果"></a>四、测试结果</h4><p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?bvid=BV1wf4y1Y7xk&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div></p><h4 id="五、结果分析"><a href="#五、结果分析" class="headerlink" title="五、结果分析"></a><strong>五、结果分析</strong></h4><p>对于运动速度较慢的物体追踪效果好，速度越快效果越差，遇到遮挡物会受到影响。</p><h4 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a><strong>六、参考资料</strong></h4><ul><li>MOSSE：<a href="https://www.cs.colostate.edu/~draper/papers/bolme_cvpr10.pdf">https://www.cs.colostate.edu/~draper/papers/bolme_cvpr10.pdf</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Correlation-Filter-based-tracker（相关滤波器）&quot;&gt;&lt;a href=&quot;#Correlation-Filter-based-tracker（相关滤波器）&quot; class=&quot;headerlink&quot; title=&quot;Correlation Fi</summary>
      
    
    
    
    <category term="Tracker" scheme="http://10185102110.github.io/categories/Tracker/"/>
    
    
    <category term="Tracker" scheme="http://10185102110.github.io/tags/Tracker/"/>
    
  </entry>
  
  <entry>
    <title>JDBC数据库操作</title>
    <link href="http://10185102110.github.io/2021/05/11/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    <id>http://10185102110.github.io/2021/05/11/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/</id>
    <published>2021-05-11T10:16:36.000Z</published>
    <updated>2021-08-28T04:48:40.293Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDBC连接数据库-Mysql"><a href="#JDBC连接数据库-Mysql" class="headerlink" title="JDBC连接数据库(Mysql)"></a>JDBC连接数据库(Mysql)</h4><ol><li><p>下载JDBC驱动包：mysql-connector-java-8.0.16.jar</p></li><li><p>右键java项目——&gt;Build Path——&gt;Add External Archives——&gt;选择1中文件</p></li><li>打开项目中的module-info.java文件，在括号中添加requires java.sql;</li></ol><p><img src="1.png" alt=""></p><ol><li>测试代码</li></ol><ul><li>select</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">             <span class="comment">//MySQL8.0以上版本 com.mysql.jdbc.Driver 更换为 com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;加载数据库驱动时抛出异常！&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/bank?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">             <span class="comment">//serverTimezone=UTC用来解决数据库和系统时区差异引起的问题</span></span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;select * from officer&quot;</span>;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String f,l;</span><br><span class="line">    <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">    id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    f = rs.getString(<span class="number">3</span>);</span><br><span class="line">    l = rs.getString(<span class="number">4</span>);</span><br><span class="line">    System.out.println(id+<span class="string">&quot; &quot;</span>+l+f);</span><br><span class="line">    &#125;</span><br><span class="line">    rs.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>insert</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;加载数据库驱动时抛出异常！&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/bank?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">    String sql = <span class="string">&quot;insert into customer(CUST_ID,ADDRESS,CITY,CUST_TYPE_CD,PROVICIAL_REGION,POSTAL_CODE)values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">    PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, <span class="string">&quot;14&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>, <span class="string">&quot;浙江省杭州市滨江区网商路599号网易大厦&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">3</span>, <span class="string">&quot;杭州市&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">4</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">5</span>, <span class="string">&quot;浙江省&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">6</span>, <span class="string">&quot;310052&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> temp = pstmt.executeUpdate();</span><br><span class="line">    <span class="keyword">if</span>(temp!=<span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录添加成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>update</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;加载数据库驱动时抛出异常！&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/bank?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;update customer set CUST_TYPE_CD=&#x27;B&#x27; where ADDRESS=&#x27;上海市南京西路11号1021室&#x27;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = stmt.executeUpdate(sql);</span><br><span class="line">    <span class="keyword">if</span>(temp!=<span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录修改成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录修改失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JDBC连接数据库(Mysql)</summary>
    
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
