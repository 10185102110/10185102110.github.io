<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生孰来</title>
  
  
  <link href="http://10185102110.github.io/atom.xml" rel="self"/>
  
  <link href="http://10185102110.github.io/"/>
  <updated>2021-10-29T16:47:04.645Z</updated>
  <id>http://10185102110.github.io/</id>
  
  <author>
    <name>Ave Bai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JMeter实践</title>
    <link href="http://10185102110.github.io/2021/10/26/JMeter%20%E5%AE%9E%E8%B7%B5/"/>
    <id>http://10185102110.github.io/2021/10/26/JMeter%20%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-10-26T12:06:36.000Z</published>
    <updated>2021-10-29T16:47:04.645Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JMeter-模拟-HTTP-请求"><a href="#JMeter-模拟-HTTP-请求" class="headerlink" title="JMeter 模拟 HTTP 请求"></a>JMeter 模拟 HTTP 请求</h1><h2 id="创建测试任务"><a href="#创建测试任务" class="headerlink" title="创建测试任务"></a>创建测试任务</h2><p>在 JMeter 中，任何类型的测试都需要先创建线程组，一个线程组可以看作一个测试任务。</p><p>（1）添加线程组。用鼠标右键单击“测试计划”，在快捷菜单中单击添加 -&gt; 线程(用户) -&gt; 线程组。</p><p>（2）设置线程组。线程组主要包括 3 个参数：</p><ul><li><p>线程数：一个线程代表一个虚拟用户。</p></li><li><p>Ramp-Up Period(in seconds)：设置线程的启动时长，单位为秒。如果线程数是 100，启动时长为 5s，那么需要 5s 启动 100 个线程，平均每秒启动 20 个线程。</p></li><li><p>循环次数：每个线程发送请求的次数。如果这个线程组中有 5 个HTTP请求，循环次数为 3 的话，那么一个线程会发送 5×3=15 个 HTTP 请求。如果选中了“永远”复选框，那么所有的线程会无限循环发送请求，直到手动单击工具栏上的停止按钮。</p></li></ul><p>如果用来做功能测试/接口测试，那么应保持默认设置。</p><p><img src="2.png" alt=""></p><h2 id="模拟网页-MD5-加密"><a href="#模拟网页-MD5-加密" class="headerlink" title="模拟网页 MD5 加密"></a>模拟网页 MD5 加密</h2><p>有一个 MD5 在线网站 <a href="http://www.md5.cz/，利用它可以对密码进行散列处理。用">http://www.md5.cz/，利用它可以对密码进行散列处理。用</a> Fiddler 对这个网站进行抓包，然后用 JMeter 来实现。具体的操作步骤如下。</p><p>（1）启动 Fiddler，打开浏览器，输入 <a href="http://ww.md5.cz/，在页面中输入“password”，然后单击按钮“hash">http://ww.md5.cz/，在页面中输入“password”，然后单击按钮“hash</a> darling, hash!”。</p><p><img src="0.png" alt=""></p><p><img src="1.png" alt=""></p><p>能看到浏览器发出的 HTTP 请求报文如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">http://www.md5.cz/getmd5.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.md5.cz</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>13</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 Edg/95.0.1020.30</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://www.md5.cz</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://www.md5.cz/</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>_ga=GA1.2.1991138354.1635224796; _gid=GA1.2.478924991.1635224796</span><br><span class="line"></span><br><span class="line"><span class="ini"><span class="attr">what</span>=password</span></span><br></pre></td></tr></table></figure><p>（2）打开 JMeter，右击线程组-&gt;添加-&gt;取样器-&gt;HTTP 请求，参数按照报文填写：</p><p><img src="3.png" alt=""></p><p>（3）右击 HTTP请求-&gt;添加-&gt;配置元件-&gt;HTTP信息头管理器，添加 HTTP Header。可以先在 Fiddler 中复制所有的 HTTP Header，然后单击“从剪贴板添加”。由于 JMeter 自动添加 Host，所以不需要手动添加，如果有则需要删除。</p><p><img src="4.png" alt=""></p><p>（4）右击线程组-&gt;添加-&gt;监听器-&gt;察看结果树。运行JMeter，单击工具栏上的绿色按钮，可以运行脚本。通过结果树可以看到我们发出的 HTTP请求以及 Web 服务器返回的 HTTP 响应。</p><p><img src="5.png" alt=""></p><h1 id="JMeter-天气接口自动化测试"><a href="#JMeter-天气接口自动化测试" class="headerlink" title="JMeter 天气接口自动化测试"></a>JMeter 天气接口自动化测试</h1><h2 id="Fiddler-抓包分析"><a href="#Fiddler-抓包分析" class="headerlink" title="Fiddler 抓包分析"></a>Fiddler 抓包分析</h2><p>（1）启动 Fiddler，单击菜单栏中 Rules -&gt; Hide Image Requests。抓包的时候把图片的包隐藏。</p><p>（2）打开浏览器，打开 <a href="http://www.weather.com.cn/。在“城市名称”中输入“上海”，单击查询。">http://www.weather.com.cn/。在“城市名称”中输入“上海”，单击查询。</a></p><p>（3）抓到几十个包，但分析下来主要有两步操作：</p><ul><li><p>​    获取城市代码。发送一个 GET 请求到 <a href="http://toy1.weather.com.cn/search?cityname=%E4%B8%8A%E6%B5%B7&amp;callback=success_jsonpCallback&amp;_=1635227081722">http://toy1.weather.com.cn/search?cityname=%E4%B8%8A%E6%B5%B7&amp;callback=success_jsonpCallback&amp;_=1635227081722</a> ，“上海”被 URLEncode 后变成了 “%E4%B8%8A%E6%B5%B7”，从这个响应中可以得到上海的地区代码。</p><p><img src="6.png" alt=""></p></li><li><p>获取城市的天气数据。发送一个 GET 请求到 <a href="http://www.weather.com.cn/weather1d/101020100.shtml">http://www.weather.com.cn/weather1d/101020100.shtml</a> 得到该城市的天气数据。</p><p><img src="7.png" alt=""></p></li></ul><p>这两个请求必须带上一个叫“Referer”的 Header，Referer 的作用就是用来追踪来源的。</p><h2 id="JMeter-实现参数化"><a href="#JMeter-实现参数化" class="headerlink" title="JMeter 实现参数化"></a>JMeter 实现参数化</h2><p>（1）启动JMeter，在线程组下面新建一个 HTTP 请求，将其命名为 GetCityCode。发送一个Get方法的HTTP请求到 <a href="http://toy1.weather.com.cn/search?cityname=上海。添加一个HTTP信息头管理器，添加一个">http://toy1.weather.com.cn/search?cityname=上海。添加一个HTTP信息头管理器，添加一个</a> Referer：</p><p><img src="8.png" alt=""></p><p>（2）添加验证点。选择 GetCityCode 这个 HTTP 请求，右击-&gt;添加-&gt;断言-&gt;响应断言。右击线程组-&gt;添加-&gt;监听器-&gt;断言结果。匹配结果会显示到断言结果中，成功则只显示 HTTP 请求名称，失败则显示 HTTP 名称和没有匹配到的第一项。</p><p><img src="9.png" alt=""></p><p>（3）使用用户自定义变量。右击线程组-&gt;添加-&gt;配置元件-&gt;用户定义的变量。添加一个变量 city，其值设为“上海”。</p><p><img src="10.png" alt=""></p><p>在 GetCityCode 中使用这个变量：</p><p><img src="11.png" alt=""></p><p>这样就实现了参数化，以后修改城市的时候，只要修改用户自定义变量就可以。</p><h2 id="正则表达式提取城市地区代码"><a href="#正则表达式提取城市地区代码" class="headerlink" title="正则表达式提取城市地区代码"></a>正则表达式提取城市地区代码</h2><p>（1）选择 GetCityCode 这个 HTTP 请求，用鼠标右键选择添加-&gt;后置处理器-&gt;正则表达式提取器。</p><p><img src="12.png" alt=""></p><p>通过正则表达式提取器把城市代码提取出来，并且存到变量 citycode，然后把这个变量提供给第二个 HTTP 请求使用。</p><p>关联：一个 HTTP 请求使用了另一个 HTTP 请求中的数据，两个请求之间发生了关联。</p><p>（2）新建第二个 HTTP 请求，命名为 GetWeather。发送一个 GET 请求到 <a href="http://www.weather">http://www.weather</a>. com.cn/weather1d/${citycode}.shtml。运行结果如下：</p><p><img src="13.png" alt=""></p><p>到这里天气接口的简单自动化测试就完成了。</p><h1 id="BeanShell"><a href="#BeanShell" class="headerlink" title="BeanShell"></a>BeanShell</h1><p>BeanShell 是一个小型的 Java 源代码解释器，具有对象脚本语言特性。其能够动态执行标准 Java 语法，可以通过脚本来处理 Java 应用程序。</p><p>BeanShell 使用内置对象 vars 对变量进行存取操作。</p><ul><li><code>vars.get(&quot;name&quot;)</code>：从 JMeter 中获得变量值。</li><li><code>vars.put(&quot;key&quot;，&quot;value&quot;)</code>：数据存到 JMeter 变量中。</li></ul><p><strong>实例：BeanShell 调用自己写的 jar 包进行 MD5 加密</strong></p><p>（1）在 Eclipse 新建工程，添加一个 class 文件，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> md5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">md5</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMd5</span><span class="params">(String plainText)</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>); </span><br><span class="line">            md.update(plainText.getBytes()); </span><br><span class="line">            <span class="keyword">byte</span> b[] = md.digest(); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i; </span><br><span class="line"></span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>); </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; b.length; offset++) &#123; </span><br><span class="line">                i = b[offset]; </span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>) </span><br><span class="line">                i += <span class="number">256</span>; </span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">16</span>) </span><br><span class="line">                        buf.append(<span class="string">&quot;0&quot;</span>); </span><br><span class="line">                    buf.append(Integer.toHexString(i)); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">//32位加密 </span></span><br><span class="line">                <span class="keyword">return</span> buf.toString(); </span><br><span class="line">                <span class="comment">// 16位的加密 </span></span><br><span class="line">                <span class="comment">//return buf.toString().substring(8, 24); </span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将工程导出为一个 jar 文件，取名为 md5.jar。</p><p>（2）启动 JMeter，在测试计划中引入这个 jar 包。</p><p><img src="14.png" alt=""></p><p>（3）在线程组中添加一个 BeanShell 取样器、一个调试取样器和一个查看结果树。</p><p><img src="15.png" alt=""></p><p><img src="16.png" alt=""></p><p>调试取样器中查看变量，可以看到密码被加密。</p><h1 id="自动登录禅道"><a href="#自动登录禅道" class="headerlink" title="自动登录禅道"></a>自动登录禅道</h1><h2 id="HTTP-Cookie-管理器"><a href="#HTTP-Cookie-管理器" class="headerlink" title="HTTP Cookie 管理器"></a>HTTP Cookie 管理器</h2><p>HTTP 协议本身是无状态的，为了维持登录的状态引入 Cookie 机制。</p><p>Cookie 的流程如下：<br>（1）浏览器发送第一个 HTTP 请求给 Web 服务器，里面包含用户名和密码。Web 服务器验证用户名和密码后，把登录相关的 Cookie 发送给浏览器客户端。<br>（2）浏览器客户端再一次访问的时候，会带上 Cookie，这样才处于登录状态，否则会被服务器跳转到登录页面。</p><p>用 JMeter 来模拟整个登录过程，需要在第一次登录后，用正则表达式提取器把登录相关的 Cookie 提取出来，然后把登录的 Cookie 插入后续的 HTTP 请求中形成关联。</p><p>JMeter 中的 HTTP Cookie 管理器可以自动管理 Cookie。如果 HTTP 响应中包含 Cookie，那么 HTTP Cookie 管理器会自动保存这些 Cookie。用户再次访问该站点时，HTTP 请求会自动使用这些 Cookie。一个线程组有自己存储 Cookie 的区域，并且一个线程组只能添加一个 HTTP Cookie 管理器。</p><p>选择线程组，用鼠标右键单击添加-&gt;配置元件-&gt;HTTP Cookie 管理器。</p><h2 id="自动登录禅道-1"><a href="#自动登录禅道-1" class="headerlink" title="自动登录禅道"></a>自动登录禅道</h2><p>（1）启动 Fiddler，启动过滤。在 Filter 选项卡中激活 Filter，并且在 Response Type and size 中选中“Show only HTML”。</p><p>（2）打开浏览器，输入 <a href="http://127.0.0.1:80/index.php（我部署的禅道地址），然后输入用户名和密码，单击“登录”。">http://127.0.0.1:80/index.php（我部署的禅道地址），然后输入用户名和密码，单击“登录”。</a></p><p>（3）从抓包可以看到，首先用 GET 方法得到一个数字（就是 verifyRand），然后用 POST 方法登录，但是密码是加密后发送给服务器的，Body 中的数据是 account=admin&amp;password=372539499122ad0a7085743c6c322bc8&amp;passwordStrength=1&amp;referer=%2Fzentao%2F&amp;verifyRand=527812645&amp;keepLogin=0&amp;captcha=。</p><p><img src="17.png" alt=""></p><p><img src="18.png" alt=""></p><p>（4）用浏览器的开发工具查看源代码，可以发现一个叫 md5 的 js 包。</p><p><img src="19.png" alt=""></p><p>查看登录页面的源代码发现加密规则是 <code>md5(md5(password) + rand)</code>，rand 就是上面说的 verifyRand，每次登录请求都会刷新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#loginPanel #submit&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> account          = $(<span class="string">&#x27;#account&#x27;</span>).val().trim();</span><br><span class="line">    <span class="keyword">var</span> password         = $(<span class="string">&#x27;input:password&#x27;</span>).val().trim();</span><br><span class="line">    <span class="keyword">var</span> passwordStrength = computePasswordStrength(password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hasMD5    = <span class="keyword">typeof</span>(md5) == <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> referer   = $(<span class="string">&#x27;#referer&#x27;</span>).val();</span><br><span class="line">    <span class="keyword">var</span> link      = createLink(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;login&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> keepLogin = $(<span class="string">&#x27;#keepLoginon&#x27;</span>).attr(<span class="string">&#x27;checked&#x27;</span>) == <span class="string">&#x27;checked&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> captcha   = $(<span class="string">&#x27;#captcha&#x27;</span>).length == <span class="number">1</span> ? $(<span class="string">&#x27;#captcha&#x27;</span>).val() : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    $.get(createLink(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;refreshRandom&#x27;</span>), <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rand = data;</span><br><span class="line">        $.ajax</span><br><span class="line">        (&#123;</span><br><span class="line">            <span class="attr">url</span>: link,</span><br><span class="line">            <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;account&quot;</span>: account, </span><br><span class="line">                <span class="string">&quot;password&quot;</span>: hasMD5 ? md5(md5(password) + rand) : password,</span><br><span class="line">                <span class="string">&#x27;passwordStrength&#x27;</span> : passwordStrength,</span><br><span class="line">                <span class="string">&#x27;referer&#x27;</span> : referer,</span><br><span class="line">                <span class="string">&#x27;verifyRand&#x27;</span> : rand,</span><br><span class="line">                <span class="string">&#x27;keepLogin&#x27;</span> : keepLogin,</span><br><span class="line">                <span class="string">&#x27;captcha&#x27;</span> : captcha</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(data.result == <span class="string">&#x27;fail&#x27;</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    alert(data.message);</span><br><span class="line">                    <span class="keyword">if</span>($(<span class="string">&#x27;.captchaBox&#x27;</span>).length == <span class="number">1</span>) $(<span class="string">&#x27;.captchaBox .input-group .input-group-addon img&#x27;</span>).click();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                location.href = data.locate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（5）重新写一个 jar 包实现禅道的加密，在测试计划中引入这个 jar 包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> md5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">md5</span> </span>&#123;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String key,String rand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> md5(md5(key) + rand);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//md5加密算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String plainText)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            md.update(plainText.getBytes());</span><br><span class="line">            <span class="keyword">byte</span> b[] = md.digest();</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; b.length; offset++) &#123;</span><br><span class="line">                i = b[offset];</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">                    i += <span class="number">256</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">16</span>)</span><br><span class="line">                    buf.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                buf.append(Integer.toHexString(i));</span><br><span class="line">            &#125;</span><br><span class="line">            result = buf.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）选择线程组，添加一个 HTTP Cookie 管理器，用来自动管理Cookie。</p><p>（7）选择线程组，添加一个 HTTP 请求默认值，填写的内容如图：</p><p><img src="20.png" alt=""></p><p>（8）选择线程组，添加用户自定义的变量。</p><p><img src="21.png" alt=""></p><p>（9）选择线程组，添加一个 HTTP 请求，命名为 Getverify，用来获取随机生成的 verifyRand，</p><p>GET <a href="http://127.0.0.1/zentao/user-refreshRandom.html。在这个请求下添加一个">http://127.0.0.1/zentao/user-refreshRandom.html。在这个请求下添加一个</a> HTTP 信息头管理器和一个 JSON 提取器。</p><p><img src="22.png" alt=""></p><p>（10）选择线程组，添加一个 BeanShell 取样器和一个调试取样器。</p><p><img src="23.png" alt=""></p><p>（11）选择线程组，添加一个 HTTP 请求，命名为 Login，用来登录禅道。添加一个 HTTP 信息头管理器，不填 Host 和 Cookie。</p><p><img src="24.png" alt=""></p><p>（12）添加一个察看结果树，运行就可以看到成功登录了。</p><p><img src="25.png" alt=""></p><h1 id="JMeter-给网站做压力测试"><a href="#JMeter-给网站做压力测试" class="headerlink" title="JMeter 给网站做压力测试"></a>JMeter 给网站做压力测试</h1><p>在一台电脑用 JMeter 模拟 200 个用户，同时去使用 bing 搜索不同的关键字， 查看页面返回的时间是否在正常范围内。</p><p>（1）首先把测试需要用到的 2 个参数放在 txt 文件中，新建一个 data.txt 文件，输入些数据， 一行有两个数据，用逗号分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">百度百科,苹果</span><br><span class="line">百度百科,西瓜</span><br><span class="line">百度百科,香蕉</span><br><span class="line">百度百科,菠萝</span><br><span class="line">百度百科,杨梅</span><br></pre></td></tr></table></figure><p>（2）启动 JMeter，先添加一个线程组，然后右击添加-&gt;配置元件-&gt;CSV数据文件设置。</p><p><img src="26.png" alt=""></p><p>（3）添加 HTTP 请求，发送 GET 到 <a href="http://cn.bing.com/search?q=testteststtssdfds">http://cn.bing.com/search?q=</a>百度百科+水果名称。</p><p><img src="27.png" alt=""></p><p>（3）选中线程组，修改配置。</p><p><img src="28.png" alt=""></p><p>Ramp-Up 时间(秒):：设置线程需要多长时间全部启动。如果线程数为 200 ，准备时长为 10 ，那么需要每秒钟启动 20 个线程。</p><p>循环次数：每个线程发送请求的次数。如果线程数为 200 ，循环次数为 10 ，那么每个线程发送 10 次请求。总请求数为 200*10=2000 。</p><p>（4）添加汇总报告，运行并查看报告。</p><p><img src="29.png" alt=""></p><ul><li>异常%：本次测试中出现错误请求的数量。正常情况下应该是 0.00%。否则就是功能出现了问题。也就是当大量用户访问的时候，造成了功能失败的问题，这个问题很严重。</li><li>平均值：平均响应时间，单位是 ms。对于一个 HTTP 请求来说，响应时间应该在 200ms 之内，但是图中的平均响应时间是 8007ms，说明性能非常差。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;JMeter-模拟-HTTP-请求&quot;&gt;&lt;a href=&quot;#JMeter-模拟-HTTP-请求&quot; class=&quot;headerlink&quot; title=&quot;JMeter 模拟 HTTP 请求&quot;&gt;&lt;/a&gt;JMeter 模拟 HTTP 请求&lt;/h1&gt;</summary>
      
    
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Fiddler抓包</title>
    <link href="http://10185102110.github.io/2021/10/20/fiddler%E6%8A%93%E5%8C%85/"/>
    <id>http://10185102110.github.io/2021/10/20/fiddler%E6%8A%93%E5%8C%85/</id>
    <published>2021-10-20T12:06:36.000Z</published>
    <updated>2021-10-29T07:25:53.579Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基本界面"><a href="#基本界面" class="headerlink" title="基本界面"></a>基本界面</h1><p><img src="D:\blog\source\_posts\fiddler抓包\0.png" alt="0"></p><p>左半边是 Web Sessions 列表（会话列表），显示捕捉到的每个 Session 的简短信息。</p><p>下面的一行黑框是 QuickExec（命令行工具），可以输入简单的命令，例如输入 cls 可以清空 Web Sessions。</p><p>右半边是 Inspectors 选项卡（功能面板），上面是 HTTP 请求报文，下面是 HTTP 响应报文。其中 Raw 选项卡可以查看完整的消息，Headers 选项卡只查看消息中的 Header。</p><p>Web Sessions 列表栏中包含的信息如下：</p><div class="table-container"><table><thead><tr><th>#</th><th>Result</th><th>Protocol</th><th>Host</th><th>URL</th><th>Body</th><th>Caching</th><th>Content-Type</th><th>Process</th></tr></thead><tbody><tr><td>Fiddler 生成的 ID</td><td>响应的状态码</td><td>使用的协议：HTTP/HTTPS</td><td>服务器的主机名和端口号</td><td>路径</td><td>响应中包含的字节数</td><td>跟缓存相关的字段的值</td><td>响应中 Content-Type 的值</td><td>对应本地 zhuabao</td></tr></tbody></table></div><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Fiddler 是以代理 Web 服务器的形式工作的，它使用代理地址：127.0.0.1，端口：8888。</p><p>Fiddler 启动的时候，会偷偷地把 Internet 选项中的代理修改为 127.0.0.1，端口：8888。当 Fiddler 退出的时候，它会自动在 Internet 选项中取消代理，这样就不会影响别的程序。如果 Fiddler 非正常退出，这时候因为 Fiddler 没有自动注销，会造成网页无法访问，解决办法是重新启动 Fiddler。</p><h1 id="捕获-HTTP-HTTPS-协议的数据包"><a href="#捕获-HTTP-HTTPS-协议的数据包" class="headerlink" title="捕获 HTTP/HTTPS 协议的数据包"></a>捕获 HTTP/HTTPS 协议的数据包</h1><p>（1）启动 Fiddler，打开任何一个浏览器，输入 <a href="https://avebai.gitee.io/">https://avebai.gitee.io/</a>。</p><p>（2）回到 Fiddler 界面，在 Session 列表中，会看到 Fiddler 已经捕获到了很多 Session。可以选择任何一个 Session，然后选择 Inspectors 选项卡，就可以查看详细内容。</p><p>单击 Fiddler 左下角的 “Capturing” 按钮可以设置开始抓包或者停止抓包。</p><h2 id="HTTP-协议报文结构"><a href="#HTTP-协议报文结构" class="headerlink" title="HTTP 协议报文结构"></a>HTTP 协议报文结构</h2><p>HTTP 报文分 2 个：一个是 HTTP 请求报文，一个是 HTTP 响应报文。</p><p>（1）HTTP 请求报文的结构</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//起始行（Request line）</span><br><span class="line"><span class="keyword">GET</span> <span class="string">https://avebai.gitee.io/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">//首部（Request Header）</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>avebai.gitee.io    </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">sec-ch-ua</span><span class="punctuation">: </span>&quot;Microsoft Edge&quot;;v=&quot;95&quot;, &quot;Chromium&quot;;v=&quot;95&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;</span><br><span class="line"><span class="attribute">sec-ch-ua-mobile</span><span class="punctuation">: </span>?0</span><br><span class="line"><span class="attribute">sec-ch-ua-platform</span><span class="punctuation">: </span>&quot;Windows&quot;</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.54 Safari/537.36 Edg/95.0.1020.30  </span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9     </span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>none</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>navigate</span><br><span class="line"><span class="attribute">Sec-Fetch-User</span><span class="punctuation">: </span>?1</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>document</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br  </span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6  </span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>Hm_lvt_211d055ab9f6b88805047adca6ce783d=1633064099,1634716265,1634914872,1635040194; Hm_lpvt_211d055ab9f6b88805047adca6ce783d=1635040543</span><br><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>W/&quot;6172d18e-a294&quot;</span><br><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Fri, 22 Oct 2021 14:58:22 GMT</span><br><span class="line">回车符+换行符</span><br><span class="line">//主体（Body）</span><br></pre></td></tr></table></figure><p>HTTP 请求报文分为 3 部分。其中首部第一行表示请求方法（POST/GET）+URI（不是URL）+协议版本，如果是 GET 就没有主体。</p><p>（2）HTTP 响应报文的结构</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//起始行（Response line）</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line">//首部（Response Header）</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sun, 24 Oct 2021 02:07:42 GMT</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>openresty</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Fri, 22 Oct 2021 14:58:22 GMT</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;6172d18e-a294&quot;</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Mon, 25 Oct 2021 02:07:42 GMT</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=86400</span><br><span class="line">回车符+换行符</span><br><span class="line">//主体（Body）</span><br></pre></td></tr></table></figure><p>Response 消息的结构和 Request 消息的结构基本一样。</p><p>起始行包括协议版本+状态码+状态码信息。</p><div class="table-container"><table><thead><tr><th>状态码</th><th>描述</th></tr></thead><tbody><tr><td>1XX</td><td>信息提示，表示请求已被成功接收，继续处理</td></tr><tr><td>2XX</td><td>成功，表示请求已被成功接收</td></tr><tr><td>3XX</td><td>重定向，必须进一步处理</td></tr><tr><td>4XX</td><td>客户端错误，请求有语法错误或请求无法实现</td></tr><tr><td>5XX</td><td>服务器错误，服务器未能实现合法的请求</td></tr></tbody></table></div><p>常见的状态码：</p><ul><li>200：OK，服务器成功处理了请求。</li><li>204：No Content，没有内容。</li><li>206：Partial Content，部分内容。</li><li>301/302：Moved Permanently，请求的 URL 已移走。</li><li>304：Not Modified，上次的文档已被缓存且是最新的，可以继续使用。</li><li>400：Bad Request，客户端请求有语法错误。</li><li>403：Forbidden，拒绝访问。</li><li>404：Not Found，未找到资源。</li><li>401：Unauthorized，未授权错误禁止访问。</li><li>501：Internal Server Error，服务器内部错误。</li><li>503：Server Unavailable，服务器暂时不可用。</li></ul><p>（3）URL</p><p>URL 的全称是Uniform Resource Locator，中文译名为“统一资源定位符”，用于完整地描述 Internet 上某一处资源的地址。<br>URI 的全称是 Uniform Resource Identifier，中文译名为“统一资源标识符”，用来唯一地标识一个资源。而 URL 是一种具体的 URI。</p><p>URL 的基本格式：协议+域名+资源路径+参数+锚</p><p>协议一般为 http、https、ftp 等；锚以 ‘#’ 开头。</p><p>参数可以通过 fiddler 中的 WebForms 查看。</p><p>锚是页面内部的超链接，可以快速到达本页内响应的位置。</p><p>（4）HTTP 请求方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息并返回实体主体。</td></tr><tr><td>HEAD</td><td>类似 GET，但返回的响应中没有具体内容，用于获取报文头部。</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理，数据被包含在请求体中。可能导致新资源的建立或对已有资源的修改。</td></tr><tr><td>PUT</td><td>向服务器传送数据。</td></tr><tr><td>DELETE</td><td>请求服务器删除指定页面。</td></tr></tbody></table></div><p>GET 和 POST 的区别：</p><ul><li>GET 提交的数据会放在 URL 之后，以 ‘？’ 分割 URL 和传输的数据，参数之间以 ‘&amp;’ 相连。POST 方法是把提交的数据放在 HTTP 包的 Body 中。</li><li>GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据大小没有限制。</li><li>GET 方式提交数据会带来安全问题，比如一个登录页面通过 GET 方式提交数据时，用户名和密码将出现在 URL 上。</li></ul><p>（5）Header</p><div class="table-container"><table><thead><tr><th>Header 字段</th><th>描述</th></tr></thead><tbody><tr><td>Cookie</td><td></td></tr><tr><td>Accept</td><td>表示浏览器可以接受的媒体类型。</td></tr><tr><td>Accept-Encoding</td><td>表示浏览器支持的压缩方式。</td></tr><tr><td>Accept-Language</td><td>表示浏览器支持的语言。</td></tr><tr><td>User-Agent</td><td>告诉服务器，浏览器客户端的相关信息，可以修改它伪装成任何客户端</td></tr><tr><td>Referer</td><td>用来让服务器判断用户的来源页面</td></tr><tr><td>Connection</td><td>表示 TCP 连接信息</td></tr><tr><td>Host</td><td>指定被请求的主机和端口号</td></tr><tr><td></td></tr></tbody></table></div><h2 id="设置断点拦截-HTTP-请求"><a href="#设置断点拦截-HTTP-请求" class="headerlink" title="设置断点拦截 HTTP 请求"></a>设置断点拦截 HTTP 请求</h2><p>一、全局断点</p><p>（1）启动 Fiddler，在菜单栏中单击 Rules -&gt; Automatic Breakpoint -&gt; Before Requests。</p><p>（2）打开浏览器，输入“www.baidu.com”，这时任务栏上的 Fiddler 图标闪烁，说明 Fiddler 拦截住了 HTTP 请求。</p><p>（3）在菜单栏中单击 Rules-&gt; Automatic Breakpoint-&gt;Disable（因为已经拦截住想要的 HTTP 请求了，其他 HTTP 请求就不需要拦截了）。</p><p>（4）选中需要修改的 HTTP 请求，选中 “Inspectors” 面板，可以使用 Raw 选项卡修改请求文件。</p><p>（5）单击绿色的 “Run to Completion” 按钮放行。</p><p>二、单个断点</p><p>命令行输入：bpm www.baidu.cm（拦截 www.baidu.com 请求）</p><p>输入命令：bpu （解除拦截）</p><h2 id="设置断点修改-HTTP-响应"><a href="#设置断点修改-HTTP-响应" class="headerlink" title="设置断点修改 HTTP 响应"></a>设置断点修改 HTTP 响应</h2><p>一、全局断点</p><p>（1）启动 Fiddler，在菜单栏中单击 Rules -&gt; Automatic Breakpoint -&gt; After Response。</p><p>（2）打开浏览器，输入“www.baidu.com”，这时任务栏上的 Fiddler 图标闪烁，说明 Fiddler 拦截住了 HTTP 请求。</p><p>（3）在菜单栏中单击 Rules-&gt; Automatic Breakpoint-&gt;Disable（因为已经拦截住想要的 HTTP 请求了，其他 HTTP 请求就不需要拦截了）。</p><p>（4）选中需要修改的 HTTP 请求，选中 “Inspectors” 面板，可以使用 Raw 选项卡修改响应文件。</p><p>（5）单击绿色的 “Run to Completion” 按钮放行。</p><p>二、单个断点</p><p>命令行输入：bpafter www.baidu.com（拦截 www.baidu.com 响应）</p><p>输入命令：bpafter （解除拦截）</p><h1 id="手机抓包"><a href="#手机抓包" class="headerlink" title="手机抓包"></a>手机抓包</h1><p>（1）启动 Fiddler，单击菜单栏中 Tools-&gt;Options-&gt;Connections，选中“Allow remote computers to connect”，Fiddler 的默认端口号是 8888。</p><p>（2）以小米 10 为例，打开手机中的设置-&gt;WLAN，找到手机当前连接的 WiFi，修改代理服务器，服务器主机名为 Fiddler 所在电脑的 IP 地址，服务器端口为 8888，如下图所示：</p><p><img src="D:\blog\source\_posts\fiddler抓包\2.jpg" alt="2"></p><p>在 Fiddler 中，将鼠标放在右上方的“online”图标上能看到主机 IP 地址。</p><p>（3）现在在手机上打开网址或者应用就能在 Fiddler 中捕获手机发出的 HTTP 包，可以设置过滤条件，如下：</p><p><img src="D:\blog\source\_posts\fiddler抓包\3.png" alt="3"></p><p>（4）要捕获 HTTPS 包就要在手机上安装证书。打开手机浏览器，输入 <a href="http://192.168.1.101:8888">http://192.168.1.101:8888</a> ，点击图中蓝色字段下载证书，点击证书文件进行安装即可。</p><p><img src="D:\blog\source\_posts\fiddler抓包\1.jpg" alt="1"></p><p>（5）点击设置-&gt;系统安全-&gt;信任的凭证-&gt;用户 可以看到安装的证书，点击删除即可卸载。</p><p><img src="D:\blog\source\_posts\fiddler抓包\4.jpg" alt="4"></p><h1 id="Fiddler-发送-HTTP-HTTPS-请求"><a href="#Fiddler-发送-HTTP-HTTPS-请求" class="headerlink" title="Fiddler 发送 HTTP/HTTPS 请求"></a>Fiddler 发送 HTTP/HTTPS 请求</h1><p>功能组件 Composer 可以用来发送 HTTP/HTTPS 请求。</p><p><img src="D:\blog\source\_posts\fiddler抓包\5.png" alt="5"></p><p>Composer 有两种编辑模式：</p><ul><li>Parsed模式。这个模式比较常用，把请求分为 3 个部分：请求起始行、请求 Header 和请求 Body。</li><li>Raw模式。该模式需要一行一行地写一个请求。</li></ul><p>也可以把会话列表中的 HTTP/HTTPS 请求拖拽到 Composer 中编辑后再发送出去。</p><h2 id="Replay-菜单"><a href="#Replay-菜单" class="headerlink" title="Replay 菜单"></a>Replay 菜单</h2><p>在会话列表中，选中一个或者多个 Session，右键-&gt;Replay，可以看到一个菜单，详细说明如下：</p><div class="table-container"><table><thead><tr><th>Reissue Requests</th><th>重复发送请求</th></tr></thead><tbody><tr><td>Reissue Unconditionally</td><td>无条件反复发送选中的请求</td></tr><tr><td>Reissue and Edit</td><td>把选中的请求以原来的形式重新发送。在每个Session中设置断点，可以在发送给服务器之前修改请求</td></tr><tr><td>Reissue and Verify</td><td>重新发送请求，检查响应，如果和上一个请求一样就变成绿色</td></tr><tr><td>Reissue Sequentially</td><td>选中多个Session会按顺序重新发送请求，单线程</td></tr><tr><td>Reissue from Composer</td><td>在Composer中编辑该请求</td></tr><tr><td>Revisit in IE</td><td>在IE浏览器中用Get方法访问该请求</td></tr></tbody></table></div><h2 id="简单的性能测试"><a href="#简单的性能测试" class="headerlink" title="简单的性能测试"></a>简单的性能测试</h2><p>在 Web Sessions 列表中，选中一个或者多个 Session，然后按下 Shift 键的同时单击“Replay”按钮，会弹出提示框，要求指定每个请求被重新发送的次数。Fiddler 会用多线程同时发送该请求，相当于模拟了很多用户同时访问该请求。</p><p><img src="D:\blog\source\_posts\fiddler抓包\6.png" alt="6"></p><h2 id="安全测试之重放攻击"><a href="#安全测试之重放攻击" class="headerlink" title="安全测试之重放攻击"></a>安全测试之重放攻击</h2><p>重放攻击（Replay Attacks），指黑客通过抓包的方式，得到客户端的请求数据及请求连接，重复地向服务器发送请求的行为。</p><p>重放攻击的危害很大，比如下单、投票、点赞等功能，攻击者可以对用户的请求进行抓包，然后重复发送来进行刷单、刷票等操作。</p><p><strong>如何防止重放攻击？</strong></p><p>在 HTTP/HTTPS 请求中添加时间戳（stamp）和数字签名（sign），可以防止重放攻击。也就是说每次发送请求时需要多传两个参数，分别为 stamp 和 sign。数字签名使用对称加密，保证请求的有效性；时间戳保证请求的时效性。</p><h1 id="Fiddler-实现弱网测试"><a href="#Fiddler-实现弱网测试" class="headerlink" title="Fiddler 实现弱网测试"></a>Fiddler 实现弱网测试</h1><p>Fiddler 是通过延迟发送或接收数据的时间来模拟限速的。</p><p>需要模拟出以下 3 种弱网场景：<br>（1）网络慢或延迟，导致加载时间长。<br>（2）网络中断，Web 服务器返回 500 等状态码。<br>（3）网络超时，HTTP/HTTPS 请求发出去后，很久都没有响应。</p><h2 id="精确控制网速"><a href="#精确控制网速" class="headerlink" title="精确控制网速"></a>精确控制网速</h2><p>（1）启动 Fiddler，选择 Rules -&gt; Performances -&gt; Simulate Modem Speeds，此时打开一个网页可以感觉到明显变慢。</p><p>（2）点击菜单 Rules-&gt;Customize Rules，在 FiddlerScript 中找到如下一段代码（ctrl+F 快速查找）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (m_SimulateModem) &#123;</span><br><span class="line">// Delay sends by 300ms per KB uploaded.每上传1kb数据，延时0.3秒</span><br><span class="line">oSession[&quot;request-trickle-delay&quot;] = &quot;300&quot;; </span><br><span class="line">    // Delay receives by 150ms per KB downloaded.每下载1kb数据，延时0.15秒</span><br><span class="line">    oSession[&quot;response-trickle-delay&quot;] = &quot;150&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以修改数值以精确控制网速。</p><p>网络取值的算法就是 1000/下载速度 = 需要延迟的时间（ms），比如 50kbit/s 需要延迟 200ms 来接收数据。</p><h2 id="模拟网络中断"><a href="#模拟网络中断" class="headerlink" title="模拟网络中断"></a>模拟网络中断</h2><p>用 Fiddler 可以下断点，伪造 HTTP 响应。客户端发出的 HTTP 请求根本没有到达服务器，而是被 Fiddler 直接返回了一个伪造的 HTTP 响应。</p><p>具体做法是用 Fiddler 拦截住客户端发出来的 HTTP 请求，然后在“Choose Response”选中需要返回的状态码，然后单击“Run to Completion”返回给客户端，如下图：</p><p><img src="D:\blog\source\_posts\fiddler抓包\7.png" alt="7"></p><p>返回的页面信息被改为 502。</p><h2 id="Fiddler-模拟网络超时"><a href="#Fiddler-模拟网络超时" class="headerlink" title="Fiddler 模拟网络超时"></a>Fiddler 模拟网络超时</h2><p>利用 Fiddler 下断点的功能拦截住移动客户端发出的 HTTP 请求，这样就相当于网络超时了，然后再检查客户端有没有重发或者超时的机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;基本界面&quot;&gt;&lt;a href=&quot;#基本界面&quot; class=&quot;headerlink&quot; title=&quot;基本界面&quot;&gt;&lt;/a&gt;基本界面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;D:\blog\source\_posts\fiddler抓包\0.png&quot; </summary>
      
    
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发——广播机制</title>
    <link href="http://10185102110.github.io/2021/10/20/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://10185102110.github.io/2021/10/20/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-20T04:06:36.000Z</published>
    <updated>2021-10-22T14:20:53.157Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h1><p>Android 中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会收到自己所关心的广播内容，这些广播可能是来自于系统的，也可能是来自于其他应用程序的。Android 提供了一套完整的 API，允许应用程序自由地发送和接收广播，这就是 BroadcastReceiver。</p><p>Android 中的广播主要可以分为两种类型：标准广播和有序广播。</p><ul><li><p>标准广播（normal broadcasts）是一种完全异步执行的广播，在广播发出之后，所有的 BroadcastReceiver 几乎会在同一时刻收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。</p></li><li><p>有序广播（ordered broadcasts）则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个 BroadcastReceiver 能够收到这条广播消息，当这个 BroadcastReceiver 中的逻辑执行完毕后，广播才会继续传递。所以此时的 BroadcastReceiver 是有先后顺序的， 优先级高的 BroadcastReceiver 可以先收到广播消息，并且前面的 BroadcastReceiver 还可以截断正在传递的广播，使得后面的 BroadcastReceiver 无法收到广播消息。</p></li></ul><h1 id="接受系统广播"><a href="#接受系统广播" class="headerlink" title="接受系统广播"></a>接受系统广播</h1><p>Android 内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。比如手机开机完成后会发出一条广播，电池的电量发生变化会发出一条广播等等。</p><h2 id="动态注册监听时间变化"><a href="#动态注册监听时间变化" class="headerlink" title="动态注册监听时间变化"></a>动态注册监听时间变化</h2><p>注册 BroadcastReceiver 的方式一般有两种：在代码中注册和在 AndroidManifest.xml 中注册。前者被称为动态注册，后者被称为静态注册。</p><p>通过动态注册的方式编写一个能够监听时间变化的程序，修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">        timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">        registerReceiver(timeChangeReceiver, intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        unregisterReceiver(timeChangeReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeChangeReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;Time has changed&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了一个内部类 TimeChangeReceiver，继承自 BroadcastReceiver ，并重写了父类的 <code>onReceive()</code> 方法。这样每当系统时间发生变化时，<code>onReceive()</code> 方法就会得到执行。</p><p><code>onCreate()</code> 方法中，首先创建一个 IntentFilter 的实例，并给它添加了一个值为 android.intent.action.TIME_TICK 的 action，因为当系统时间发生变化时，系统发出的正是一条值为 android.intent.action.TIME_TICK 的广播。接下来创建一个 TimeChangeReceiver 的实例，然后调用 <code>registerReceiver()</code> 方法进行注册，将 TimeChangeReceiver 的实例和 IntentFilter 的实例都传进去，这样 TimeChangeReceiver 就会收到所有值为 android.intent.action.TIME_TICK 的广播， 也就实现了监听系统时间变化的功能。 最后，动态注册的 BroadcastReceiver 一定要取消注册才行，在 <code>onDestroy()</code> 方法中通过调用 <code>unregisterReceiver()</code> 方法来实现。</p><p>运行程序，系统每隔一分钟就会发出一条 android.intent.action.TIME_TICK 的广播。</p><p>完整的系统广播列表，可以到如下的路径中去查看：</p><p>Android/SDK/platforms/&lt;任意android api版本&gt;/data/broadcast_actions.txt</p><h2 id="静态注册实现开机启动"><a href="#静态注册实现开机启动" class="headerlink" title="静态注册实现开机启动"></a>静态注册实现开机启动</h2><p>动态注册的 BroadcastReceiver 必须在程序启动之后才能接收广播，因为注册的逻辑是写在 <code>onCreate()</code> 方法中的。而静态注册可以让程序在未启动的情况下也能接收广播。</p><p>由于大量恶意的应用程序在程序未启动的情况下监听系统广播，从而使任何应用都可以频繁地从后台被唤醒，严重影响了用户手机的电量和性能，Android 系统几乎每个版本都在削减静态注册 BroadcastReceiver 的功能。</p><p>在 Android 8.0 系统之后，所有隐式广播都不允许使用静态注册的方式来接收了。隐式广播指的是那些没有具体指定发送给哪个应用程序的广播，大多数系统广播属于隐式广播，但是少数特殊的系统广播目前仍然允许使用静态注册的方式来接收。这些特殊的系统广播列表详见：</p><p><a href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p><p>在这些特殊的系统广播当中，有一条值为 android.intent.action.BOOT_COMPLETED 的广播，这是一条开机广播，以它为例实现一个开机启动的功能。</p><p>可以通过 Android Studio 提供的快捷方式来创建 BroadcastReceiver。New→Other→Broadcast Receiver，命名为 BootCompleteReceiver，Exported 属性表示是否允许这个 BroadcastReceiver 接收本程序以外的广播，Enabled 属性表示是否启用这个 BroadcastReceiver，勾选这两个属性。</p><p>修改 BootCompleteReceiver 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BootCompleteReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;Boot Complete&quot;</span>, Toast.LENGTH_LONG).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态的 BroadcastReceiver 一定要在 AndroidManifest.xml 文件中注册才可以使用，这里自动注册了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.broadcasttest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.BroadcastTest&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签 <code>&lt;receiver&gt;</code> 就是静态注册的 BroadcastReceiver，不过目前的 BootCompleteReceiver 是无法收到开机广播的，还需要对 AndroidManifest.xml 文件进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.broadcasttest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.BroadcastTest&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 Android 系统启动完成后会发出一条值为 android.intent.action.BOOT_COMPLETED 的广播，因此我们在标签中又添加了一个标签，并在里面声明了相应的 action。</p><p>另外，Android 系统为了保护用户设备的安全和隐私，做了严格的规定：如果程序需要进行一些对用户来说比较敏感的操作，必须在 AndroidManifest.xml 文件中进行权限声明，否则程序将会直接崩溃。比如这里接收系统的开 机广播就是需要进行权限声明的，所以在上述代码中使用 <code>&lt;uses-permission&gt;</code> 标签声明了 android.permission.RECEIVE_BOOT_COMPLETED 权限。</p><h1 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h1><h2 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h2><p>新建一个 MyBroadcastReceiver：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;received in MyBroadcastReceiver&quot;</span>,</span><br><span class="line">            Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 MyBroadcastReceiver 收到自定义的广播时，就会弹出 “received in MyBroadcastReceiver” 的提示。</p><p>在 AndroidManifest.xml 中对这个 BroadcastReceiver 进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcasttest.MY_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让 MyBroadcastReceiver 接收一条值为 com.example.broadcasttest.MY_BROADCAST 的广播。</p><p>修改 activity_main.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Send Broadcast&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在布局文件中定义一个按钮，用于作为发送广播的触发点。</p><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcasttest.MY_BROADCAST&quot;</span>)</span><br><span class="line">            intent.setPackage(packageName)</span><br><span class="line">            sendBroadcast(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构建一个 Intent 对象，并把要发送的广播的值传入，然后调用 Intent 的 <code>setPackage()</code> 方法，并传入当前应用程序的包名。最后调用 <code>sendBroadcast()</code> 方法将广播发送出去，这样所有监听 com.example.broadcasttest.MY_BROADCAST 这条广播的 BroadcastReceiver 就会收到消息。此时发出去的广播就是一条标准广播。</p><p>默认情况下我们发出的自定义广播都是隐式广播，因此这里一定要调用 <code>setPackage()</code> 方法，指定这条广播是发送给哪个应用程序的，从而让它变成一条显式广播，否则静态注册的 BroadcastReceiver 将无法接收到这条广播。</p><h2 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h2><p>新建 AnotherBroadcastReceiver：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;received in AnotherBroadcastReceiver&quot;</span>,</span><br><span class="line">            Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AndroidManifest.xml 中对这个 BroadcastReceive r的配置进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;.AnotherBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcasttest.MY_BROADCAST&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>AnotherBroadcastReceiver 同样接收的是 com.example.broadcasttest.MY_BROADCAST 这条广播。运行程序，并点击 “Send Broadcast” 按钮，就会分别弹出两次提示信息，不过目前还是标准广播。</p><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    button.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcasttest.MY_BROADCAST&quot;</span>)</span><br><span class="line">        intent.setPackage(packageName)</span><br><span class="line">        sendOrderedBroadcast(intent, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendOrderedBroadcast()</code> 方法接收两个参数：第一个参数仍然是 Intent；第二个参数是一个与权限相关的字符串，这里传入 null。</p><p>设定 BroadcastReceiver 的先后顺序：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcasttest.MY_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 android:priority 属性将 MyBroadcastReceiver 的优先级设成 100，以保证它一定会在 AnotherBroadcastReceiver 之前收到广播。</p><p>设置 MyBroadcastReceiver 截断广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;received in MyBroadcastReceiver&quot;</span>,</span><br><span class="line">            Toast.LENGTH_SHORT).show()</span><br><span class="line">        abortBroadcast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>abortBroadcast()</code> 方法表示将这条广播截断，后面的 BroadcastReceiver 将无法再接收到这条广播。</p><p>重新运行程序，并点击 “Send Broadcast” 按钮，只有 MyBroadcastReceiver 中的 Toast 信息能够弹出。</p><h1 id="实践：强制下线功能"><a href="#实践：强制下线功能" class="headerlink" title="实践：强制下线功能"></a>实践：强制下线功能</h1><p>如果你的 QQ 号在别处登录了，就会将你强制挤下线。实现强制下线功能的思路比较简单，只需要在界面上弹出一个对话框，让用户无法进行任何其他操作，必须点击对话框中的“确定”按钮，然后回到登录界面即可。</p><p>强制下线功能需要先关闭所有的 Activity，然后回到登录界面，这里可以用到 Activity 的实践代码。</p><p>先创建一个 ActivityCollector 类用于管理所有的 Activity：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ActivityCollector &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activities = ArrayList&lt;Activity&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activities.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activities.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">finishAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (activity <span class="keyword">in</span> activities) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing) &#123;</span><br><span class="line">                activity.finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activities.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 BaseActivity 类作为所有 Activity 的父类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个 LoginActivity 来作为登录界面，编辑布局文件 activity_login.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;90dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Account:&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/accountEdit&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;90dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;18sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Password:&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/passwordEdit&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/login&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Login&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用 LinearLayout 编写了一个登录布局，最外层是一个纵向的 LinearLayout，里面包含  3 行直接子元素。第一行是一个横向的 LinearLayout，用于输入账号信息；第二行也是一个横向的 LinearLayout，用于输入密码信息；第三行是一个登录按钮。</p><p>修改 LoginActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_login)</span><br><span class="line">        login.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> account = accountEdit.text.toString()</span><br><span class="line">            <span class="keyword">val</span> password = passwordEdit.text.toString()</span><br><span class="line">            <span class="comment">// 如果账号是admin且密码是123456，就认为登录成功</span></span><br><span class="line">            <span class="keyword">if</span> (account == <span class="string">&quot;admin&quot;</span> &amp;&amp; password == <span class="string">&quot;123456&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">                startActivity(intent)</span><br><span class="line">                finish()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;account or password is invalid&quot;</span>,</span><br><span class="line">                    Toast.LENGTH_SHORT).show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里模拟了一个非常简单的登录功能。首先将 LoginActivity 的继承结构改成继承自 BaseActivity，然后在登录按钮的点击事件里对输入的账号和密码进行判断：如果账号是 admin 并且密码是 123456，就认为登录成功并跳转到 MainActivity，否则就提示用户账号或密码错误。</p><p>在主界面提供强制下线功能，修改 activity_main.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/forceOffline&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Send force offline broadcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        forceOffline.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.broadcastbestpractice.FORCE_OFFLINE&quot;</span>)</span><br><span class="line">            sendBroadcast(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在按钮的点击事件里发送了一条广播，广播的值为 com.example.broadcastbestpractice.FORCE_OFFLINE，这条广播就是用于通知程序强制用户下线的。也就是说，强制用户下线的逻辑并不是写在 MainActivity 里的，而是应该写在接收这条广播的 BroadcastReceiver 里。这样强制下线的功能就不会依附于任何界面了，不管在程序的任何地方，只要发出这样一条广播，就可以完成强制下线的操作。</p><p>在 BaseActivity 中动态注册一个 BroadcastReceiver 来接收这条强制下线广播：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> receiver: ForceOfflineReceiver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume()</span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;com.example.broadcastbestpractice.FORCE_OFFLINE&quot;</span>)</span><br><span class="line">        receiver = ForceOfflineReceiver()</span><br><span class="line">        registerReceiver(receiver, intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">        unregisterReceiver(receiver)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ForceOfflineReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">            AlertDialog.Builder(context).apply &#123;</span><br><span class="line">                setTitle(<span class="string">&quot;Warning&quot;</span>)</span><br><span class="line">                setMessage(<span class="string">&quot;You are forced to be offline. Please try to login again.&quot;</span>)</span><br><span class="line">                setCancelable(<span class="literal">false</span>)</span><br><span class="line">                setPositiveButton(<span class="string">&quot;OK&quot;</span>) &#123; _, _ -&gt;</span><br><span class="line">                    ActivityCollector.finishAll() <span class="comment">// 销毁所有Activity</span></span><br><span class="line">                    <span class="keyword">val</span> i = Intent(context, LoginActivity::<span class="keyword">class</span>.java)</span><br><span class="line">                    context.startActivity(i) <span class="comment">// 重新启动LoginActivity</span></span><br><span class="line">                &#125;</span><br><span class="line">                show()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForceOfflineReceiver 中的 <code>onReceive()</code> 方法，首先使用 AlertDialog.Builder 构建一个对话框。注意这里一定要调用 <code>setCancelable()</code> 方法将对话框设为不可取消，否则用户按一下 Back 键就可以关闭对话框继续使用程序。然后使用 <code>setPositiveButton()</code> 方法给对话框注册确定按钮，当用户点击了“OK”按钮时，就调用 ActivityCollector 的 <code>finishAll()</code> 方法销毁所有 Activity，并重新启动 LoginActivity。</p><p><code>onResume()</code> 和 <code>onPause()</code> 这两个生命周期方法分别注册和取消注册 ForceOfflineReceiver。因为我们需要保证只有处于栈顶的 Activity 才能接收到这条强制下线广播，非栈顶的 Activity 不应该也没必要接收这条广播，所以不在 <code>onCreate()</code> 和 <code>onDestroy()</code> 方法里注册和取消注册 BroadcastReceiver。</p><p>修改 AndroidManifest.xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.broadcasttest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.BroadcastTest&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.LoginActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行程序，效果如下：</p><p><img src="0.png" alt=""></p><p><img src="1.png" alt=""></p><p><strong>参考资料：</strong></p><p>[1] 郭霖 ：第一行代码 Android（第3版)）. 北京：人民邮电出版社，2020</p><p>[2] <a href="https://kotlinlang.org/docs/home.html">Kotlin docs | Kotlin (kotlinlang.org)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;广播机制简介&quot;&gt;&lt;a href=&quot;#广播机制简介&quot; class=&quot;headerlink&quot; title=&quot;广播机制简介&quot;&gt;&lt;/a&gt;广播机制简介&lt;/h1&gt;&lt;p&gt;Android 中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会</summary>
      
    
    
    
    <category term="Android" scheme="http://10185102110.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://10185102110.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发——UI</title>
    <link href="http://10185102110.github.io/2021/10/18/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94UI/"/>
    <id>http://10185102110.github.io/2021/10/18/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94UI/</id>
    <published>2021-10-18T07:06:36.000Z</published>
    <updated>2021-10-22T14:20:22.775Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="常见控件"><a href="#常见控件" class="headerlink" title="常见控件"></a>常见控件</h1><h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p>主要用于在界面上显示一段文本信息。</p><p>代码实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#00ff00&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;This is TextView&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:id</code> 给当前控件定义了一个唯一标识符，<code>android:layout_width</code> 和 <code>android:layout_height</code> 指定了控件的宽度和高度。Android中 所有的控件都具有这两个属性，可选值有 $3$ 种：match_parent、wrap_content 和固定值。</p><ul><li>match_parent 表示让当前控件的大小和父布局的大小一样。</li><li>wrap_content 表示让当前控件的大小能够刚好包含住里面的内容。</li><li>固定值表示表示给控件指定一个固定的尺寸，单位一般用 dp，这是一种屏幕密度无关的尺寸单位，可以保证在不同分辨率的手机上显示效果尽可能地一致，如 50 dp 就是一个有效的固定值。</li></ul><p><code>android:gravity</code> 指定文字的对齐方式，可选值有 top、bottom、start、 end、center 等，可以用“|”来同时指定多个值，这里我们指定的是”center”，效果等同于”center_vertical|center_horizontal”，表示文字在垂直和水平方向都居中对齐。</p><p><code>android:textColor</code> 属性指定文字的颜色，<code>android:textSize</code> 属性指定文字的大小。文字大小要使用 sp 作为单位，这样当用户在系统中修改了文字显示尺寸时，应用程序中的文字大小也会跟着变化。</p><p>效果如下：</p><p><img src="0.png" alt=""></p><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>在上述代码中加入如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="1.png" alt=""></p><p>Android 系统默认会将按钮上的英文字母全部转换成大写，如果这不是想要的效果，可以在 XML 中添加  <code>android:textAllCaps=&quot;false&quot;</code> 这个属性，系统就会保留指定的原始文字内容。</p><p>为 Button 的点击事件注册一个监听器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.first_layout)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">// 在此处添加逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><p>EditText 是程序用于和用户进行交互的另一个重要控件，它允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。</p><p>在 xml 中加入以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/editText&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">&quot;Type something here&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:maxLines</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:hint</code> 指定一段提示性的文本。</p><p><code>android:maxLines</code> 指定 EditText 的最大行数，这样当输入的内容超过两行时，文本就会向上滚动，EditText 则不会再继续拉伸。</p><p>效果如下：</p><p><img src="2.png" alt=""></p><p>可以结合使用 EditText 与 Button 来完成一些功能，比如通过点击按钮获取 EditText 中输入的内容。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line"><span class="keyword">val</span> inputText = editText.text.toString()</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span>, inputText, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p>ImageView 是用于在界面上展示图片的一个控件。</p><p>在 XML 文件中加入如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:src</span>=<span class="string">&quot;@drawable/img_1&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:src</code> 属性给 ImageView 指定一张图片。由于图片的宽和高都是未知的，所以将 ImageView 的宽和高都设定为 wrap_content，这样就保证了不管图片的尺寸是多少，都可以完整地展示出来。</p><p>效果如下：</p><p><img src="3.png" alt=""></p><p>可以在程序中通过代码动态地更改 ImageView 中的图片。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    imageView.setImageResource(R.drawable.img_2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p>ProgressBar 用于在界面上显示一个进度条，表示程序正在加载一些数据。</p><p>在 XML 中加入以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/progressBar&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="4.png" alt=""></p><p>屏幕中有一个圆形进度条不停地旋转，如何才能让进度条在数据加载完成时消失呢？</p><p>所有的 Android 控件都具有可见属性，可以通过 <code>android:visibility</code> 进行指定，可选值有 $3$ 种：visible、invisible 和 gone。visible 表示控件是可见的，这个值是默认值；invisible 表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了；gone 则表示控件不仅不可见，而且不再占用任何屏幕空间。</p><p>使用的是 <code>setVisibility()</code> 方法，允许传入 View.VISIBLE、 View.INVISIBLE 和 View.GONE 这三种值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">if</span> (progressBar.visibility == View.VISIBLE) &#123;</span><br><span class="line">        progressBar.visibility = View.GONE</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        progressBar.visibility = View.VISIBLE</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在按钮的点击事件中，通过 <code>getVisibility()</code> 方法来判断 ProgressBa r是否可见，如果可见就将 ProgressBar 隐藏掉，如果不可见就将 ProgressBar 显示出来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:id</span>=<span class="string">&quot;@+id/progressBar&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">style</span>=<span class="string">&quot;?android:attr/progressBarStyleHorizontal&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:max</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br></pre></td></tr></table></figure><p>另外，可以用 style 属性给 ProgressBar 指定不同的样式，比如水平进度条。还可以通过 <code>android:max</code> 属性给进度条设置一个最大值，然后在代码中动态地更改进度条的进度。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    progressBar.progress = progressBar.progress + <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p>AlertDialog 可以在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽其他控件的交互能力，因此 AlertDialog 一般用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。</p><p>代码实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    AlertDialog.Builder(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">        setTitle(<span class="string">&quot;This is Dialog&quot;</span>)</span><br><span class="line">        setMessage(<span class="string">&quot;Something important.&quot;</span>)</span><br><span class="line">        setCancelable(<span class="literal">false</span>)</span><br><span class="line">        setPositiveButton(<span class="string">&quot;OK&quot;</span>) &#123; dialog, which -&gt;</span><br><span class="line">                                &#125;</span><br><span class="line">        setNegativeButton(<span class="string">&quot;Cancel&quot;</span>) &#123; dialog, which -&gt;</span><br><span class="line">                                    &#125;</span><br><span class="line">        show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 AlertDialog.Builder 构建一个对话框，这里使用了 Kotlin 标准函数中的 apply 函数。在 apply 函数中为这个对话框设置标题、内容、可否使用 Back 键关闭对话框等属性，接下来调用 <code>setPositiveButton()</code> 方法为对话框设置确定按钮的点击事件，调用 <code>setNegativeButton()</code> 方法设置取消按钮的点击事件，最后调用 show() 方法将对话框显示出来。效果如下：</p><p><img src="5.png" alt=""></p><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>ListView 允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据会滚动出屏幕。</p><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p>修改 activity_main.xml，在布局中加入 ListView 控件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ListView</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:id</span>=<span class="string">&quot;@+id/listView&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> <span class="keyword">data</span> = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Mango&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Mango&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> adapter = ArrayAdapter&lt;String&gt;(<span class="keyword">this</span>,android.R.layout.simple_list_item_1,<span class="keyword">data</span>)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个包含水果名称的集合，不过集合中的数据无法直接传递给 ListView，需要借助适配器来完成。ArrayAdapter 通过泛型来指定要适配的数据类型，然后在构造函数中把要适配的数据传入。这里提供的数据都是字符串，因此将 ArrayAdapter 的泛型指定为 String，然后在 ArrayAdapter 的构造函数中依次传入 Activity 的实例、ListView 子项布局的id，以及数据源。<code>android.R.layout.simple_list_item_1</code> 作为 ListView 子项布局的 id，是一个 Android 内置的布局文件，里面只有一个 TextView，可用于简单地显示一段文本。最后调用 ListView 的 <code>setAdapter()</code> 方法，将构建好的适配器对象传递进去，这样 ListView 和数据之间的关联就建立完成了。</p><p>效果如下：</p><p><img src="12.png" alt=""></p><h3 id="定制-ListView-的界面"><a href="#定制-ListView-的界面" class="headerlink" title="定制 ListView 的界面"></a>定制 ListView 的界面</h3><p>定义一个实体类，作为 ListView 适配器的适配类型。新建 Fruit 类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>(<span class="keyword">val</span> name:String, <span class="keyword">val</span> imageId: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>Fruit 类中只有两个字段：name 表示水果的名字，imageId 表示水果对应图片的资源 id。</p><p>然后为 ListView 的子项指定一个自定义的布局，在 layout 目录下新建 fruit_item.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitName&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个布局定义了一个 ImageView 用于显示水果的图片，TextView 用于显示水果的名称，并让 ImageView 和 TextView 都在垂直方向上居中显示。</p><p>接下来创建一个自定义的适配器，这个适配器继承自 ArrayAdapter，并将泛型指定为 Fruit 类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span></span>(activity: Activity, <span class="keyword">val</span> resourceId: <span class="built_in">Int</span>, <span class="keyword">data</span>: List&lt;Fruit&gt;) :</span><br><span class="line">    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, <span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(position: <span class="type">Int</span>, convertView: <span class="type">View</span>?, parent: <span class="type">ViewGroup</span>)</span></span>: View &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">        <span class="keyword">val</span> fruit = getItem(position) <span class="comment">// 获取当前项的Fruit实例</span></span><br><span class="line">        <span class="keyword">if</span> (fruit != <span class="literal">null</span>) &#123;</span><br><span class="line">            fruitImage.setImageResource(fruit.imageId)</span><br><span class="line">            fruitName.text = fruit.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FruitAdapter 定义了一个主构造函数，用于将 Activity 的实例、ListView 子项布局的 id 和数据源传递进来。另外重写了 <code>getView()</code> 方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在 <code>getView()</code> 方法中，首先使用 LayoutInflater 来为这个子项加载我们传入的布局，第三个参数指定成 false，表示只让我们在父布局中声明的layout 属性生效，但不会为这个 View 添加父布局。接下来调用 View 的 <code>findViewById()</code> 方法分别获取到ImageView 和 TextView 的实例，然后通过 <code>getItem()</code> 方法得到当前项的 Fruit 实例，并分别调用它们的 <code>setImageResource()</code> 和 <code>setText()</code> 方法设置显示的图片和文字，最后将布局返回。</p><p>最后修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruitList = ArrayList&lt;Fruit&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initFruits() <span class="comment">// 初始化水果数据</span></span><br><span class="line">        <span class="keyword">val</span> adapter = FruitAdapter(<span class="keyword">this</span>, R.layout.fruit_item, fruitList)</span><br><span class="line">        listView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFruits</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat(<span class="number">2</span>) &#123;</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Apple&quot;</span>, R.drawable.apple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Banana&quot;</span>, R.drawable.banana_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Orange&quot;</span>, R.drawable.orange_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Watermelon&quot;</span>, R.drawable.watermelon_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pear&quot;</span>, R.drawable.pear_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Grape&quot;</span>, R.drawable.grape_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Pineapple&quot;</span>, R.drawable.pineapple_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Strawberry&quot;</span>, R.drawable.strawberry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Cherry&quot;</span>, R.drawable.cherry_pic))</span><br><span class="line">            fruitList.add(Fruit(<span class="string">&quot;Mango&quot;</span>, R.drawable.mango_pic))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="13.png" alt=""></p><h3 id="提升-ListView-的运行效率"><a href="#提升-ListView-的运行效率" class="headerlink" title="提升 ListView 的运行效率"></a>提升 ListView 的运行效率</h3><p>目前这个 ListView 的运行效率是很低的，因为在 FruitAdapter 的 <code>getView()</code> 方法中，每次都将布局重新加载了一遍，当 ListView 快速滚动的时候，这就会成为性能的瓶颈。</p><p><code>getView()</code> 方法中还有一个 convertView 参数，用于将之前加载好的布局进行缓存，以便之后进行重用，可以借助这个参数来进行性能优化。修改 FruitAdapter 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span></span>(activity: Activity, <span class="keyword">val</span> resourceId: <span class="built_in">Int</span>, <span class="keyword">data</span>: List&lt;Fruit&gt;) :</span><br><span class="line">    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, <span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(position: <span class="type">Int</span>, convertView: <span class="type">View</span>?, parent: <span class="type">ViewGroup</span>)</span></span>: View &#123;</span><br><span class="line">        <span class="keyword">val</span> view: View</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">        <span class="keyword">val</span> fruit = getItem(position) <span class="comment">// 获取当前项的Fruit实例</span></span><br><span class="line">        <span class="keyword">if</span> (fruit != <span class="literal">null</span>) &#123;</span><br><span class="line">            fruitImage.setImageResource(fruit.imageId)</span><br><span class="line">            fruitName.text = fruit.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 convertView 为 null，则使用 LayoutInflater 去加载布局；如果不为 null，则直接对 convertView 进行重用。</p><p>虽然现在已经不会再重复去加载布局，但是每次在 <code>getView()</code> 方法中仍然会调用 View 的 <code>findViewById()</code> 方法来获取一次控件的实例。 我们可以借助一个 ViewHolder 来对这部分性能进行优化，修改 FruitAdapter 中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span></span>(activity: Activity, <span class="keyword">val</span> resourceId: <span class="built_in">Int</span>, <span class="keyword">data</span>: List&lt;Fruit&gt;) :</span><br><span class="line">    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, <span class="keyword">data</span>) &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>(<span class="keyword">val</span> fruitImage: ImageView, <span class="keyword">val</span> fruitName: TextView)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(position: <span class="type">Int</span>, convertView: <span class="type">View</span>?, parent: <span class="type">ViewGroup</span>)</span></span>: View &#123;</span><br><span class="line">        <span class="keyword">val</span> view: View</span><br><span class="line">        <span class="keyword">val</span> viewHolder: ViewHolder</span><br><span class="line">        <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;</span><br><span class="line">            view = LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">            <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">            viewHolder = ViewHolder(fruitImage, fruitName)</span><br><span class="line">            view.tag = viewHolder</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = convertView</span><br><span class="line">            viewHolder = view.tag <span class="keyword">as</span> ViewHolder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> fruit = getItem(position) <span class="comment">// 获取当前项的Fruit实例</span></span><br><span class="line">        <span class="keyword">if</span> (fruit != <span class="literal">null</span>) &#123;</span><br><span class="line">            viewHolder.fruitImage.setImageResource(fruit.imageId)</span><br><span class="line">            viewHolder.fruitName.text = fruit.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增一个内部类 ViewHolder，用于对 ImageView 和 TextView 的控件实例进行缓存。当 convertView 不为 null 的时候，则调用 View 的 <code>getTag()</code> 方法，把 ViewHolder 重新取出。</p><h3 id="ListView-的点击事件"><a href="#ListView-的点击事件" class="headerlink" title="ListView 的点击事件"></a>ListView 的点击事件</h3><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    initFruits() <span class="comment">// 初始化水果数据</span></span><br><span class="line">    <span class="keyword">val</span> adapter = FruitAdapter(<span class="keyword">this</span>, R.layout.fruit_item, fruitList)</span><br><span class="line">    listView.adapter = adapter</span><br><span class="line">    listView.setOnItemClickListener &#123; parent, view, position, id -&gt;</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, fruit.name, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>setOnItemClickListener()</code> 方法为 ListView 注册一个监听器，当用户点击了 ListView 中的任何一个子项时，就会回调到 Lambda 表达式中。可以通过 position 参数判断用户点击的是哪一个子项，然后获取到相应的水果，并通过 Toast 将水果的名字显示出来。</p><p>查看源码发现 <code>setOnItemClickListener()</code> 方法接收 4 个参数，但是这里只用到一个 position，Kotlin 允许我们将没有用到的参数使用下划线来替代：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listView.setOnItemClickListener &#123; _, _, position, _ -&gt;</span><br><span class="line"><span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">Toast.makeText(<span class="keyword">this</span>, fruit.name, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><p>更强大的滚动控件。</p><h3 id="RecyclerView-的基本用法"><a href="#RecyclerView-的基本用法" class="headerlink" title="RecyclerView 的基本用法"></a>RecyclerView 的基本用法</h3><p>RecyclerView 属于新增控件，要在 app/build.gradle 文件中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">implementation &#x27;androidx.recyclerview:recyclerview:1.0.0&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在布局中加入 RecyclerView 控件，修改 activity_main.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 RecyclerView 并不是内置在系统 SDK 当中的，所以需要把完整的包路径写出来。</p><p>Fruit 类 和 fruit_item.xml 与 ListView 一致，接下来需要为 RecyclerView 准备一个适配器，新建 FruitAdapter 类，让这个适配器继承自 RecyclerView.Adapter，并将泛型指定为 FruitAdapter.ViewHolder。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitAdapter</span></span>(<span class="keyword">val</span> fruitList: List&lt;Fruit&gt;) :</span><br><span class="line">    RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        <span class="keyword">val</span> fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(parent.context)</span><br><span class="line">            .inflate(R.layout.fruit_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        holder.fruitImage.setImageResource(fruit.imageId)</span><br><span class="line">        holder.fruitName.text = fruit.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = fruitList.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先定义一个内部类 ViewHolder，它要继承自 RecyclerView.ViewHolder，ViewHolder 的主构造函数中要传入一个 View 参数，这个参数通常就是 RecyclerView 子项的最外层布局，那么就可以通过 <code>findViewById()</code> 方法来获取布局中 ImageView 和 TextView 的实例。接下来重写  onCreateViewHolder()、onBindViewHolder() 和 getItemCount() 这 3个方法。 <code>onCreateViewHolder()</code> 方法用于创建 ViewHolder 实例，在这个方法中将 fruit_item 布局加载进来。<code>onBindViewHolder()</code> 方法创建一个 ViewHolder 实例，并把加载出来的布局传入构造函数当中，最后将 ViewHolder 的实例返回。<code>onBindViewHolder()</code> 方法用于对 RecyclerView 子项的数据进行赋值，会在每个子项被滚动到屏幕内的时候执行，这里通过 position 参数得到当前项的 Fruit 实例，然后再将数据设置到 ViewHolder 的 ImageView 和 TextView 当中。<code>getItemCount()</code> 方法用于告诉 RecyclerView 一共有多少子项。</p><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    initFruits() <span class="comment">// 初始化水果数据</span></span><br><span class="line">    <span class="keyword">val</span> layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">    recyclerView.layoutManager = layoutManager</span><br><span class="line">    <span class="keyword">val</span> adapter = FruitAdapter(fruitList)</span><br><span class="line">    recyclerView.adapter = adapter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LayoutManager 用于指定 RecyclerView 的布局方式。</p><h3 id="实现横向滚动和瀑布流布局"><a href="#实现横向滚动和瀑布流布局" class="headerlink" title="实现横向滚动和瀑布流布局"></a>实现横向滚动和瀑布流布局</h3><p>首先要对 fruit_item 布局进行修改，因为目前这个布局里面的元素是水平排列的，适用于纵向滚动的场景，而如果要实现横向滚动的话，应该把 fruit_item 里的元素改成垂直排列，并限制宽度。</p><p>修改 fruit_item.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;80dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitName&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    initFruits() <span class="comment">// 初始化水果数据</span></span><br><span class="line">    <span class="keyword">val</span> layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">    layoutManager.orientation = LinearLayoutManager.HORIZONTAL</span><br><span class="line">    recyclerView.layoutManager = layoutManager</span><br><span class="line">    <span class="keyword">val</span> adapter = FruitAdapter(fruitList)</span><br><span class="line">    recyclerView.adapter = adapter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入了一行代码，调用 LinearLayoutManager 的 <code>setOrientation()</code> 方法设置布局的排列方向。默认是纵向排列的，传入 LinearLayoutManager.HORIZONTAL 表示让布局横向排列，这样就可以横向滚动了。</p><p>除了 LinearLayoutManager 之外，RecyclerView 还提供了 GridLayoutManager 和  StaggeredGridLayoutManager 这两种内置的布局排列方式。GridLayoutManager 可以用于实现网格布局， StaggeredGridLayoutManager 可以用于实现瀑布流布局。</p><p>接下来实现瀑布流布局，修改 fruit_item.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitImage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/fruitName&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 MainActivity 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> fruitList = ArrayList&lt;Fruit&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initFruits() <span class="comment">// 初始化水果数据</span></span><br><span class="line">        <span class="keyword">val</span> layoutManager = StaggeredGridLayoutManager(<span class="number">3</span>,</span><br><span class="line">            StaggeredGridLayoutManager.VERTICAL)</span><br><span class="line">        recyclerView.layoutManager = layoutManager</span><br><span class="line">        <span class="keyword">val</span> adapter = FruitAdapter(fruitList)</span><br><span class="line">        recyclerView.adapter = adapter</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFruits</span><span class="params">()</span></span> &#123;</span><br><span class="line">        repeat(<span class="number">2</span>) &#123;</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Apple&quot;</span>),</span><br><span class="line">                R.drawable.apple_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Banana&quot;</span>),</span><br><span class="line">                R.drawable.banana_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Orange&quot;</span>),</span><br><span class="line">                R.drawable.orange_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Watermelon&quot;</span>),</span><br><span class="line">                R.drawable.watermelon_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Pear&quot;</span>),</span><br><span class="line">                R.drawable.pear_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Grape&quot;</span>),</span><br><span class="line">                R.drawable.grape_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Pineapple&quot;</span>),</span><br><span class="line">                R.drawable.pineapple_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Strawberry&quot;</span>),</span><br><span class="line">                R.drawable.strawberry_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Cherry&quot;</span>),</span><br><span class="line">                R.drawable.cherry_pic))</span><br><span class="line">            fruitList.add(Fruit(getRandomLengthString(<span class="string">&quot;Mango&quot;</span>),</span><br><span class="line">                R.drawable.mango_pic))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRandomLengthString</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = (<span class="number">1.</span><span class="number">.20</span>).random()</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        repeat(n) &#123;</span><br><span class="line">            builder.append(str)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StaggeredGridLayoutManager 的构造函数接收两个参数：第一个参数用于指定布局的列数，传入 3 表示会把布局分为 3 列；第二个参数用于指定布局的排列方向，传入 StaggeredGridLayoutManager.VERTICAL 表示会让布局纵向排列。</p><p>由于瀑布流布局需要各个子项的高度不一致才能看出明显的效果，自定义 getRandomLengthString() 方法将水果名字拉长以加大差距。</p><p>效果如下：</p><p><img src="14.png" alt=""></p><h3 id="RecyclerView-的点击事件"><a href="#RecyclerView-的点击事件" class="headerlink" title="RecyclerView 的点击事件"></a>RecyclerView 的点击事件</h3><p>RecyclerView 需要自己给子项具体的 View 注册点击事件。</p><p>修改 FruitAdapter 中的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">    <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">val</span> viewHolder = ViewHolder(view)</span><br><span class="line">    viewHolder.itemView.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">val</span> position = viewHolder.adapterPosition</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        Toast.makeText(parent.context, <span class="string">&quot;you clicked view <span class="subst">$&#123;fruit.name&#125;</span>&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">    viewHolder.fruitImage.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">val</span> position = viewHolder.adapterPosition</span><br><span class="line">        <span class="keyword">val</span> fruit = fruitList[position]</span><br><span class="line">        Toast.makeText(parent.context, <span class="string">&quot;you clicked image <span class="subst">$&#123;fruit.name&#125;</span>&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewHolder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码分别为最外层布局和 ImageView 注册了点击事件。RecyclerView 的强大之处也在于此，它可以轻松实现子项中任意控件或布局的点击事件。</p><h1 id="3-种布局"><a href="#3-种布局" class="headerlink" title="3 种布局"></a>3 种布局</h1><p>布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面。当然，布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套能够完成一些比较复杂的界面实现。</p><h2 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h2><p>LinearLayout 又称作线性布局。</p><p>代码格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_gravity</span>=<span class="string">&quot;top&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:text</span>=<span class="string">&quot;Button 1&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:text</span>=<span class="string">&quot;Button 2&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_gravity</span>=<span class="string">&quot;bottom&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:text</span>=<span class="string">&quot;Button 3&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>android:orientation</code> 属性指定排列方向是 vertical（垂直）或者 horizontal（水平）。需要注意，如果 LinearLayout 的排列方向是 horizontal，内部的控件就绝对不能将宽度指定为 match_parent，否则，单独一个控件就会将整个水平方向占满。同理，如果 LinearLayout 的排列方向是 vertical，内部的控件就不能将高度指定为 match_parent。</p><p><code>android:layout_gravity</code> 属性用于指定控件在布局中的对齐方式。当 LinearLayout 的排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效。同理，当 LinearLayout 的排列方向是 vertical 时，只有水平方向上的对齐方式才会生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:id</span>=<span class="string">&quot;@+id/input_message&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:hint</span>=<span class="string">&quot;Type something&quot;</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br><span class="line">    </span><br><span class="line"> <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:id</span>=<span class="string">&quot;@+id/send&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:text</span>=<span class="string">&quot;Send&quot;</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:layout_weight</code> 属性使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面起到重要作用。</p><p>由于我们使用了 <code>android:layout_weight</code> 属性，此时控件的宽度就不应该再由 <code>android:layout_width</code> 来决定了，<code>android:layout_width</code> 指定成 0 dp 是一种比较规范的写法。</p><p>在 EditText 和 Button 里将 <code>android:layout_weight</code> 属性的值指定为 $1$，这表示 EditText 和 Button 将在水平方向平分宽度。原理很简单，系统会先把 LinearLayout 下所有控件指定的 layout<em>weight 值相加，得到一个总值， 然后每个控件所占大小的比例就是用该控件的 layout_weight 值除总值。因此如果想让 EditText 占据屏幕宽度的 3/5，Button 占据屏幕宽度的 2/5，只需要将 EditText 的 layout</em> weight 改成 3，Button 的 layout_weight 改成 2 就可以了。</p><p>使用 layout_weight 实现宽度自适配效果：</p><p>指定 EditText 的 <code>android:layout_weight</code> 属性为 1，并将 Button 的宽度改回 wrap_content。这表示 Button 的宽度仍然按照 wrap_content 来计算，而 EditText 则会占满屏幕所有的剩余空间。使用这种方式编写的界面，不仅可以适配各种屏幕，而且看起来也更加舒服。</p><h2 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h2><p>RelativeLayout 又称作相对布局，它可以通过相对定位的方式让控件出现在布局的任何位置。</p><p>代码实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentLeft</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentTop</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentLeft</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button5&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 5&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>让 Button 1 和父布局的左上角对齐，Button 2 和父布局的右上角对齐，Button 3 居中显示，Button 4 和父布局的左下角对齐， Button 5 和父布局的右下角对齐。</p><p>效果如下：</p><p><img src="6.png" alt=""></p><p>控件也可以相对于控件进行定位。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toLeftOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_above</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button4&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toLeftOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 4&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button5&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@id/button3&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 5&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:layout_above</code> 属性可以让一个控件位于另一个控件的上方，需要为这个属性指定相对控件 id 的引用，这里填入了 @id/button3，表示让该控件位于 Button 3 的上方。其他的属性也是相似的，<code>android: layout_below</code> 表示让一个控件位于另一个控件的下方，<code>android:layout_toLeftOf</code> 表示让一个控件位于另一个控件的左侧，<code>android:layout_toRightOf</code> 表示让一个控件位于另一个控件的右侧。注意，当一个控件去引用另一个控件的 id 时，该控件一定要定义在引用控件的后面，不然会出现找不到 id 的情况。</p><p>效果如下：</p><p><img src="7.png" alt=""></p><p>RelativeLayout 中还有另外一组相对于控件进行定位的属性，<code>android:layout_alignLeft</code> 表示让一个控件的左边缘和另一个控件的左边缘对齐，<code>android:layout_alignRight</code> 表示让一个控件的右边缘和另一个控件的右边缘对齐。<code>android:layout_alignTop</code> 和 <code>android:layout_alignBottom</code> 同理。</p><h2 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h2><p>FrameLayout 又称作帧布局，这种布局没有丰富的定位方式，所有的控件都会默认摆放在布局的左上角。</p><p>代码实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;This is TextView&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="8.png" alt=""></p><p>除了这种默认效果之外，还可以使用 layout_gravity 属性来指定控件在布局中的对齐方式。</p><p><code>android:layout_gravity</code> 属性的 left 和 right 分别让控件居左对齐和居右对齐。</p><p>效果如下：</p><p><img src="9.png" alt=""></p><h1 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h1><p>常用控件和布局的继承结构：</p><p><img src="10.png" alt=""></p><ol><li><p>引入布局</p><p>以自定义标题栏为例，创建一个 Empty Activity 项目，在 layout 目录下新建一个 title.xml 布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/title_bg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/titleBack&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/back_bg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Back&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#fff&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/titleText&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Title Text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#fff&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/titleEdit&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/edit_bg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Edit&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;#fff&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 LinearLayout 中分别加入了两个 Button 和一个 TextView，左边的 Button 可用于返回，右边的 Button 可用于编辑，中间的 TextView 则可以显示一段标题文本。</p><p><code>android:background</code> 用于为布局或控件指定一个背景，可以使用颜色或图片来进行填充。</p><p><code>android:layout_margin</code> 属性可以指定控件在上下左右方向的间距，也可以使用<code>android:layout_marginLeft</code> 或 <code>android:layout_marginTop</code> 等属性来单独指定控件在某个方向上的间距。</p><p>在 activity_main.xml 中引入该布局：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/title&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 MainActivity 中将系统自带的标题栏隐藏掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        supportActionBar?.hide()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>getSupportActionBar()</code> 方法来获得 ActionBar 的实例，然后再调用它的 <code>hide()</code> 方法将标题栏隐藏起来。由于 ActionBar 有可能为空，所以这里还使用了 <code>?.</code> 操作符。</p><p>效果如下：</p><p><img src="11.png" alt=""></p><p>引入布局的技巧解决了重复编写布局代码的问题，而自定义控件可以解决重复编写事件注册的问题。</p></li><li><p>创建自定义控件</p><p>新建 TitleLayout.kt 继承自 LinearLayout，让它成为自定义的标题栏控件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span></span>(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>)</span><br><span class="line">        titleBack.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> activity = context <span class="keyword">as</span> Activity</span><br><span class="line">            activity.finish()</span><br><span class="line">        &#125;</span><br><span class="line">        titleEdit.setOnClickListener &#123;</span><br><span class="line">            Toast.makeText(context, <span class="string">&quot;You clicked Edit button&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TitleLayout 的主构造函数中声明了 Context（一个 Activity 实例） 和 AttributeSet 这两个参数，在布局中引入 TitleLayout 控件时就会调用这个构造函数。然后在 init 结构体中对标题栏布局进行动态加载，通过 LayoutInflater 的 <code>from()</code> 方法可以构建出一个 LayoutInflater 对象，然后调用 <code>inflate()</code> 方法就可以动态加载一个布局文件。<code>inflate()</code> 方法接收两个参数：第一个参数是要加载的布局文件的 id，这里传入 R.layout.title；第二个参数是给加载好的布局再添加一个父布局，这里指定为 TitleLayout，于是直接传入 this。</p><p>然后分别给返回和编辑这两个按钮注册点击事件，当点击返回按钮时销毁当前 Activity， 当点击编辑按钮时弹出一段文本。</p><p>修改 activity_main.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">com.example.uicustomviews.TitleLayout</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加自定义控件和添加普通控件的方式基本是一样的，但是在添加自定义控件时需要指明控件的完整类名。</p><p>这样的话，每当我们在一个布局中引入 TitleLayout 时，返回按钮和编辑按钮的点击事件就自动实现好了。</p></li></ol><h1 id="聊天界面实践"><a href="#聊天界面实践" class="headerlink" title="聊天界面实践"></a>聊天界面实践</h1><h2 id="制作-9-Patch-图片"><a href="#制作-9-Patch-图片" class="headerlink" title="制作 9-Patch 图片"></a>制作 9-Patch 图片</h2><p>它是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸、哪些区域不可以。</p><p><img src="15.png" alt=""></p><p>修改 activity_main.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/message_left_original&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="16.png" alt=""></p><p>由于图片的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了，效果非常差。</p><p>下面来制作 9-Patch 图片，右击该图片→Create 9-Patch file，保存就会弹出编辑界面：</p><p><img src="17.png" alt=""></p><p>在图片的 4 个边框绘制黑点，在上边框和左边框绘制的部分表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分表示内容允许被放置的区域。使用鼠标在图片的边缘拖动就可以进行绘制，按住 Shift 键拖动可以进行擦除。绘制完成后效果如下：</p><p><img src="18.png" alt=""></p><p>将原图片删除，重新运行，效果如下：</p><p><img src="19.png" alt=""></p><h2 id="编写简单的聊天界面"><a href="#编写简单的聊天界面" class="headerlink" title="编写简单的聊天界面"></a>编写简单的聊天界面</h2><p>在 app/build.gradle 当中添加依赖库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;androidx.recyclerview:recyclerview:1.0.0&#x27;</span><br></pre></td></tr></table></figure><p>始编写主界面，修改 activity_main.xml 中的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#d8e0e8&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/inputText&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:hint</span>=<span class="string">&quot;Type something here&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:maxLines</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/send&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Send&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>RecyclerView 用于显示聊天的消息内容，EditText 用于输入消息，Button 用于发送消息。</p><p>定义消息的实体类，新建 Msg：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span></span>(<span class="keyword">val</span> content: String, <span class="keyword">val</span> type: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TYPE_RECEIVED = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> TYPE_SENT = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Msg 类中只有两个字段：content 表示消息的内容，type 表示消息的类型。其中消息类型有两个值可选：TYPE_RECEIVED 表示这是一条收到的消息，TYPE_SENT 表示这是一条发出的消息。定义常量的关键字是 const， 注意只有在单例类、companion object 或顶层方法中才可以使用 const 关键字。</p><p>编写 RecyclerView 的接收消息子项布局，新建 msg_left_item.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/message_left&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftMsg&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#fff&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写发送消息的子项布局，新建 msg_right_item.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/message_right&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/rightMsg&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_margin</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建 RecyclerView 的适配器类，新建类 MsgAdapter：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgAdapter</span></span>(<span class="keyword">val</span> msgList: List&lt;Msg&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftViewHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> leftMsg: TextView = view.findViewById(R.id.leftMsg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">RightViewHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> rightMsg: TextView = view.findViewById(R.id.rightMsg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemViewType</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">return</span> msg.type</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (viewType ==</span><br><span class="line">        Msg.TYPE_RECEIVED) &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_left_item,</span><br><span class="line">            parent, <span class="literal">false</span>)</span><br><span class="line">        LeftViewHolder(view)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> view = LayoutInflater.from(parent.context).inflate(R.layout.msg_right_item,</span><br><span class="line">            parent, <span class="literal">false</span>)</span><br><span class="line">        RightViewHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg = msgList[position]</span><br><span class="line">        <span class="keyword">when</span> (holder) &#123;</span><br><span class="line">            <span class="keyword">is</span> LeftViewHolder -&gt; holder.leftMsg.text = msg.content</span><br><span class="line">            <span class="keyword">is</span> RightViewHolder -&gt; holder.rightMsg.text = msg.content</span><br><span class="line">            <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = msgList.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据不同的 viewType 创建不同的界面。首先定义 LeftViewHolder 和 RightViewHolder 这两个 ViewHolder，分别用于缓存 msg_left_item.xml 和 msg_right_item.xml 布局中的控件。然后重写 <code>getItemViewType()</code> 方法，并在这个方法中返回当前 position 对应的消息类型。</p><p>在 <code>onCreateViewHolder()</code> 方法中根据不同的 viewType 来加载不同的布局并创建不同的 ViewHolder。然后在 <code>onBindViewHolder()</code> 方法中判断 ViewHolder 的类型：如果是 LeftViewHolder，就将内容显示到左边的消息布局；如果是 RightViewHolder，就将内容显示到右边的消息布局。</p><p>最后修改 MainActivity 中的代码，为 RecyclerView 初始化一些数据，并给发送按钮加入事件响应，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> msgList = ArrayList&lt;Msg&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> adapter: MsgAdapter? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initMsg()</span><br><span class="line">        <span class="keyword">val</span> layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">        recyclerView.layoutManager = layoutManager</span><br><span class="line">        adapter = MsgAdapter(msgList)</span><br><span class="line">        recyclerView.adapter = adapter</span><br><span class="line">        send.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (v) &#123;</span><br><span class="line">            send -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> content = inputText.text.toString()</span><br><span class="line">                <span class="keyword">if</span> (content.isNotEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">val</span> msg = Msg(content, Msg.TYPE_SENT)</span><br><span class="line">                    msgList.add(msg)</span><br><span class="line">                    adapter?.notifyItemInserted(msgList.size - <span class="number">1</span>) <span class="comment">// 当有新消息时， 刷新RecyclerView中的显示</span></span><br><span class="line">                    recyclerView.scrollToPosition(msgList.size - <span class="number">1</span>) <span class="comment">// 将RecyclerView 定位到最后一行</span></span><br><span class="line">                    inputText.setText(<span class="string">&quot;&quot;</span>) <span class="comment">// 清空输入框中的内容</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initMsg</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> msg1 = Msg(<span class="string">&quot;Hello guy.&quot;</span>, Msg.TYPE_RECEIVED)</span><br><span class="line">        msgList.add(msg1)</span><br><span class="line">        <span class="keyword">val</span> msg2 = Msg(<span class="string">&quot;Hello. Who is that?&quot;</span>, Msg.TYPE_SENT)</span><br><span class="line">        msgList.add(msg2)</span><br><span class="line">        <span class="keyword">val</span> msg3 = Msg(<span class="string">&quot;This is Tom. Nice talking to you. &quot;</span>, Msg.TYPE_RECEIVED)</span><br><span class="line">        msgList.add(msg3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="20.png" alt=""></p><h1 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h1><p><strong>参考资料：</strong></p><p>[1] 郭霖 ：第一行代码 Android（第3版)）. 北京：人民邮电出版社，2020</p><p>[2] <a href="https://kotlinlang.org/docs/home.html">Kotlin docs | Kotlin (kotlinlang.org)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;常见控件&quot;&gt;&lt;a href=&quot;#常见控件&quot; class=&quot;headerlink&quot; title=&quot;常见控件&quot;&gt;&lt;/a&gt;常见控件&lt;/h1&gt;&lt;h2 id=&quot;TextView&quot;&gt;&lt;a href=&quot;#TextView&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="Android" scheme="http://10185102110.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://10185102110.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发——Activity</title>
    <link href="http://10185102110.github.io/2021/10/16/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Activity/"/>
    <id>http://10185102110.github.io/2021/10/16/Android%20%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Activity/</id>
    <published>2021-10-16T11:06:36.000Z</published>
    <updated>2021-10-22T14:18:35.344Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Activity-的基本用法"><a href="#Activity-的基本用法" class="headerlink" title="Activity 的基本用法"></a>Activity 的基本用法</h1><h2 id="创建-Activity"><a href="#创建-Activity" class="headerlink" title="创建 Activity"></a>创建 Activity</h2><p>新建一个 Android 项目，选择 “Add No Activity”，包名使用默认值 com.example.activitytest。</p><p>app/src/main/java/com.example.activitytest 目录是空的，右击 com.example.activitytest 包→New→Activity→Empty Activity，命名为 FirstActivity。Generate Layout File 表示会自动为 FirstActivity 创建一个对应的布局文件，Launcher Activity 表示会自动将 FirstActivity 设置为当前项目的主 Activity，暂时都不勾选。</p><h2 id="创建和加载布局"><a href="#创建和加载布局" class="headerlink" title="创建和加载布局"></a>创建和加载布局</h2><p>右击 app/src/main/res 创建一个 layout 目录，然后对着 layout 目录右键→New→Layout resource file，将这个布局文件命名为 first_layout，根元素默认选择为 LinearLayout。</p><p>在 first_layout 中添加一个 Button 元素，并在 Button 元素内部增加几个属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button1&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 1&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:id</code> 是给当前元素定义一个唯一的标识符，<code>@+id/id_name</code> 表示在 XML 中定义一个 id，去掉 ’+‘ 号就是引用一个 id。<code>android:layout_width</code> 指定了当前元素的宽度，这里使用 match_parent 表示让当前元素和父元素一样宽。<code>android:layout_height</code> 指定了当前元素的高度，这里使用 wrap_content 表示当前元素的高度只要能刚好包含里面的内容就行。<code>android:text</code> 指定了元素中显示的文字内容。</p><p>一个简单的布局编写完成了，接下来在 Activity 中加载这个布局。</p><p>在 FirstActivity 的 onCreate() 方法中加入如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.first_layout)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 <code>setContentView()</code> 方法来给当前的 Activity 加载一个布局，而在 setContentView() 方法中，一般会传入一个布局文件的 id。</p><h2 id="在-AndroidManifest-xml-注册"><a href="#在-AndroidManifest-xml-注册" class="headerlink" title="在 AndroidManifest.xml 注册"></a>在 AndroidManifest.xml 注册</h2><p>所有的 Activity 都要在 AndroidManifest.xml 中进行注册才能生效。实际上 FirstActivity 已经在 AndroidManifest.xml 中注册过了，打开 app/src/main/AndroidManifest.xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.activitytest&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Activitytest&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，Activity 的注册声明要放在 <code>&lt;application&gt;</code> 标签内，这里是通过 <code>&lt;activity&gt;</code> 标签来对 Activity 进行注册的。</p><p>接下来为程序配置主 Activity，对标签  <code>&lt;activity&gt;</code> 进行修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:label</span>=<span class="string">&quot;This is FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>android:label</code> 指定 Activity 中标题栏的内容，标题栏是显示在 Activity 最顶部的，还是启动器（Launcher）中应用程序显示的名称。</p><p>运行结果：</p><p><img src="0.png" alt=""></p><h2 id="在-Activity-中使用-Toast"><a href="#在-Activity-中使用-Toast" class="headerlink" title="在 Activity 中使用 Toast"></a>在 Activity 中使用 Toast</h2><p>Toast 是 Android 系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不会占用任何屏幕空间。</p><p>首先需要定义一个弹出 Toast 的触发点，就让这个按钮的点击事件作为弹出Toast的触发点。</p><p>在 <code>onCreate()</code> 方法中添加如下代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.first_layout)</span><br><span class="line">    <span class="keyword">val</span> button1: Button = findViewById(R.id.button1)</span><br><span class="line">    button1.setOnClickListener &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;You clicked Button 1&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Activity 中，可以通过 <code>findViewById()</code> 方法获取在布局文件中定义的元素，这里我们传入 R.id.button1来得到按钮的实例。得到按钮的实例之后，通过调用 <code>setOnClickListener()</code> 方法为按钮注册一个监听器，点击按钮时就会执行监听器中的 <code>onClick()</code> 方法。 通过静态方法 <code>makeText()</code> 创建出一个 Toast 对象，然后调用 <code>show()</code> 将 Toast 显示出来就可以了。</p><p>makeText() 方法需要传入 3 个参数。第一个参数是 Context，也就是 Toast 要求的上下文，由于 Activity 本身就是一个 Context 对象，这里直接传入 this 即可；第二个参数是 Toast 显示的文本内容；第三个参数是 Toast 显示的时长，有两个内置常量可以选择：Toast.LENGTH_SHORT 和 Toast.LENGTH_LONG。</p><p>重新运行并点击按钮：</p><p><img src="1.png" alt=""></p><p>Kotlin 编写的 Android 项目在 app/build.gradle 文件的头部默认引入了一个 kotlin-android-extensions 插件，这个插件会根据布局文件中定义的控件 id 自动生成一个具有相同名称的变量，我们可以在 Activity 里直接使用 这个变量，而不用再调用 findViewById() 方法了。</p><h2 id="在-Activity-中使用-Menu"><a href="#在-Activity-中使用-Menu" class="headerlink" title="在 Activity 中使用 Menu"></a>在 Activity 中使用 Menu</h2><p>首先在 res 目录下新建一个 menu 目录，接着在这个目录新建一个名叫 “main” 的菜单文件，右击 menu→New→Menu resource file。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_item&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:title</span>=<span class="string">&quot;Add&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/remove_item&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:title</span>=<span class="string">&quot;Remove&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建两个菜单项，其中标签 <code>&lt;item&gt;</code> 用来创建具体的某一个菜单项，然后通过 <code>android:id</code> 给这个菜单项指定一个唯一的标识符，通过 <code>android:title</code> 给这个菜单项指定一个名称。</p><p>回到 FirstActivity 中来重写 <code>onCreateOptionsMenu()</code> 方法，重写方法可以使用 Ctrl + O 快捷键。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    menuInflater.inflate(R.menu.main, menu)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onCreateOptionsMenu()</code> 方法中实际上调用了父类的 <code>getMenuInflater()</code> 方法。<code>getMenuInflater()</code> 方法能够得到一个 MenuInflater 对象，再调用它的 <code>inflate()</code> 方法，就可以给当前 Activity 创建菜单了。<code>inflate()</code> 方法接收两个参数：第一个参数用于指定我们通过哪一个资源文件来创建菜单，这里传入R.menu.main；第二个参数用于指定我们的菜单项将添加到哪一个 Menu 对象当中，这里直接使用 <code>onCreateOptionsMenu()</code> 方法中传入的 menu 参数。最后给这个方法返回 true，表示允许创建的菜单显示出来；如果返回了false，创建的菜单将无法显示。</p><p>定义菜单响应事件。在 FirstActivity 中重写 <code>onOptionsItemSelected()</code> 方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">        R.id.add_item -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;You clicked Add&quot;</span>,</span><br><span class="line">            Toast.LENGTH_SHORT).show()</span><br><span class="line">        R.id.remove_item -&gt; Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;You clicked Remove&quot;</span>,</span><br><span class="line">            Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右上角的三点就是菜单，内部有两个菜单项。</p><p><img src="D:\blog\source\_posts\Android 开发——Activity\2.png" alt="2"></p><p><img src="3.png" alt=""></p><h2 id="销毁一个-Activity"><a href="#销毁一个-Activity" class="headerlink" title="销毁一个 Activity"></a>销毁一个 Activity</h2><p>其实只要按一下 Back 键就可以销毁当前的 Activity，但也可以通过代码销毁，调用 <code>finish()</code> 方法。</p><p>修改按钮监听器中的代码，如下所示： </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123; </span><br><span class="line">    finish() </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>重新运行程序，这时点击一下按钮，当前的 Activity 就被成功销毁了，效果和按下 Back 键是一样的。</p><h1 id="使用-Intent-切换-Activity"><a href="#使用-Intent-切换-Activity" class="headerlink" title="使用 Intent 切换 Activity"></a>使用 Intent 切换 Activity</h1><p>Intent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent 一般可用于启动 Activity、启动 Service 以及发送广播等场景。</p><p>Intent 大致可以分为两种：显式 Intent 和隐式 Intent。</p><h2 id="显式-Intent"><a href="#显式-Intent" class="headerlink" title="显式 Intent"></a>显式 Intent</h2><p>右击 com.example.activitytest 包→New→Activity→Empty Activity，会弹出一个创建 Activity 的对话框，这次命名为 SecondActivity，并勾选 Generate Layout File，给布局文件起名为 second_layout，但要勾选Launcher Activity 选项。</p><p>将 second_layout 里面的代码替换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Button 2&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还是定义了一个按钮，并在按钮上显示 Button 2。</p><p>Intent 有多个构造函数的重载，其中一个是 <code>Intent(Context packageContext, Class cls)</code>。这个构造函数接收两个参数：第一个参数 Context 要求提供一个启动 Activity 的上下文；第二个参数 Class 用于指定想要启动的目标 Activity。Activity 类中提供了一个 <code>startActivity()</code> 方法，专门用于启动 Activity，它接收一个 Intent 参数，这里我们将构建好的 Intent 传入 <code>startActivity()</code> 方法就可以启动目标 Activity 了。</p><p>修改 FirstActivity 中按钮的点击事件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123;</span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line"> startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构建了一个 Intent 对象，第一个参数传入 this 也就是 FirstActivity 作为上下文，第二个参数传入 SecondActivity::class.java 作为目标 Activity。</p><p>重新启动，点击 Button1 即可切换到页面 2。</p><h2 id="隐式-Intent"><a href="#隐式-Intent" class="headerlink" title="隐式 Intent"></a>隐式 Intent</h2><p>相比于显式 Intent，隐式 Intent 则含蓄许多，它并不明确指出想要启动哪一个 Activity，而是指定一系列更为抽象的 action 和 category 等信息，然后由系统去分析这个 Intent，并帮我们找出合适的 Activity 去启动。</p><p>通过在 <code>&lt;activity&gt;</code> 标签下配置的内容，可以指定当前 Activity 能够响应的 action 和 category，打开 AndroidManifest.xml，添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.activitytest.ACTION_START&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有 <code>&lt;action&gt;</code> 和 <code>&lt;category&gt;</code> 中的内容同时匹配 Intent 中指定的 action 和 category 时，这个 Activity 才能响应此 Intent。</p><p>修改 FirstActivity 中按钮的点击事件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.activitytest.ACTION_START&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Intent 的另一个构造函数，直接将 action 的字符串传了进去，表明想要启动能够响应 <code>com.example.activitytest.ACTION_START</code> 这个 action 的 Activity。<code>android.intent.category.DEFAULT</code> 是一种默认的 category， 在调用 <code>startActivity()</code> 方法的时候会自动将这个 category 添加到 Intent 中。</p><p>每个 Intent 中只能指定一个 action，但能指定多个 category。</p><p>修改 FirstActivity 中按钮的点击事件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="string">&quot;com.example.activitytest.ACTION_START&quot;</span>)</span><br><span class="line">    intent.addCategory(<span class="string">&quot;com.example.activitytest.MY_CATEGORY&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以调用 Intent 中的 <code>addCategory()</code> 方法来添加一个 category，同时需要在 <code>&lt;intent-filter&gt;</code> 中添加该 category 的声明。</p><h2 id="使用隐式-Intent-启动其他程序的-Activity"><a href="#使用隐式-Intent-启动其他程序的-Activity" class="headerlink" title="使用隐式 Intent 启动其他程序的 Activity"></a>使用隐式 Intent 启动其他程序的 Activity</h2><p>修改 FirstActivity 中按钮点击事件的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_VIEW)</span><br><span class="line">    intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先指定了 Intent 的 action 是 <code>Intent.ACTION_VIEW</code>，这是一个 Android 系统内置的动作，其常量值为 android.intent.action.VIEW。然后通过 <code>Uri.parse()</code> 方法将一个网址字符串解析成一个 Uri 对象，再调用 Intent 的 <code>setData()</code> 方法将这个 Uri 对象传递进去。</p><p>重新运行程序，在 FirstActivity 界面点击按钮就可以打开系统浏览器。</p><p><img src="4.png" alt=""></p><h2 id="向下一个-Activity-传递数据"><a href="#向下一个-Activity-传递数据" class="headerlink" title="向下一个 Activity 传递数据"></a>向下一个 Activity 传递数据</h2><p>在启动 Activity 时传递数据的思路很简单，Intent 中提供了一系列 <code>putExtra()</code> 方法的重载，可以把我们想要传递的数据暂存在 Intent 中，在启动另一个 Activity 后，只需要把这些数据从 Intent 中取出就可以了。比如FirstActivity 中有一个字符串，现在想把这个字符串传递到 SecondActivity 中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = <span class="string">&quot;Hello SecondActivity&quot;</span></span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    intent.putExtra(<span class="string">&quot;extra_data&quot;</span>, <span class="keyword">data</span>)</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用显式 Intent 的方式来启动 SecondActivity，并通过 <code>putExtra()</code> 方法传递一个字符串。这里 <code>putExtra()</code> 方法接收两个参数，第一个参数是键，用于之后从 Intent 中取值，第二个参数才是真正要传递的数据。</p><p>然后在 SecondActivity 中将传递的数据取出，并打印出来，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.second_layout)</span><br><span class="line">        <span class="keyword">val</span> extraData = intent.getStringExtra(<span class="string">&quot;extra_data&quot;</span>)</span><br><span class="line">        Log.d(<span class="string">&quot;SecondActivity&quot;</span>, <span class="string">&quot;extra data is <span class="variable">$extraData</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行程序，在 FirstActivity 的界面点击一下按钮会跳转到 SecondActivity，查看 Logcat 打印信息：</p><p><img src="5.png" alt=""></p><h2 id="返回数据给上一个-Activity"><a href="#返回数据给上一个-Activity" class="headerlink" title="返回数据给上一个 Activity"></a>返回数据给上一个 Activity</h2><p>Activity 类中还有一个用于启动 Activity 的 <code>startActivityForResult()</code> 方法，但它期望在 Activity 销毁的时候能够返回一个结果给上一个 Activity。</p><p>startActivityForResult() 方法接收两个参数：第一个参数还是 Intent；第二个参数是请求码，用于在之后的回调中判断数据的来源。修改 FirstActivity 中按钮的点击事件，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    startActivityForResult(intent, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SecondActivity 中给按钮注册点击事件，并在点击事件中添加返回数据的逻辑，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.second_layout)</span><br><span class="line">        button2.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent()</span><br><span class="line">            intent.putExtra(<span class="string">&quot;data_return&quot;</span>, <span class="string">&quot;Hello FirstActivity&quot;</span>)</span><br><span class="line">            setResult(RESULT_OK, intent)</span><br><span class="line">            finish()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是构建了一个 Intent，只不过这个 Intent 仅仅用于传递数据，把要传递的数据存放在 Intent 中，然后调用 <code>setResult()</code> 方法。这个方法非常重要，专门用于向上一个 Activity 返回数据。<code>setResult()</code> 方法接收两个参数：第一个参数用于向上一个 Activity 返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这两个值；第二个参数则把带有数据的 Intent 传递回去。最后调用 <code>finish()</code> 方法来销毁当前 Activity。</p><p>由于使用 startActivityForResult() 方法来启动 SecondActivity，在 SecondActivity 被销毁后会回调上一个 Activity 的 <code>onActivityResult()</code> 方法，因此需要在 FirstActivity 中重写该方法来得到返回的数据，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">        <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">            <span class="number">1</span> -&gt; <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">                <span class="keyword">val</span> returnedData = <span class="keyword">data</span>?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)</span><br><span class="line">                Log.d(<span class="string">&quot;FirstActivity&quot;</span>, <span class="string">&quot;returned data is <span class="variable">$returnedData</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>onActivityResult()</code> 方法带有 $3$ 个参数：第一个参数 requestCode，即在启动 Activity 时传入的请求码；第二个参数 resultCode，即在返回数据时传入的处理结果；第三个参数 data，即携带着返回数据的 Intent。由于在一个 Activity 中有可能调用 <code>startActivityForResult()</code> 方法去启动很多不同的 Activity，每一个 Activity 返回的数据都会回调到 <code>onActivityResult()</code> 这个方法中，因此首先要做的就是通过检查 requestCode 的值来判断数据来源；确定数据是从 SecondActivity 返回的之后，再通过 resultCode 的值来判断处理结果是否成功；最后从 data 中取值并打印出来，这样就完成了向上一个 Activity 返回数据的工作。</p><p>重新运行程序，在 FirstActivity 的界面点击按钮会打开 SecondActivity，然后在 SecondActivity 界面点击 Button 2 按钮会回到 FirstActivity，这时查看 Logcat 的打印信息：</p><p><img src="6.png" alt=""></p><p>如果用户在 SecondActivity 中并不是通过点击按钮，而是通过按下 Back 键回到 FirstActivity，我们可以通过在 SecondActivity 中重写 <code>onBackPressed()</code> 方法来向上一个 Activity 传递数据，代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">val</span> intent = Intent()</span><br><span class="line"> intent.putExtra(<span class="string">&quot;data_return&quot;</span>, <span class="string">&quot;Hello FirstActivity&quot;</span>)</span><br><span class="line"> setResult(RESULT_OK, intent)</span><br><span class="line"> finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Activity-的生命周期"><a href="#Activity-的生命周期" class="headerlink" title="Activity 的生命周期"></a>Activity 的生命周期</h1><h2 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h2><p>Android 是使用任务（task）来管理 Activity 的，一个任务就是一组存放在栈里的 Activity 的集合，这个栈也被称作返回栈（back stack）。</p><p>栈是一种后进先出的数据结构，在默认情况 下，每当我们启动了一个新的 Activity，它就会在返回栈中入栈，并处于栈顶的位置。而每当我们按下 Back 键或调用 <code>finish()</code> 方法去销毁一个 Activity 时，处于栈顶的 Activity 就会出栈，前一个入栈的 Activity 就会重新处于栈顶的位置。系统总是会显示处于栈顶的 Activity 给用户。</p><h2 id="Activity-状态"><a href="#Activity-状态" class="headerlink" title="Activity 状态"></a>Activity 状态</h2><p>每个 Activity 在其生命周期中最多可能会有 $4$ 种状态。</p><ul><li><p>运行状态</p><p>当一个 Activity 位于返回栈的栈顶时，Activity 就处于运行状态。系统最不愿意回收的就是处于运行状态的 Activity，因为这会带来非常差的用户体验。</p></li><li><p>暂停状态</p><p>当一个 Activity 不再处于栈顶位置，但仍然可见时，Activity 就进入了暂停状态。可见指的是没有占满整个屏幕，比如对话框形式的 Activity 只会占用屏幕中间的部分区域。处于暂停状态的 Activity 仍然是完全存活着的，系统也不愿意回收这种 Activity（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种 Activity。</p></li><li><p>停止状态</p><p>当一个 Activity 不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种 Activity 保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的 Activity 有可能会被系统回收。</p></li><li><p>销毁状态</p><p>一个 Activity 从返回栈中移除后就变成了销毁状态。系统最倾向于回收处于这种状态的 Activity，以保证手机的内存充足。</p></li></ul><h2 id="Activity-的生存期"><a href="#Activity-的生存期" class="headerlink" title="Activity 的生存期"></a>Activity 的生存期</h2><p>Activity 类中定义了 $7$ 个回调方法，覆盖了 Activity 生命周期的每一个环节。</p><ul><li>onCreate()。它会在 Activity 第一次被创建的时候调用。应该在这个方法中完成 Activity 的初始化操作，比如加载布局、绑定事件等。 </li><li>onStart()。这个方法在 Activity 由不可见变为可见的时候调用。 </li><li>onResume()。这个方法在 Activity 准备好和用户进行交互的时候调用。此时的 Activity 一 定位于返回栈的栈顶，并且处于运行状态。 </li><li>onPause()。这个方法在系统准备去启动或者恢复另一个 Activity 的时候调用。通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶 Activity 的使用。 </li><li>onStop()。这个方法在 Activity 完全不可见的时候调用。它和 onPause() 方法的主要区别在于，如果启动的新 Activity 是一个对话框式的 Activity，那么 onPause() 方法会得到执行，而 onStop() 方法并不会执行。 </li><li>onDestroy()。这个方法在 Activity 被销毁之前调用，之后 Activity 的状态将变为销毁状态。 </li><li>onRestart()。这个方法在 Activity 由停止状态变为运行状态之前调用，也就是 Activity 被重新启动了。</li></ul><p>可以将 Activity 分为以下 $3$ 种生存期：</p><ul><li>完整生存期。Activity 在 onCreate() 方法和 onDestroy() 方法之间所经历的就是完整生存期。一般情况下，一个 Activity 会在 onCreate() 方法中完成各种初始化操作，而在 onDestroy() 方法中完成释放内存的操作。 </li><li>可见生存期。Activity 在 onStart() 方法和 onStop() 方法之间所经历的就是可见生存期。在可见生存期内， Activity 对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法合理地管理那些对用户可见的资源。比如在 onStart() 方法中对资源进行加载，而在 onStop() 方法中对资源进行释放，从而保证处于停止状态的 Activity 不会占用过多内存。 </li><li>前台生存期。Activity 在 onResume() 方法和 onPause() 方法之间所经历的就是前台生存期。在前台生存期内，Activity 总是处于运行状态，此时的 Activity 是可以和用户进行交互的，我们平时看到和接触最多的就是这个状态下的 Activity。</li></ul><p>Android 官方提供了一张 Activity 生命周期的示意图：</p><p><img src="7.png" alt=""></p><h2 id="Activity-被回收了怎么办"><a href="#Activity-被回收了怎么办" class="headerlink" title="Activity 被回收了怎么办"></a>Activity 被回收了怎么办</h2><p>假设应用中有一个 Activity A，用户在 Activity A 的基础上启动了 Activity B，Activity A 就进入了 停止状态，这个时候由于系统内存不足，将 Activity A 回收掉了，然后用户按下 Back 键返回 Activity A，会出现什么情况呢？其实还是会正常显示 Activity A 的，只不过这时并不会执行 onRestart() 方法，而是会执行 Activity A 的 <code>onCreate()</code> 方法，因为 Activity A 在这种情况下会被重新创建一次。</p><p>但是有一个问题，Activity A 中是可能存在临时数据和状态的，所以要想办法保存一些重要信息。Activity 中提供了一个 <code>onSaveInstanceState()</code> 回调方法，这个方法可以保证在 Activity 被回收之前一定会被调用。</p><p><code>onSaveInstanceState()</code> 方法会携带一个 Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如可以使用 putString() 方法保存字符串，使用 putInt() 方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从 Bundle 中取值，第二个参数是真正要保存的内容。</p><p>在 Activity 中添加如下代码就可以将临时数据保存：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line"> <span class="keyword">val</span> tempData = <span class="string">&quot;Something you just typed&quot;</span></span><br><span class="line"> outState.putString(<span class="string">&quot;data_key&quot;</span>, tempData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一直使用的 <code>onCreate()</code> 方法有一个 Bundle 类型的参数。这个参数一般都是 null，但是如果在 Activity 被系统回收之前通过 <code>onSaveInstanceState()</code> 方法保存数据，这个参数就会带有之前保存的全部数据。</p><p>修改 Activity 的 <code>onCreate()</code> 方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line"> <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"> Log.d(tag, <span class="string">&quot;onCreate&quot;</span>)</span><br><span class="line"> setContentView(R.layout.activity_main)</span><br><span class="line"> <span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">val</span> tempData = savedInstanceState.getString(<span class="string">&quot;data_key&quot;</span>)</span><br><span class="line"> Log.d(tag, <span class="string">&quot;tempData is <span class="variable">$tempData</span>&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Intent 还可以结合 Bundle 一起用于传递数据。首先我们可以把需要传递的数据都保存在 Bundle 对象中，然后再将 Bundle 对象存放在 Intent 里。到了目标 Activity 之后，先从 Intent 中取出 Bundle，再从 Bundle 中一一取出数据。</p><h2 id="Activity-的启动模式"><a href="#Activity-的启动模式" class="headerlink" title="Activity 的启动模式"></a>Activity 的启动模式</h2><p>启动模式一共有 $4$ 种，分别是 standard、singleTop、 singleTask 和 singleInstance，可以在 AndroidManifest.xml 中通过给标签指定 <code>android:launchMode</code> 属性来选择启动模式。</p><ul><li><p>standard</p><p>standard 是 Activity 默认的启动模式，对于使用 standard 模式的 Activity，系统不会在乎这个 Activity 是否已经在返回栈中存在，每次启动都会创建一个该 Activity 的新实例。</p></li><li><p>singleTop</p><p>当 Activity 的启动模式指定为 singleTop，在启动 Activity 时如果发现返回栈的栈顶已经是该 Activity，则认为可以直接使用它，不会再创建新的 Activity 实例。</p></li><li><p>singleTask</p><p>当 Activity 的启动模式指定为 singleTask，每次启动该 Activity 时， 系统首先会在返回栈中检查是否存在该Activity 的实例，如果发现已经存在则直接使用该实例， 并把在这个 Activity 之上的所有其他 Activity 统统出栈，如果没有发现就会创建一个新的 Activity 实例。</p></li><li><p>singleInstance</p><p>指定为 singleInstance 模式的 Activity 会启用一个新的返回栈来管理这个 Activity。</p></li></ul><h1 id="实践技巧"><a href="#实践技巧" class="headerlink" title="实践技巧"></a>实践技巧</h1><h2 id="知晓当前在哪一个Activity"><a href="#知晓当前在哪一个Activity" class="headerlink" title="知晓当前在哪一个Activity"></a>知晓当前在哪一个Activity</h2><p>根据程序当前的界面就能判断出这是哪一个 Activity。</p><p>要新建一个 BaseActivity 类，然后让 BaseActivity 继承自 AppCompatActivity ，并重写 onCreate() 方法，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(<span class="string">&quot;BaseActivity&quot;</span>, javaClass.simpleName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是获取了当前实例的 Class对象，然后再调用 simpleName 获取当前实例的类名。</p><p>接下来需要让 BaseActivity 成为 ActivityTest 项目中所有 Activity 的父类，为了使 BaseActivity 可以被继承，在类名的前面加上 open 关键字。然后修改 FirstActivity、SecondActivity 的继承结构，让它们不再继承自 AppCompatActivity，而是继承自 BaseActivity。而由于 BaseActivity 继承自 AppCompatActivity，所以项目中所有 Activity 的现有功能并不受影响。</p><h2 id="随时随地退出程序"><a href="#随时随地退出程序" class="headerlink" title="随时随地退出程序"></a>随时随地退出程序</h2><p>用一个专门的集合对所有的 Activity 进行管理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> ActivityCollector &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activities = ArrayList&lt;Activity&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activities.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        activities.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">finishAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (activity <span class="keyword">in</span> activities) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing) &#123;</span><br><span class="line">                activity.finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activities.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了单例类，是因为全局只需要一个 Activity 集合。在集合中通过一个 ArrayList 来暂存 Activity，然后提供了一个 <code>addActivity()</code> 方法，用于向 ArrayList 中添加 Activity；提供了一个 <code>removeActivity()</code> 方法，用于从 ArrayList 中移除 Activity；最后提供了一个 <code>finishAll()</code> 方法，用于将 ArrayList 中存储的 Activity 全部销毁。注意在销毁Activity之前， 我们需要先调用 <code>activity.isFinishing</code> 来判断 Activity 是否正在销毁中，因为 Activity 还可能通过按下 Back 键等方式被销毁，如果该 Activity 没有正在销毁中，我们再去调用它的 <code>finish()</code> 方法来销毁它。</p><p>接下来修改 BaseActivity 中的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(<span class="string">&quot;BaseActivity&quot;</span>, javaClass.simpleName)</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 ThirdActivity 界面想通过点击按钮直接退出程序，只需将代码改成如下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(<span class="string">&quot;ThirdActivity&quot;</span>, <span class="string">&quot;Task id is <span class="variable">$taskId</span>&quot;</span>)</span><br><span class="line">        setContentView(R.layout.activity_third)</span><br><span class="line">        button3.setOnClickListener &#123;</span><br><span class="line">            ActivityCollector.finishAll()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以在销毁所有 Activity 的代码后面再加上杀掉当前进程的代码，以保证程序完全退出，杀掉进程的代码如下所示： </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.os.Process.killProcess(android.os.Process.myPid())</span><br></pre></td></tr></table></figure><p><code>killProcess()</code> 方法用于杀掉一个进程，它接收一个进程 id 参数，我们可以通过 <code>myPid()</code> 方法来获得当前程序的进程 id。需要注意的是，killProcess() 方法只能用于杀掉当前程序的进程，不能用于杀掉其他程序。</p><h2 id="启动-Activity-的最佳写法"><a href="#启动-Activity-的最佳写法" class="headerlink" title="启动 Activity 的最佳写法"></a>启动 Activity 的最佳写法</h2><p>假设 SecondActivity 中需要用到两个非常重要的字符串参数，在启动 SecondActivity 的时候必须传递过来，那么很容易会写出如下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data1&quot;</span>)</span><br><span class="line">intent.putExtra(<span class="string">&quot;param2&quot;</span>, <span class="string">&quot;data2&quot;</span>)</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure><p>但由于工作对接问题有时不知道 SecondActivity 需要传递哪些数据，SecondActivity 中添加代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>, data1: <span class="type">String</span>, data2: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(context, SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param1&quot;</span>, data1)</span><br><span class="line">        intent.putExtra(<span class="string">&quot;param2&quot;</span>, data2)</span><br><span class="line">        context.startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了一个新的语法结构 companion object，并在 companion object 中定义了一个 <code>actionStart()</code> 方法。Kotlin 规定，所有定义在 companion object 中的方法都可以使用类似于 Java 静态方法的形式调用。<code>actionStart()</code> 方法完成了 Intent 的构建，另外所有 SecondActivity 中需要的数据都是通过 <code>actionStart()</code> 方法的参数传递过来的，然后把它们存储到 Intent 中，最后调用 startActivity() 方法启动 SecondActivity。</p><p>这样写还简化了启动 Activity 的代码，现在只需要一行代码就可以启动 SecondActivity， 如下所示： </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener &#123; SecondActivity.actionStart(<span class="keyword">this</span>, <span class="string">&quot;data1&quot;</span>, <span class="string">&quot;data2&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><p>[1] 郭霖 ：第一行代码 Android（第3版)）. 北京：人民邮电出版社，2020</p><p>[2] <a href="https://kotlinlang.org/docs/home.html">Kotlin docs | Kotlin (kotlinlang.org)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Activity-的基本用法&quot;&gt;&lt;a href=&quot;#Activity-的基本用法&quot; class=&quot;headerlink&quot; title=&quot;Activity 的基本用法&quot;&gt;&lt;/a&gt;Activity 的基本用法&lt;/h1&gt;&lt;h2 id=&quot;创建-A</summary>
      
    
    
    
    <category term="Android" scheme="http://10185102110.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://10185102110.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>设计一个加密算法</title>
    <link href="http://10185102110.github.io/2021/10/14/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://10185102110.github.io/2021/10/14/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-14T11:24:56.000Z</published>
    <updated>2021-10-22T14:55:13.209Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>密钥为一个随机密码本中的一个随机段落，以下步骤采用同一密钥。</p><ul><li><p>先采用维吉尼亚(Vigenere)表的一次密码本加密。</p><p>Vigenere 表：</p><p><img src="0.png" alt=""></p><p>加密示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">密钥(列选择器)：iamie   xistt   hatis   cert</span><br><span class="line">明文(行选择器)：MACHI   NESCA   NNOTT   HINK</span><br><span class="line">密文(表中的值)：uaopm   kmkvt   unhbl   jmed</span><br></pre></td></tr></table></figure></li><li><p>再采用带密钥的简单列置换算法对第一步得到的密文加密，行入列出。</p><p>加密示例：</p><p>假设明文为：endalen is bordered on the northwest by the municipalities of alvdal and tynset</p><ol><li>选取密钥，比如 sample。（以此确定矩阵每行字符数以及输出列选择顺序。如有相同字母，保留最左边，其他剔除）。</li><li>按照密钥 sample 中各字母的排列顺序来确定输出列选择顺序。（字母表排列在前的值小），sample 对应的输出列选择顺序为：614532。</li><li>按密钥长度按行写明文为如下（去掉空格），最末一行如不足一行，随便添点数据。</li><li>按 614532 顺序按列读下面的矩阵，得到密文：niettbuasdtaerooseiilneelodnehctaasddsrhhynloaybabeewtiiflncendnrtmpevdt</li><li>解密时，将密文按 614532 顺序按列填写矩阵，然后按行读取即是明文。</li></ol><p><img src="1.png" alt=""></p></li><li><p>解密时，先用列入行出的列置换算法解密，再用 Vigenere 表解密。</p></li></ul><h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><ul><li>Windows 10</li><li>JDK 1.8.0_301</li></ul><h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><p>主要函数功能说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成维吉尼亚表</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FixVigenere</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//加密，明文仅支持大写字母</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">Encode</span><span class="params">(String s,String password)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//解密，密文仅支持小写字母</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">Decode</span><span class="params">(String s,String password)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//得到列选择顺序</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] <span class="title">MySort</span><span class="params">(String password)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//随机生成密钥</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">GeneratePassword</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">char</span>[][] vigenere = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String lowStr = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> colleft; <span class="comment">//列置换时记录最后一行应有的字符个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成维吉尼亚表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FixVigenere</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                vigenere[i][j-i] = lowStr.charAt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            j = j-i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">                vigenere[i][j++] = lowStr.charAt(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">Encode</span><span class="params">(String s,String password)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先替换密码</span></span><br><span class="line">        String ss = s.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = ss.length(); <span class="comment">//明文长度</span></span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = ss.charAt(index)-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> col = password.charAt(index % password.length())-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            str.append(vigenere[row][col]);</span><br><span class="line">            length--;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后置换密码，行入列出</span></span><br><span class="line">        String sss = str.toString();</span><br><span class="line">        <span class="keyword">int</span>[] arr = MySort(password);</span><br><span class="line">        <span class="keyword">int</span> rowlen = (<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)sss.length()/arr.length);</span><br><span class="line">        colleft = sss.length() % arr.length;</span><br><span class="line">        <span class="keyword">char</span>[][] ColChange = <span class="keyword">new</span> <span class="keyword">char</span>[rowlen][arr.length];</span><br><span class="line">        <span class="comment">//最后一行的空位填充</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-colleft;i++)&#123;</span><br><span class="line">            ColChange[ColChange.length-<span class="number">1</span>][colleft+i] = (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sss.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row = i / arr.length;</span><br><span class="line">            <span class="keyword">int</span> col = i % arr.length;</span><br><span class="line">            ColChange[row][col] = sss.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        ArrayList&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr)&#123;</span><br><span class="line">            l.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sssindex = <span class="number">0</span>;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr.length;i++)&#123;</span><br><span class="line">            index = l.indexOf(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ColChange.length;j++)&#123;</span><br><span class="line">                ans.append(ColChange[j][index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解密</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">Decode</span><span class="params">(String s,String password)</span></span>&#123;</span><br><span class="line">        String sss = s.replaceAll(<span class="string">&quot; &quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//置换密码，列入行出</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = MySort(password);</span><br><span class="line">        <span class="keyword">int</span> rowlen = sss.length()/arr.length;</span><br><span class="line">        <span class="keyword">char</span>[][] ColChange = <span class="keyword">new</span> <span class="keyword">char</span>[rowlen][arr.length];</span><br><span class="line">        ArrayList&lt;Integer&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:arr)&#123;</span><br><span class="line">            l.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sssindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = l.indexOf(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ColChange.length;j++)&#123;</span><br><span class="line">                ColChange[j][index] = sss.charAt(sssindex++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ColChange.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                ans.append(ColChange[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;colleft;i++)&#123;</span><br><span class="line">            ans.append(ColChange[ColChange.length-<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//替换密码</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        String ss = ans.toString();</span><br><span class="line">        <span class="keyword">int</span> length = ss.length();</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> key = password.charAt(index % password.length());</span><br><span class="line">            <span class="keyword">int</span> col = key-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">char</span> mi = ss.charAt(index);</span><br><span class="line">            <span class="keyword">char</span> ming;</span><br><span class="line">            <span class="keyword">if</span>(mi&gt;=key)&#123;</span><br><span class="line">                ming = (<span class="keyword">char</span>)(mi-key+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ming = (<span class="keyword">char</span>)(<span class="string">&#x27;Z&#x27;</span>-(key-mi-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(ming);</span><br><span class="line">            length--;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到列选择顺序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MySort(String password)&#123;</span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;password.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = password.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(c)) list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Character ch : list) &#123;</span><br><span class="line">            str.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        String s = str.toString();</span><br><span class="line">        <span class="comment">//System.out.println(s);</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            arr[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j)&gt;s.charAt(i))&#123;</span><br><span class="line">                    arr[j]++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    arr[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//随机生成密钥</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">GeneratePassword</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10</span>, n = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> length = (<span class="keyword">int</span>)(Math.random()*(n-m)+m);</span><br><span class="line">        StringBuffer password = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>)(Math.random()*<span class="number">26</span>);</span><br><span class="line">            password.append(lowStr.charAt(index));</span><br><span class="line">            length--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> password.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成维吉尼亚表</span></span><br><span class="line">        FixVigenere();</span><br><span class="line">        <span class="comment">//随机生成密钥</span></span><br><span class="line">        String password = GeneratePassword();</span><br><span class="line"></span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;密码 @AveBai 2021/10/16&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">850</span>, <span class="number">600</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建中间容器（面板容器）</span></span><br><span class="line">        JSplitPane splitPane = <span class="keyword">new</span> JSplitPane();</span><br><span class="line">        JPanel panel1 = <span class="keyword">new</span> JPanel(<span class="keyword">null</span>);</span><br><span class="line">        JPanel panel2 = <span class="keyword">new</span> JPanel(<span class="keyword">null</span>);</span><br><span class="line">        splitPane.setLeftComponent(panel1);</span><br><span class="line">        splitPane.setRightComponent(panel2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          加密界面</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        JLabel label1 = <span class="keyword">new</span> JLabel();</span><br><span class="line">        label1.setBounds(<span class="number">20</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">50</span>);</span><br><span class="line">        label1.setText(<span class="string">&quot;输入明文:&quot;</span>);</span><br><span class="line">        label1.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, Font.BOLD, <span class="number">20</span>));</span><br><span class="line">        label1.setForeground(Color.BLUE);</span><br><span class="line">        panel1.add(label1);</span><br><span class="line"></span><br><span class="line">        JLabel label3 = <span class="keyword">new</span> JLabel();</span><br><span class="line">        label3.setBounds(<span class="number">20</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">50</span>);</span><br><span class="line">        label3.setText(<span class="string">&quot;友情提示:仅支持大写字母&quot;</span>);</span><br><span class="line">        label3.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, Font.PLAIN, <span class="number">16</span>));</span><br><span class="line">        panel1.add(label3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文本区域组件</span></span><br><span class="line">        JTextArea textArea1 = <span class="keyword">new</span> JTextArea();</span><br><span class="line">        textArea1.setLineWrap(<span class="keyword">true</span>);                         <span class="comment">// 自动换行</span></span><br><span class="line">        textArea1.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        JTextArea textArea2 = <span class="keyword">new</span> JTextArea();</span><br><span class="line">        textArea2.setLineWrap(<span class="keyword">true</span>);                         <span class="comment">// 自动换行</span></span><br><span class="line">        textArea2.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建滚动面板</span></span><br><span class="line">        JScrollPane scrollPane1 = <span class="keyword">new</span> JScrollPane(</span><br><span class="line">                textArea1,</span><br><span class="line">                ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,</span><br><span class="line">                ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER</span><br><span class="line">        );</span><br><span class="line">        scrollPane1.setBounds(<span class="number">20</span>,<span class="number">50</span>,<span class="number">350</span>,<span class="number">150</span>);</span><br><span class="line">        panel1.add(scrollPane1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文本区域组件</span></span><br><span class="line">        JTextArea textArea3 = <span class="keyword">new</span> JTextArea();</span><br><span class="line">        textArea3.setLineWrap(<span class="keyword">true</span>);                         <span class="comment">// 自动换行</span></span><br><span class="line">        textArea3.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        JTextArea textArea4 = <span class="keyword">new</span> JTextArea();</span><br><span class="line">        textArea4.setLineWrap(<span class="keyword">true</span>);                         <span class="comment">// 自动换行</span></span><br><span class="line">        textArea4.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加密按钮</span></span><br><span class="line">        <span class="keyword">final</span> JButton btn1 = <span class="keyword">new</span> JButton(<span class="string">&quot;加密&quot;</span>);</span><br><span class="line">        btn1.setBounds(<span class="number">20</span>,<span class="number">260</span>,<span class="number">80</span>,<span class="number">35</span>);</span><br><span class="line">        btn1.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line">        btn1.setForeground(Color.BLUE);</span><br><span class="line">        btn1.setContentAreaFilled(<span class="keyword">false</span>);</span><br><span class="line">        btn1.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                textArea3.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                textArea3.append(Encode(textArea1.getText(),password));</span><br><span class="line">                textArea2.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                textArea2.append(textArea3.getText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel1.add(btn1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建滚动面板</span></span><br><span class="line">        JScrollPane scrollPane3 = <span class="keyword">new</span> JScrollPane(</span><br><span class="line">                textArea3,</span><br><span class="line">                ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,</span><br><span class="line">                ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER</span><br><span class="line">        );</span><br><span class="line">        scrollPane3.setBounds(<span class="number">20</span>,<span class="number">320</span>,<span class="number">350</span>,<span class="number">150</span>);</span><br><span class="line">        panel1.add(scrollPane3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          解密界面</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        JLabel label2 = <span class="keyword">new</span> JLabel();</span><br><span class="line">        label2.setBounds(<span class="number">20</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">50</span>);</span><br><span class="line">        label2.setText(<span class="string">&quot;输入密文:&quot;</span>);</span><br><span class="line">        label2.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, Font.BOLD, <span class="number">20</span>));</span><br><span class="line">        label2.setForeground(Color.BLUE);</span><br><span class="line">        panel2.add(label2);</span><br><span class="line"></span><br><span class="line">        JLabel label4 = <span class="keyword">new</span> JLabel();</span><br><span class="line">        label4.setBounds(<span class="number">20</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">50</span>);</span><br><span class="line">        label4.setText(<span class="string">&quot;友情提示:仅支持小写字母&quot;</span>);</span><br><span class="line">        label4.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, Font.PLAIN, <span class="number">16</span>));</span><br><span class="line">        panel2.add(label4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建滚动面板</span></span><br><span class="line">        JScrollPane scrollPane2 = <span class="keyword">new</span> JScrollPane(</span><br><span class="line">                textArea2,</span><br><span class="line">                ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,</span><br><span class="line">                ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER</span><br><span class="line">        );</span><br><span class="line">        scrollPane2.setBounds(<span class="number">20</span>,<span class="number">50</span>,<span class="number">350</span>,<span class="number">150</span>);</span><br><span class="line">        panel2.add(scrollPane2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//解密按钮</span></span><br><span class="line">        <span class="keyword">final</span> JButton btn2 = <span class="keyword">new</span> JButton(<span class="string">&quot;解密&quot;</span>);</span><br><span class="line">        btn2.setBounds(<span class="number">20</span>,<span class="number">260</span>,<span class="number">80</span>,<span class="number">35</span>);</span><br><span class="line">        btn2.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;楷体&quot;</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line">        btn2.setForeground(Color.BLUE);</span><br><span class="line">        btn2.setContentAreaFilled(<span class="keyword">false</span>);</span><br><span class="line">        btn2.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                textArea4.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                textArea4.append(Decode(textArea2.getText(),password));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel2.add(btn2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建滚动面板</span></span><br><span class="line">        JScrollPane scrollPane4 = <span class="keyword">new</span> JScrollPane(</span><br><span class="line">                textArea4,</span><br><span class="line">                ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,</span><br><span class="line">                ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER</span><br><span class="line">        );</span><br><span class="line">        scrollPane4.setBounds(<span class="number">20</span>,<span class="number">320</span>,<span class="number">350</span>,<span class="number">150</span>);</span><br><span class="line">        panel2.add(scrollPane4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分隔条上显示快速 折叠/展开 两边组件的小按钮</span></span><br><span class="line">        splitPane.setOneTouchExpandable(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 拖动分隔条时连续重绘组件</span></span><br><span class="line">        splitPane.setContinuousLayout(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置分隔条的初始位置</span></span><br><span class="line">        splitPane.setDividerLocation(<span class="number">400</span>);</span><br><span class="line">        <span class="comment">// 把分隔面板作为内容面板添加到窗口并显示</span></span><br><span class="line">        jf.setContentPane(splitPane);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        textArea1.append(<span class="string">&quot;MACHINESCANNOTTHINK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="2.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;p&gt;密钥为一个随机密码本中的一个随机段落，以下步骤采用同一密钥。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先采用维吉尼亚(Vi</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="信息安全" scheme="http://10185102110.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java swing</title>
    <link href="http://10185102110.github.io/2021/10/14/Java%20swing/"/>
    <id>http://10185102110.github.io/2021/10/14/Java%20swing/</id>
    <published>2021-10-14T08:51:52.000Z</published>
    <updated>2021-10-17T15:39:29.457Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Swing 是 Java 为图形界面应用开发提供的一组工具包，是 Java 基础类的一部分。</p><p>Swing 包含了构建图形界面（GUI）的各种组件，如: 窗口、标签、按钮、文本框等。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>一个 Java 的图形界面，由各种不同类型的“元素”组成，例如: 窗口、菜单栏、对话框、标签、按钮、文本框等等，这些“元素”统一被称为组件（Component）。</p><p>组件按照不同的功能，可分为顶层容器、中间容器、基本组件。一个简单窗口的组成，如下层级结构所示:</p><ul><li>顶层容器<ul><li>菜单栏</li><li>中间容器<ul><li>基本组件</li><li>基本组件</li></ul></li></ul></li></ul><p>组件类型的继承关系:</p><ol><li>顶层容器属于窗口类组件，继承自 java.awt.Window；</li><li>中间容器和基本组件 继承自 javax.swing.JComponent。</li></ol><h3 id="顶层容器"><a href="#顶层容器" class="headerlink" title="顶层容器"></a>顶层容器</h3><p>顶层容器属于窗口类组件，可以独立显示，一个图形界面至少需要一个窗口，例如:</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>组件</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>JFrame</td><td>一个普通的窗口（绝大多数 Swing 图形界面程序使用 JFrame 作为顶层容器）</td></tr><tr><td style="text-align:center">2</td><td>JDialog</td><td>对话框</td></tr></tbody></table></div><h3 id="中间容器"><a href="#中间容器" class="headerlink" title="中间容器"></a>中间容器</h3><p>中间容器充当基本组件的载体，不可独立显示。中间容器可以添加若干基本组件（也可以嵌套添加中间容器），对容器内的组件进行管理，类似于给各种复杂的组件进行分组管理。最顶层的一个中间容器必须依托在顶层容器（窗口）内。</p><p>常用的中间容器（面板）:</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>组件</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>JPanel</td><td>一般轻量级面板容器组件</td></tr><tr><td style="text-align:center">2</td><td>JScrollPane</td><td>带滚动条的，可以水平和垂直滚动的面板组件</td></tr><tr><td style="text-align:center">3</td><td>JSplitPane</td><td>分隔面板</td></tr><tr><td style="text-align:center">4</td><td>JTabbedPane</td><td>选项卡面板</td></tr><tr><td style="text-align:center">5</td><td>JLayeredPane</td><td>层级面板</td></tr></tbody></table></div><p>特殊的中间容器：</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>组件</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>JMenuBar</td><td>菜单栏</td></tr><tr><td style="text-align:center">2</td><td>JToolBar</td><td>工具栏</td></tr><tr><td style="text-align:center">3</td><td>JPopupMenu</td><td>弹出菜单</td></tr><tr><td style="text-align:center">4</td><td>JInternalFrame</td><td>内部窗口</td></tr></tbody></table></div><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p>基本组件是直接实现人机交互的组件。</p><p>常用的简单的基本组件:</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>组件</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>JLabel</td><td>标签</td></tr><tr><td style="text-align:center">2</td><td>JButton</td><td>按钮</td></tr><tr><td style="text-align:center">3</td><td>JRadioButton</td><td>单选按钮</td></tr><tr><td style="text-align:center">4</td><td>JCheckBox</td><td>复选框</td></tr><tr><td style="text-align:center">5</td><td>JToggleButton</td><td>开关按钮</td></tr><tr><td style="text-align:center">6</td><td>JTextField</td><td>文本框</td></tr><tr><td style="text-align:center">7</td><td>JPasswordField</td><td>密码框</td></tr><tr><td style="text-align:center">8</td><td>JTextArea</td><td>文本区域</td></tr><tr><td style="text-align:center">9</td><td>JComboBox</td><td>下拉列表框</td></tr><tr><td style="text-align:center">10</td><td>JList</td><td>列表</td></tr><tr><td style="text-align:center">11</td><td>JProgressBar</td><td>进度条</td></tr><tr><td style="text-align:center">12</td><td>JSlider</td><td>滑块</td></tr></tbody></table></div><p>选取器组件：</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>组件</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>JFileChooser</td><td>文件选取器</td></tr><tr><td style="text-align:center">2</td><td>JColorChooser</td><td>颜色选取器</td></tr></tbody></table></div><p>其他较为复杂的基本组件：</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>组件</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>JTable</td><td>表格</td></tr><tr><td style="text-align:center">2</td><td>JTree</td><td>树</td></tr></tbody></table></div><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><p>把 <code>Swing</code> 的各种组件(<code>JComponent</code>)添加到面板容器中(<code>JPanel</code>)，需要给面板容器指定布局管理器(<code>LayoutManager</code>)，明确容器(<code>Container</code>)内的各个组件之间的排列布局方式。</p><p>常用的布局管理器：</p><div class="table-container"><table><thead><tr><th style="text-align:center">#</th><th>布局管理器</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>FlowLayout</td><td>流式布局，按组件加入的顺序，按水平方向排列，排满一行换下一行继续排列。</td></tr><tr><td style="text-align:center">2</td><td>GridLayout</td><td>网格布局，把<code>Container</code>按指定行列数分隔出若干网格，每一个网格按顺序放置一个控件。</td></tr><tr><td style="text-align:center">3</td><td>GridBagLayout</td><td>网格袋布局，按网格划分<code>Container</code>，每个组件可占用一个或多个网格，可将组件垂直、水平或沿它们的基线对齐。</td></tr><tr><td style="text-align:center">4</td><td>BoxLayout</td><td>箱式布局，将<code>Container</code>中的多个组件按 水平 或 垂直 的方式排列。</td></tr><tr><td style="text-align:center">5</td><td>GroupLayout</td><td>分组布局，将组件按层次分组（串行 或 并行），分别确定 组件组 在 水平 和 垂直 方向上的位置。</td></tr><tr><td style="text-align:center">6</td><td>CardLayout</td><td>卡片布局，将<code>Container</code>中的每个组件看作一张卡片，一次只能显示一张卡片，默认显示第一张卡片。</td></tr><tr><td style="text-align:center">7</td><td>BorderLayout</td><td>边界布局，把<code>Container</code>按方位分为 5 个区域（东、西、南、北、中），每个区域放置一个组件。</td></tr><tr><td style="text-align:center">8</td><td>SpringLayout</td><td>弹性布局，通过定义组件四条边的坐标位置来实现布局。</td></tr><tr><td style="text-align:center">9</td><td>null</td><td>绝对布局，通过设置组件在<code>Container</code>中的<strong>坐标位置</strong>来放置组件。</td></tr></tbody></table></div><p>若采用绝对布局，给组件设置坐标和宽高的方法（方法定义在 Component 组件基类中）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置组件的坐标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point p)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件的宽高</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSize</span><span class="params">(Dimension d)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件的界限（一次性设置组件的 坐标 和 宽高）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBounds</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBounds</span><span class="params">(Rectangle rect)</span></span></span><br></pre></td></tr></table></figure><h2 id="一个简单的窗口程序"><a href="#一个简单的窗口程序" class="headerlink" title="一个简单的窗口程序"></a>一个简单的窗口程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个顶层容器（窗口）</span></span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);        </span><br><span class="line">        jf.setSize(<span class="number">700</span>, <span class="number">500</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);  <span class="comment">// 把窗口位置设置到屏幕中心</span></span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); </span><br><span class="line">        <span class="comment">// 当点击窗口的关闭按钮时退出程序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建中间容器（面板容器）</span></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个基本组件（按钮），并添加到 面板容器 中</span></span><br><span class="line">        JButton btn = <span class="keyword">new</span> JButton(<span class="string">&quot;测试按钮&quot;</span>);</span><br><span class="line">        panel.add(btn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把面板容器作为窗口的内容面板 设置到 窗口</span></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示窗口</span></span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaSwing-面板组件"><a href="#JavaSwing-面板组件" class="headerlink" title="JavaSwing 面板组件"></a>JavaSwing 面板组件</h1><h2 id="JPanel（面板）"><a href="#JPanel（面板）" class="headerlink" title="JPanel（面板）"></a>JPanel（面板）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JPanel.html">javax.swing.JPanel</a></p><p>JPanel 常用构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建默认使用流式布局的面板</span></span><br><span class="line">JPanel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建指定布局管理器的面板</span></span><br><span class="line">JPanel(LayoutManager layout)</span><br></pre></td></tr></table></figure><h2 id="JScrollPane（滚动面板）"><a href="#JScrollPane（滚动面板）" class="headerlink" title="JScrollPane（滚动面板）"></a>JScrollPane（滚动面板）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JScrollPane.html">javax.swing.JScrollPane</a></p><p>JScrollPane 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * view: 需要滚动显示的视图组件</span></span><br><span class="line"><span class="comment"> * vsbPolicy: 垂直滚动条的显示策略</span></span><br><span class="line"><span class="comment"> * hsbPolicy: 水平滚动条的显示策略</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   JScrollPane()</span><br><span class="line"></span><br><span class="line">JScrollPane(Component view)</span><br><span class="line"></span><br><span class="line">JScrollPane(Component view, <span class="keyword">int</span> vsbPolicy, <span class="keyword">int</span> hsbPolicy)</span><br><span class="line"></span><br><span class="line">JScrollPane(<span class="keyword">int</span> vsbPolicy, <span class="keyword">int</span> hsbPolicy)</span><br></pre></td></tr></table></figure><p>滚动条的显示策略的取值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 垂直滚动条（vsbPolicy）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED    <span class="comment">// 需要时显示（默认）</span></span><br><span class="line">   ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER        <span class="comment">// 从不显示</span></span><br><span class="line">   ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS       <span class="comment">// 总是显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 水平滚动条（hsbPolicy）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED  <span class="comment">// 需要时显示（默认）</span></span><br><span class="line">   ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER      <span class="comment">// 从不显示</span></span><br><span class="line">   ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS     <span class="comment">// 总是显示</span></span><br></pre></td></tr></table></figure><p>JScrollPane 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置滚动显示视图内容组件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setViewportView</span><span class="params">(Component view)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置垂直滚动条的显示策略</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setVerticalScrollBarPolicy</span><span class="params">(<span class="keyword">int</span> policy)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置水平滚动条的显示策略</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHorizontalScrollBarPolicy</span><span class="params">(<span class="keyword">int</span> policy)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 是否响应鼠标滚动事件，默认响应</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWheelScrollingEnabled</span><span class="params">(<span class="keyword">boolean</span> handleWheel)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文本区域组件</span></span><br><span class="line">        JTextArea textArea = <span class="keyword">new</span> JTextArea();</span><br><span class="line">        textArea.setLineWrap(<span class="keyword">true</span>);                         <span class="comment">// 自动换行</span></span><br><span class="line">        textArea.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">18</span>));   <span class="comment">// 设置字体</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建滚动面板, 指定滚动显示的视图组件(textArea), 垂直滚动条一直显示, 水平滚动条从不显示</span></span><br><span class="line">        JScrollPane scrollPane = <span class="keyword">new</span> JScrollPane(</span><br><span class="line">                textArea,</span><br><span class="line">                ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,</span><br><span class="line">                ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(scrollPane);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\10.png" alt="10"></p><h2 id="JSplitPane（分隔面板）"><a href="#JSplitPane（分隔面板）" class="headerlink" title="JSplitPane（分隔面板）"></a>JSplitPane（分隔面板）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JSplitPane.html">javax.swing.JSplitPane</a></p><p>JSplitPane 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * orientation: 分隔的方向，取值 JSplitPane.HORIZONTAL_SPLIT（水平左右分隔） </span></span><br><span class="line"><span class="comment"> * 或 JSplitPane.VERTICAL_SPLIT（垂直上下分隔），默认水平左右分隔。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * continuousLayout: 拖动分隔条时，是否连续重绘组件，如果为flase，则拖动分隔条停止后才重绘组件。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * leftComponent: 左边/上面 显示的组件</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * rightComponent: 右边/下面 显示的组件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   JSplitPane()</span><br><span class="line"></span><br><span class="line">JSplitPane(<span class="keyword">int</span> orientation)</span><br><span class="line"></span><br><span class="line">JSplitPane(<span class="keyword">int</span> orientation, <span class="keyword">boolean</span> continuousLayout)</span><br><span class="line"></span><br><span class="line">JSplitPane(<span class="keyword">int</span> orientation, <span class="keyword">boolean</span> continuousLayout, Component leftComponent, Component rightComponent)</span><br><span class="line"></span><br><span class="line">JSplitPane(<span class="keyword">int</span> orientation, Component leftComponent, Component rightComponent)</span><br></pre></td></tr></table></figure><p>JSplitPane 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置分隔的方向，水平(左右) 或 垂直(上下) 分隔</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOrientation</span><span class="params">(<span class="keyword">int</span> orientation)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置 左边/上面 显示的组件（下面两个方法完全一致）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLeftComponent</span><span class="params">(Component comp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTopComponent</span><span class="params">(Component comp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置 左边/下面 显示的组件（下面两个方法完全一致）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRightComponent</span><span class="params">(Component comp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBottomComponent</span><span class="params">(Component comp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置 拖动分隔条 时是否 连续重绘 组件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContinuousLayout</span><span class="params">(<span class="keyword">boolean</span> continuousLayout)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 分隔条上是否显示快速 折叠/展开 两边组件的小按钮</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOneTouchExpandable</span><span class="params">(<span class="keyword">boolean</span> newValue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置分隔条的大小（宽度）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDividerSize</span><span class="params">(<span class="keyword">int</span> newSize)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置分隔条的位置，相对于 左边/顶部 的像素长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDividerLocation</span><span class="params">(<span class="keyword">int</span> location)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置分隔条的位置，相对于 宽度/高度 的比例 [0.0 ~ 1.0]（该方法必须要先确保 JSplitPane 已经有宽高值，否则无效）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDividerLocation</span><span class="params">(<span class="keyword">double</span> proportionalLocation)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建分隔面板</span></span><br><span class="line">        JSplitPane splitPane = <span class="keyword">new</span> JSplitPane();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置左右两边显示的组件</span></span><br><span class="line">        splitPane.setLeftComponent(<span class="keyword">new</span> JButton(<span class="string">&quot;左边按钮&quot;</span>));</span><br><span class="line">        splitPane.setRightComponent(<span class="keyword">new</span> JButton(<span class="string">&quot;右边按钮&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分隔条上显示快速 折叠/展开 两边组件的小按钮</span></span><br><span class="line">        splitPane.setOneTouchExpandable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拖动分隔条时连续重绘组件</span></span><br><span class="line">        splitPane.setContinuousLayout(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置分隔条的初始位置</span></span><br><span class="line">        splitPane.setDividerLocation(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把分隔面板作为内容面板添加到窗口并显示</span></span><br><span class="line">        jf.setContentPane(splitPane);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\11.png" alt="11"></p><h2 id="JTabbedPane（选项卡面板）"><a href="#JTabbedPane（选项卡面板）" class="headerlink" title="JTabbedPane（选项卡面板）"></a>JTabbedPane（选项卡面板）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTabbedPane.html">javax.swing.JTabbedPane</a></p><p>常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参事说明:</span></span><br><span class="line"><span class="comment"> * tabPlacement: 选项卡标题的位置, 值为 JTabbedPane.TOP、JTabbedPane.BOTTOM、</span></span><br><span class="line"><span class="comment"> * JTabbedPane.LEFT 或 JTabbedPane.RIGHT, 默认为 TOP</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment"> * tabLayoutPolicy: 选项卡位置不能放入所有的选项卡时，放置选项卡的策略，</span></span><br><span class="line"><span class="comment"> * 值为 JTabbedPane.WRAP_TAB_LAYOUT 或 JTabbedPane.SCROLL_TAB_LAYOUT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   JTabbedPane()</span><br><span class="line"></span><br><span class="line">JTabbedPane(<span class="keyword">int</span> tabPlacement)</span><br><span class="line"></span><br><span class="line">JTabbedPane(<span class="keyword">int</span> tabPlacement, <span class="keyword">int</span> tabLayoutPolicy)</span><br></pre></td></tr></table></figure><p>创建选项卡:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * title: 选项卡的标题</span></span><br><span class="line"><span class="comment"> * icon: 选项卡的图标</span></span><br><span class="line"><span class="comment"> * tip: 当鼠标移到该选项卡时，悬浮提示的文本</span></span><br><span class="line"><span class="comment"> * component: 选中该选项卡时显示的内容组件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTab</span><span class="params">(String title, Component component)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTab</span><span class="params">(String title, Icon icon, Component component)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTab</span><span class="params">(String title, Icon icon, Component component, String tip)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> * 在指定索引位置插入一个选项卡</span></span></span><br><span class="line"><span class="comment"><span class="function">   */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertTab</span><span class="params">(String title, Icon icon, Component component, String tip, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure><p>移除选项卡:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除指定位置的选项（下面两个方法完全一致）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeTabAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 移除指定内容控件的选项卡</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 移除所有选项卡</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>选项卡相关操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置当前选中的选项卡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectedIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前选中的选项卡索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSelectedIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前选中的选项卡对应的内容组件</span></span></span><br><span class="line"><span class="function">Component <span class="title">getSelectedComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置 index 位置的选项卡的标题</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTitleAt</span><span class="params">(<span class="keyword">int</span> index, String title)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置 index 位置的选项卡的图标</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIconAt</span><span class="params">(<span class="keyword">int</span> index, Icon icon)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置 index 位置的选项卡是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabledAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> enabled)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将 index 位置的内容组件设置为 component</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setComponentAt</span><span class="params">(<span class="keyword">int</span> index, Component component)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取选项卡的数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTabCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> * 自定义选项卡标题位置的组件, 这里的 titleComponent 将放到选项卡标题位置。</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 应用场景: 例如, 在选项卡标题位置添加一个关闭按钮, 点击按钮移除选项卡。</span></span></span><br><span class="line"><span class="comment"><span class="function">   */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTabComponentAt</span><span class="params">(<span class="keyword">int</span> index, Component titleComponent)</span></span></span><br></pre></td></tr></table></figure><p>状态监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加选项卡选中状态改变的监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChangeListener</span><span class="params">(ChangeListener l)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建选项卡面板</span></span><br><span class="line">        <span class="keyword">final</span> JTabbedPane tabbedPane = <span class="keyword">new</span> JTabbedPane();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第1个选项卡（选项卡只包含 标题）</span></span><br><span class="line">        tabbedPane.addTab(<span class="string">&quot;Tab01&quot;</span>, createTextPanel(<span class="string">&quot;TAB 01&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第2个选项卡（选项卡包含 标题 和 图标）</span></span><br><span class="line">        tabbedPane.addTab(<span class="string">&quot;Tab02&quot;</span>, createTextPanel(<span class="string">&quot;TAB 02&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建第3个选项卡（选项卡包含 标题、图标 和 tip提示）</span></span><br><span class="line">        tabbedPane.addTab(<span class="string">&quot;Tab03&quot;</span>, createTextPanel(<span class="string">&quot;TAB 03&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加选项卡选中状态改变的监听器</span></span><br><span class="line">        tabbedPane.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前选中的选项卡: &quot;</span> + tabbedPane.getSelectedIndex());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认选中的选项卡</span></span><br><span class="line">        tabbedPane.setSelectedIndex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(tabbedPane);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个面板，面板中心显示一个标签，用于表示某个选项卡需要显示的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JComponent <span class="title">createTextPanel</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建面板, 使用一个 1 行 1 列的网格布局（为了让标签的宽高自动撑满面板）</span></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel(<span class="keyword">new</span> GridLayout(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建标签</span></span><br><span class="line">        JLabel label = <span class="keyword">new</span> JLabel(text);</span><br><span class="line">        label.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">50</span>));</span><br><span class="line">        label.setHorizontalAlignment(SwingConstants.CENTER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加标签到面板</span></span><br><span class="line">        panel.add(label);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> panel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\12.png" alt="12"></p><h1 id="JavaSwing-基本组件"><a href="#JavaSwing-基本组件" class="headerlink" title="JavaSwing 基本组件"></a>JavaSwing 基本组件</h1><h2 id="JLabel（标签）"><a href="#JLabel（标签）" class="headerlink" title="JLabel（标签）"></a>JLabel（标签）</h2><p>官方JavaDocsApi： <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JLabel.html">javax.swing.JLabel</a></p><p><code>JLabel</code>，标签。标签主要用于展示 <strong>文本</strong> 或 <strong>图片</strong>，也可以 <strong>同时显示文本和图片</strong>。</p><p>JLabel 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造方法中的参数含义:</span></span><br><span class="line"><span class="comment"> *     text: 标签显示的 文本</span></span><br><span class="line"><span class="comment"> *     image: 标签显示的 图片</span></span><br><span class="line"><span class="comment"> *     horizontalAlignment: 标签内容（在标签内）的水平对其方式（竖直方向默认居中, 可通过方法设置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JLabel()</span><br><span class="line"></span><br><span class="line">JLabel(String text)</span><br><span class="line"></span><br><span class="line">JLabel(String text, <span class="keyword">int</span> horizontalAlignment)</span><br><span class="line"></span><br><span class="line">JLabel(Icon image) </span><br><span class="line"></span><br><span class="line">JLabel(Icon image, <span class="keyword">int</span> horizontalAlignment) </span><br><span class="line"></span><br><span class="line">JLabel(String text, Icon image, <span class="keyword">int</span> horizontalAlignment) </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JLabel 的常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 文本 和 图片</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(Icon icon)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文本相对于图片的位置（文本默认在图片右边垂直居中）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHorizontalTextPosition</span><span class="params">(<span class="keyword">int</span> textPosition)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setVerticalTextPosition</span><span class="params">(<span class="keyword">int</span> textPosition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置标签内容（在标签内）的对其方式（默认左对齐并垂直居中）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHorizontalAlignment</span><span class="params">(<span class="keyword">int</span> alignment)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setVerticalAlignment</span><span class="params">(<span class="keyword">int</span> alignment)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置图片和文本之间的间隙</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIconTextGap</span><span class="params">(<span class="keyword">int</span> iconTextGap)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 下面的方法定义在 JComponent 基类中</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文本的字体类型、样式 和 大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置字体颜色</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当鼠标移动到组件上时显示的提示文本</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setToolTipText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件的背景</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBackground</span><span class="params">(Color bg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件是否可见</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setVisible</span><span class="params">(<span class="keyword">boolean</span> visible)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件是否为 不透明，JLabel默认为透明，设置为不透明后才能显示背景</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOpaque</span><span class="params">(<span class="keyword">boolean</span> isOpaque)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件的 首选 大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPreferredSize</span><span class="params">(Dimension preferredSize)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件的 最小 大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMinimumSize</span><span class="params">(Dimension minimumSize)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件的 最大 大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaximumSize</span><span class="params">(Dimension maximumSize)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 上面的对齐参数具体的取值常量参考 DocsApi；</span></span></span><br><span class="line"><span class="comment"><span class="function"> * setXXX(...) 方法往往都对应着 getXXX() 方法。</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure><p>ImageIcon 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 本地路径 图片创建 ImageIcon</span></span><br><span class="line">ImageIcon(String filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 网络路径 图片创建 ImageIcon</span></span><br><span class="line">ImageIcon(URL location)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用图片文件的字节数组创建 ImageIcon</span></span><br><span class="line">ImageIcon(<span class="keyword">byte</span>[] imageData)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 java.awt.Image 实例创建 ImageIcon</span></span><br><span class="line">ImageIcon(java.awt.Image image)</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">700</span>, <span class="number">600</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);  <span class="comment">// 把窗口位置设置到屏幕中心</span></span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建内容面板，默认使用流式布局</span></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 只显示文本</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JLabel label0 = <span class="keyword">new</span> JLabel();</span><br><span class="line">        label0.setLocation(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        label0.setSize(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">        label0.setText(<span class="string">&quot;Only Text&quot;</span>);</span><br><span class="line">        label0.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>, Font.PLAIN, <span class="number">20</span>));  <span class="comment">// 设置字体，null 表示使用默认字体</span></span><br><span class="line">        panel.add(label0);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 只显示图片</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JLabel label1 = <span class="keyword">new</span> JLabel();</span><br><span class="line">        label1.setLocation(<span class="number">0</span>,<span class="number">150</span>);</span><br><span class="line">        label1.setSize(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">        label1.setIcon(<span class="keyword">new</span> ImageIcon(<span class="string">&quot;src/image/test.gif&quot;</span>));</span><br><span class="line">        panel.add(label1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 同时显示文本和图片</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JLabel label2 = <span class="keyword">new</span> JLabel();</span><br><span class="line">        label2.setLocation(<span class="number">100</span>,<span class="number">300</span>);</span><br><span class="line">        label2.setSize(<span class="number">500</span>,<span class="number">200</span>);</span><br><span class="line">        label2.setText(<span class="string">&quot;文本和图片&quot;</span>);</span><br><span class="line">        label2.setFont(<span class="keyword">new</span> Font(<span class="string">&quot;宋体&quot;</span>,Font.PLAIN,<span class="number">20</span>));</span><br><span class="line">        label2.setIcon(<span class="keyword">new</span> ImageIcon(<span class="string">&quot;src/image/test.gif&quot;</span>));</span><br><span class="line">        label2.setHorizontalTextPosition(SwingConstants.CENTER);   <span class="comment">// 水平方向文本在图片中心</span></span><br><span class="line">        label2.setVerticalTextPosition(SwingConstants.BOTTOM);     <span class="comment">// 垂直方向文本在图片下方</span></span><br><span class="line">        panel.add(label2);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\0.png" alt="0"></p><h2 id="JButton（按钮）"><a href="#JButton（按钮）" class="headerlink" title="JButton（按钮）"></a>JButton（按钮）</h2><p>官方JavaDocsApi： <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JButton.html">javax.swing.JButton</a></p><p>JButton 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不带有设置文本或图标的按钮</span></span><br><span class="line">JButton()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个带文本的按钮</span></span><br><span class="line">JButton(String text)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个带图标的按钮</span></span><br><span class="line">JButton(Icon icon)</span><br></pre></td></tr></table></figure><p>JButton 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置按钮的 文本、字体 和 字体颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 以下方法定义在 javax.swing.AbstractButton 基类中 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置按钮是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enable)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置按钮在 默认、按下、不可用 时显示的图片</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(Icon defaultIcon)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPressedIcon</span><span class="params">(Icon pressedIcon)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisabledIcon</span><span class="params">(Icon disabledIcon)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 是否绘制边框（设置不绘制边框，再结合上面三个设置按钮状态图片的方法，可实现自定义按钮）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBorderPainted</span><span class="params">(<span class="keyword">boolean</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>JButton 常用监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加和移除按钮的点击事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addActionListener</span><span class="params">(ActionListener listener)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeActionListener</span><span class="params">(ActionListener listener)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：简单按钮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个按钮</span></span><br><span class="line">        <span class="keyword">final</span> JButton btn = <span class="keyword">new</span> JButton(<span class="string">&quot;测试按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加按钮的点击事件监听器</span></span><br><span class="line">        btn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 获取到的事件源就是按钮本身</span></span><br><span class="line">                <span class="comment">// JButton btn = (JButton) e.getSource();</span></span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;按钮被点击&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        panel.add(btn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\1.png" alt="1"></p><p>代码实例: 自定义图片按钮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> AWTException </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">700</span>, <span class="number">500</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> JButton btn = <span class="keyword">new</span> JButton();</span><br><span class="line">        btn.setBounds(<span class="number">100</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置按钮的默认图片</span></span><br><span class="line">        btn.setIcon(<span class="keyword">new</span> ImageIcon(<span class="string">&quot;src/image/button.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置按钮被点击时的图片</span></span><br><span class="line">        btn.setPressedIcon(<span class="keyword">new</span> ImageIcon(<span class="string">&quot;src/image/press.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不绘制边框</span></span><br><span class="line">        btn.setBorderPainted(<span class="keyword">false</span>);</span><br><span class="line">        btn.setContentAreaFilled(<span class="keyword">false</span>);    <span class="comment">//不绘制默认按钮背景</span></span><br><span class="line">        btn.setFocusPainted(<span class="keyword">false</span>);           <span class="comment">//不绘制图片或文字周围的焦点虚框</span></span><br><span class="line">        <span class="comment">// 添加按钮点击事件监听器</span></span><br><span class="line">        btn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;按钮被点击了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        panel.add(btn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JRadioButton（单选按钮）"><a href="#JRadioButton（单选按钮）" class="headerlink" title="JRadioButton（单选按钮）"></a>JRadioButton（单选按钮）</h2><p>官方 JavaDocsApi： <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JRadioButton.html">javax.swing.JRadioButton</a></p><p>JButton 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无文本，未选中</span></span><br><span class="line">JRadioButton()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有文本，未选中</span></span><br><span class="line">JRadioButton(String text)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有文本，并指定是否选中</span></span><br><span class="line">JRadioButton(String text, <span class="keyword">boolean</span> selected)</span><br></pre></td></tr></table></figure><p>JRadioButton 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置单选按钮的 文本、字体 和字体颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 以下方法定义在 javax.swing.AbstractButton 基类中 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置单选按钮是否选中状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelected</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断单选按钮是否选中</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置单选按钮是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enable)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置单选按钮在 默认、被选中、不可用时显示的图片</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(Icon defaultIcon)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPressedIcon</span><span class="params">(Icon pressedIcon)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisabledIcon</span><span class="params">(Icon disabledIcon)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置图片和文本的间距</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIconTextGap</span><span class="params">(<span class="keyword">int</span> iconTextGap)</span></span></span><br></pre></td></tr></table></figure><p>JRadioButton 常用监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加状态改变监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChangeListener</span><span class="params">(ChangeListener l)</span></span></span><br></pre></td></tr></table></figure><p>ButtonGroup（按钮组）: 当有多个单选按钮时，一般只允许一个单选按钮选中，因此需要对同一类型的单选按钮进行分组，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个按钮组</span></span><br><span class="line">ButtonGroup btnGroup = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加单选按钮到按钮组</span></span><br><span class="line">btnGroup.add(radioBtn01);</span><br><span class="line">btnGroup.add(radioBtn02);</span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> AWTException </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个单选按钮</span></span><br><span class="line">        JRadioButton radioBtn01 = <span class="keyword">new</span> JRadioButton(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        JRadioButton radioBtn02 = <span class="keyword">new</span> JRadioButton(<span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建按钮组，把两个单选按钮添加到该组</span></span><br><span class="line">        ButtonGroup btnGroup = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line">        btnGroup.add(radioBtn01);</span><br><span class="line">        btnGroup.add(radioBtn02);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认第一个单选按钮选中</span></span><br><span class="line">        radioBtn01.setSelected(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        panel.add(radioBtn01);</span><br><span class="line">        panel.add(radioBtn02);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\2.png" alt="2"></p><h2 id="JCheckBox（复选框）"><a href="#JCheckBox（复选框）" class="headerlink" title="JCheckBox（复选框）"></a>JCheckBox（复选框）</h2><p>官方JavaDocsApi： <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JCheckBox.html">javax.swing.JCheckBox</a></p><p>JCheckBox 常用构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无文本，默认未选中</span></span><br><span class="line">JCheckBox()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有文本，默认未选中</span></span><br><span class="line">JCheckBox(String text)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有文本，并指定是否选中</span></span><br><span class="line">JCheckBox(String text, <span class="keyword">boolean</span> selected)</span><br></pre></td></tr></table></figure><p>JCheckBox 常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置复选框的 文本、字体 和 字体颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 以下方法定义在 javax.swing.AbstractButton 基类中 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置复选框是否选中状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelected</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断复选框是否选中</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置复选框是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enable)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置图片和文本的间距</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIconTextGap</span><span class="params">(<span class="keyword">int</span> iconTextGap)</span></span></span><br></pre></td></tr></table></figure><p>JCheckBox 常用监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加状态改变监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChangeListener</span><span class="params">(ChangeListener l)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建复选框</span></span><br><span class="line">        JCheckBox checkBox01 = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;菠萝&quot;</span>);</span><br><span class="line">        JCheckBox checkBox02 = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;香蕉&quot;</span>);</span><br><span class="line">        JCheckBox checkBox03 = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;雪梨&quot;</span>);</span><br><span class="line">        JCheckBox checkBox04 = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;荔枝&quot;</span>);</span><br><span class="line">        JCheckBox checkBox05 = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;橘子&quot;</span>);</span><br><span class="line">        JCheckBox checkBox06 = <span class="keyword">new</span> JCheckBox(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加第一个复选框的状态被改变的监听（其他复选框如果需要监听状态改变，则可按此方法添加监听）</span></span><br><span class="line">        checkBox01.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 获取事件源（即复选框本身）</span></span><br><span class="line">                JCheckBox checkBox = (JCheckBox) e.getSource();</span><br><span class="line">                System.out.println(checkBox.getText() + <span class="string">&quot; 是否选中: &quot;</span> + checkBox.isSelected());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认第一个复选框选中</span></span><br><span class="line">        checkBox01.setSelected(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        panel.add(checkBox01);</span><br><span class="line">        panel.add(checkBox02);</span><br><span class="line">        panel.add(checkBox03);</span><br><span class="line">        panel.add(checkBox04);</span><br><span class="line">        panel.add(checkBox05);</span><br><span class="line">        panel.add(checkBox06);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\3.png" alt="3"></p><h2 id="JToggleButton（开关按钮）"><a href="#JToggleButton（开关按钮）" class="headerlink" title="JToggleButton（开关按钮）"></a>JToggleButton（开关按钮）</h2><p>官方JavaDocsApi： <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JToggleButton.html">javax.swing.JToggleButton</a></p><p>JToggleButton 是 JRadioButton, JCheckBox 的父类，主要实现一个按钮的两种状态（选中 和 未选中）来实现开关切换的效果。</p><p>JToggleButton 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无文本，默认未选中</span></span><br><span class="line">JToggleButton()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有文本，默认未选中</span></span><br><span class="line">JToggleButton(String text)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有文本，并指定是否选中</span></span><br><span class="line">JToggleButton(String text, <span class="keyword">boolean</span> selected)</span><br></pre></td></tr></table></figure><p>JToggleButton 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置开关按钮的 文本、字体 和 字体颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 以下方法定义在 javax.swing.AbstractButton 基类中 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置开关按钮是否选中状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelected</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断开关按钮是否选中</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置开关按钮是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enable)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置开关按钮在 默认(关)、被选中(开)、不可用 时显示的图片</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(Icon defaultIcon)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPressedIcon</span><span class="params">(Icon pressedIcon)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisabledIcon</span><span class="params">(Icon disabledIcon)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置图片和文本之间的间距</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIconTextGap</span><span class="params">(<span class="keyword">int</span> iconTextGap)</span></span></span><br></pre></td></tr></table></figure><p>JToggleButton 常用监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加状态改变监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChangeListener</span><span class="params">(ChangeListener l)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：默认的开关按钮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建开关按钮</span></span><br><span class="line">        JToggleButton toggleBtn = <span class="keyword">new</span> JToggleButton(<span class="string">&quot;开关按钮&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 toggleBtn 的状态被改变的监听</span></span><br><span class="line">        toggleBtn.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 获取事件源（即开关按钮本身）</span></span><br><span class="line">                JToggleButton toggleBtn = (JToggleButton) e.getSource();</span><br><span class="line">                System.out.println(toggleBtn.getText() + <span class="string">&quot; 是否选中: &quot;</span> + toggleBtn.isSelected());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        panel.add(toggleBtn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\4.png" alt="4"></p><p>代码实例：自定义图片开关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建开关按钮</span></span><br><span class="line">        JToggleButton toggleBtn = <span class="keyword">new</span> JToggleButton();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先设置不绘制按钮边框</span></span><br><span class="line">        toggleBtn.setBorderPainted(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 选中(开) 和 未选中(关) 时显示的图片</span></span><br><span class="line">        toggleBtn.setSelectedIcon(<span class="keyword">new</span> ImageIcon(<span class="string">&quot;toggle_on.png&quot;</span>));</span><br><span class="line">        toggleBtn.setIcon(<span class="keyword">new</span> ImageIcon(<span class="string">&quot;toggle_off.png&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 toggleBtn 的状态被改变的监听</span></span><br><span class="line">        toggleBtn.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 获取事件源（即开关按钮本身）</span></span><br><span class="line">                JToggleButton toggleBtn = (JToggleButton) e.getSource();</span><br><span class="line">                System.out.println(toggleBtn.getText() + <span class="string">&quot; 是否选中: &quot;</span> + toggleBtn.isSelected());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        panel.add(toggleBtn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JTextField（文本框）"><a href="#JTextField（文本框）" class="headerlink" title="JTextField（文本框）"></a>JTextField（文本框）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTextField.html">javax.swing.JTextField</a></p><p>JTextField 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * text: 默认显示的文本</span></span><br><span class="line"><span class="comment"> * columns: 用来计算首选宽度的列数；如果列设置为 0，则首选宽度将是组件实现的自然结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   JTextField()</span><br><span class="line"></span><br><span class="line">JTextField(String text)</span><br><span class="line"></span><br><span class="line">JTextField(<span class="keyword">int</span> columns)</span><br><span class="line"></span><br><span class="line">JTextField(String text, <span class="keyword">int</span> columns)</span><br></pre></td></tr></table></figure><p>JTextField 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文本框中的文本</span></span><br><span class="line"><span class="function">String <span class="title">getText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文本框的 文本、字体 和 字体颜色</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置颜色，分别为: 光标颜色、呈现选中部分的背景颜色、选中部分文本的颜色、不可用时文本的颜色</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCaretColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectionColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectedTextColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisabledTextColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文本内容的水平对齐方式</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHorizontalAlignment</span><span class="params">(<span class="keyword">int</span> alignment)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文本框是否可编辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEditable</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 下面方法定义在 java.awt.Component 基类中 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断组件当前是否拥有焦点</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFocusOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br></pre></td></tr></table></figure><p>JTextField 复制粘贴相关方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置光标开始位置，selectionStart &gt;= 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectionStart</span><span class="params">(<span class="keyword">int</span> selectionStart)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置光标结束位置，selectionEnd &gt;= selectionStart</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectionEnd</span><span class="params">(<span class="keyword">int</span> selectionEnd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 复制选中部分文本</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 剪切选中部分文本</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 粘贴文本到文本框</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paste</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>JTextField 常用监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加焦点事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFocusListener</span><span class="params">(FocusListener listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加文本框内的 文本改变 监听器</span></span></span><br><span class="line"><span class="function">textField.<span class="title">getDocument</span><span class="params">()</span>.<span class="title">addDocumentListener</span><span class="params">(DocumentListener listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加按键监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addKeyListener</span><span class="params">(KeyListener listener)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> AWTException </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文本框，指定可见列数为8列</span></span><br><span class="line">        <span class="keyword">final</span> JTextField textField = <span class="keyword">new</span> JTextField(<span class="number">8</span>);</span><br><span class="line">        textField.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line">        panel.add(textField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个按钮，点击后获取文本框中的文本</span></span><br><span class="line">        JButton btn = <span class="keyword">new</span> JButton(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line">        btn.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>, Font.PLAIN, <span class="number">20</span>));</span><br><span class="line">        btn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;提交: &quot;</span> + textField.getText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(btn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\5.png" alt="5"></p><h2 id="JPasswordField（密码框）"><a href="#JPasswordField（密码框）" class="headerlink" title="JPasswordField（密码框）"></a>JPasswordField（密码框）</h2><p>官方JavaDocsApi： <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JPasswordField.html">javax.swing.JPasswordField</a></p><p>JPasswordField 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * text: 默认显示的文本</span></span><br><span class="line"><span class="comment"> * columns: 用来计算首选宽度的列数；如果列设置为 0，则首选宽度将是组件实现的自然结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   JPasswordField()</span><br><span class="line"></span><br><span class="line">JPasswordField(String text)</span><br><span class="line"></span><br><span class="line">JPasswordField(<span class="keyword">int</span> columns)</span><br><span class="line"></span><br><span class="line">JPasswordField(String text, <span class="keyword">int</span> columns)</span><br></pre></td></tr></table></figure><p>JPasswordField 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取密码框输入的密码</span></span><br><span class="line"><span class="keyword">char</span>[] getPassword()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置密码框的 密码文本、字体 和 字体颜色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置密码框输入内容的水平对齐方式</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHorizontalAlignment</span><span class="params">(<span class="keyword">int</span> alignment)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置密码框默认显示的密码字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEchoChar</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置密码框是否可编辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEditable</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 下面方法定义在 java.awt.Component 基类中 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断组件当前是否拥有焦点</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFocusOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br></pre></td></tr></table></figure><p>JPasswordField 常用监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加焦点事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFocusListener</span><span class="params">(FocusListener listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加文本框内的文本改变监听器</span></span></span><br><span class="line"><span class="function">textField.<span class="title">getDocument</span><span class="params">()</span>.<span class="title">addDocumentListener</span><span class="params">(DocumentListener listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加按键监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addKeyListener</span><span class="params">(KeyListener listener)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> AWTException </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建密码框，指定可见列数为10列</span></span><br><span class="line">        <span class="keyword">final</span> JPasswordField passwordField = <span class="keyword">new</span> JPasswordField(<span class="number">10</span>);</span><br><span class="line">        panel.add(passwordField);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个按钮，点击后获取密码框中输入的密码</span></span><br><span class="line">        JButton btn = <span class="keyword">new</span> JButton(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line">        btn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;提交，密码为: &quot;</span> + <span class="keyword">new</span> String(passwordField.getPassword()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(btn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\6.png" alt="6"></p><h2 id="JTextArea（文本区域）"><a href="#JTextArea（文本区域）" class="headerlink" title="JTextArea（文本区域）"></a>JTextArea（文本区域）</h2><p>官方JavaDocsApi： <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JTextArea.html">javax.swing.JTextArea</a></p><p>JTextArea 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * text: 默认显示的文本</span></span><br><span class="line"><span class="comment"> * rows: 默认可见的行数</span></span><br><span class="line"><span class="comment"> * columns: 默认可见的列数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 默认由 rows 和 columns 决定首选大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   JTextArea()</span><br><span class="line"></span><br><span class="line">JTextArea(String text)</span><br><span class="line"></span><br><span class="line">JTextArea(<span class="keyword">int</span> rows, <span class="keyword">int</span> columns)</span><br><span class="line"></span><br><span class="line">JTextArea(String text, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns)</span><br></pre></td></tr></table></figure><p>JTextArea 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否自动换行，默认为 false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLineWrap</span><span class="params">(<span class="keyword">boolean</span> wrap)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置自动换行方式。如果为 true，则将在单词边界（空白）处换行; 如果为 false，则将在字符边界处换行。默认为 false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWrapStyleWord</span><span class="params">(<span class="keyword">boolean</span> word)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取文本框中的文本</span></span></span><br><span class="line"><span class="function">String <span class="title">getText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 追加文本到文档末尾</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 替换部分文本</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceRange</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文本框的 文本、字体 和 字体颜色</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFont</span><span class="params">(Font font)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setForeground</span><span class="params">(Color fg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取内容的行数（以换行符计算，满行自动换下一行不算增加行数）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取指定行（行数从0开始）的行尾（包括换行符）在全文中的偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineEndOffset</span><span class="params">(<span class="keyword">int</span> line)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取指定偏移量所在的行数（行数从0开始）</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLineOfOffset</span><span class="params">(<span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置颜色，分别为: 光标颜色、呈现选中部分的背景颜色、选中部分文本的颜色、不可用时文本的颜色</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCaretColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectionColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectedTextColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDisabledTextColor</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文本框是否可编辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEditable</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 下面方法定义在 java.awt.Component 基类中 */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断组件当前是否拥有焦点</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFocusOwner</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置组件是否可用</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br></pre></td></tr></table></figure><p>JTextArea 复制粘贴相关方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置光标开始位置，selectionStart &gt;= 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectionStart</span><span class="params">(<span class="keyword">int</span> selectionStart)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置光标结束位置，selectionEnd &gt;= selectionStart</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectionEnd</span><span class="params">(<span class="keyword">int</span> selectionEnd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 复制选中部分文本</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 剪切选中部分文本</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 粘贴文本到文本框</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">paste</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>JTextArea 常用监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加焦点事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFocusListener</span><span class="params">(FocusListener listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加文本框内的 文本改变 监听器</span></span></span><br><span class="line"><span class="function">textField.<span class="title">getDocument</span><span class="params">()</span>.<span class="title">addDocumentListener</span><span class="params">(DocumentListener listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加按键监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addKeyListener</span><span class="params">(KeyListener listener)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 5 行 10 列的文本区域</span></span><br><span class="line">        <span class="keyword">final</span> JTextArea textArea = <span class="keyword">new</span> JTextArea(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 设置自动换行</span></span><br><span class="line">        textArea.setLineWrap(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 添加到内容面板</span></span><br><span class="line">        panel.add(textArea);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个提交按钮，点击按钮获取输入文本</span></span><br><span class="line">        JButton btn = <span class="keyword">new</span> JButton(<span class="string">&quot;提交&quot;</span>);</span><br><span class="line">        btn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;提交: &quot;</span> + textArea.getText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(btn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\7.png" alt="7"></p><h2 id="JComboBox（下拉列表框）"><a href="#JComboBox（下拉列表框）" class="headerlink" title="JComboBox（下拉列表框）"></a>JComboBox（下拉列表框）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JComboBox.html">javax.swing.JComboBox</a></p><p>JComboBox 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个 JComboBox 实例维护这一个 ComboBoxModel 实例。</span></span><br><span class="line"><span class="comment"> * ComboBoxModel 实例可以直接创建，也可以通过把 数组 或 集合 传递到 JComboBox 中间接创建。</span></span><br><span class="line"><span class="comment"> * JComboBox 内部创建的 ComboBoxModel 实例是 DefaultComboBoxModel。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   JComboBox()</span><br><span class="line"></span><br><span class="line">JComboBox(ComboBoxModel model)</span><br><span class="line"></span><br><span class="line">JComboBox(Object[] items)</span><br><span class="line"></span><br><span class="line">JComboBox(Vector&lt;?&gt; items)</span><br></pre></td></tr></table></figure><p>JComboBox 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置选中的索引</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectedIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前选中的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSelectedIndex</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前选中的数据项</span></span></span><br><span class="line"><span class="function">Object <span class="title">getSelectedItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置选项数据模型</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setModel</span><span class="params">(ComboBoxModel&lt;?&gt; model)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取维护选项数据的 ComboBoxModel。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 再通过 model.getElementAt(int index) 和 model.getSize() </span></span></span><br><span class="line"><span class="function"><span class="comment">// 可分别 获取指定索引的选项数据 和 选项数量。</span></span></span><br><span class="line"><span class="function">ComboBoxModel&lt;?&gt; <span class="title">getModel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加选项选中状态改变的监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addItemListener</span><span class="params">(ItemListener listener)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置下拉列表框是否可编辑，默认不可编辑。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果设置为可编辑，则除了选择指定的选项值外，还允许用户自行输入值（自行输入的值索引为-1）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEditable</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ItemEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ItemListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一个标签</span></span><br><span class="line">        JLabel label = <span class="keyword">new</span> JLabel(<span class="string">&quot;水果：&quot;</span>);</span><br><span class="line">        panel.add(label);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要选择的条目</span></span><br><span class="line">        String[] listData = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;雪梨&quot;</span>, <span class="string">&quot;苹果&quot;</span>, <span class="string">&quot;荔枝&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个下拉列表框</span></span><br><span class="line">        <span class="keyword">final</span> JComboBox&lt;String&gt; comboBox = <span class="keyword">new</span> JComboBox&lt;String&gt;(listData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加条目选中状态改变的监听器</span></span><br><span class="line">        comboBox.addItemListener(<span class="keyword">new</span> ItemListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemStateChanged</span><span class="params">(ItemEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 只处理选中的状态</span></span><br><span class="line">                <span class="keyword">if</span> (e.getStateChange() == ItemEvent.SELECTED) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;选中: &quot;</span> + comboBox.getSelectedIndex() + <span class="string">&quot; = &quot;</span> + comboBox.getSelectedItem());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认选中的条目</span></span><br><span class="line">        comboBox.setSelectedIndex(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到内容面板</span></span><br><span class="line">        panel.add(comboBox);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\8.png" alt="8"></p><h2 id="JProgressBar（进度条）"><a href="#JProgressBar（进度条）" class="headerlink" title="JProgressBar（进度条）"></a>JProgressBar（进度条）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JProgressBar.html">javax.swing.JProgressBar</a></p><p>JProgressBar 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法中的参数含义:</span></span><br><span class="line"><span class="comment"> * orient: 进度条的方向，SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL，默认为水平方向</span></span><br><span class="line"><span class="comment"> * min: 最小进度值</span></span><br><span class="line"><span class="comment"> * max: 最大进度值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">JProgressBar()</span><br><span class="line"></span><br><span class="line">JProgressBar(<span class="keyword">int</span> orient)</span><br><span class="line"></span><br><span class="line">JProgressBar(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span><br><span class="line"></span><br><span class="line">JProgressBar(<span class="keyword">int</span> orient, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span><br></pre></td></tr></table></figure><p>JProgressBar 常用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 最小进度值、最大进度值、当前进度值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMinimum</span><span class="params">(<span class="keyword">int</span> min)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaximum</span><span class="params">(<span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前进度值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前进度的百分比</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPercentComplete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 是否绘制百分比文本（进度条中间显示的百分数）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStringPainted</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置进度条进度是否为不确定模式</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIndeterminate</span><span class="params">(<span class="keyword">boolean</span> newValue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置进度条的方向，SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOrientation</span><span class="params">(<span class="keyword">int</span> newOrientation)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加进度条的进度改变监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChangeListener</span><span class="params">(ChangeListener l)</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PROGRESS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PROGRESS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> currentProgress = MIN_PROGRESS;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">250</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个进度条</span></span><br><span class="line">        <span class="keyword">final</span> JProgressBar progressBar = <span class="keyword">new</span> JProgressBar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置进度的最小值 和最大值</span></span><br><span class="line">        progressBar.setMinimum(MIN_PROGRESS);</span><br><span class="line">        progressBar.setMaximum(MAX_PROGRESS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当前进度值</span></span><br><span class="line">        progressBar.setValue(currentProgress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制百分比文本（进度条中间显示的百分数）</span></span><br><span class="line">        progressBar.setStringPainted(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加进度改变通知</span></span><br><span class="line">        progressBar.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前进度值: &quot;</span> + progressBar.getValue() + <span class="string">&quot;; &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;进度百分比: &quot;</span> + progressBar.getPercentComplete());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到内容面板</span></span><br><span class="line">        panel.add(progressBar);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟延时操作进度, 每隔 0.5 秒更新进度</span></span><br><span class="line">        <span class="keyword">new</span> Timer(<span class="number">500</span>, <span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                currentProgress++;</span><br><span class="line">                <span class="keyword">if</span> (currentProgress &gt; MAX_PROGRESS) &#123;</span><br><span class="line">                    currentProgress = MIN_PROGRESS;</span><br><span class="line">                &#125;</span><br><span class="line">                progressBar.setValue(currentProgress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\9.png" alt="9"></p><h1 id="JavaSwing-其他组件"><a href="#JavaSwing-其他组件" class="headerlink" title="JavaSwing 其他组件"></a>JavaSwing 其他组件</h1><h2 id="JFileChooser（文件选择器）"><a href="#JFileChooser（文件选择器）" class="headerlink" title="JFileChooser（文件选择器）"></a>JFileChooser（文件选择器）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JFileChooser.html">javax.swing.JFileChooser</a></p><p>JFileChooser 常用构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * currentDirectory: 打开文件选取器时默认显示的文件夹（默认为用户文件夹）</span></span><br><span class="line"><span class="comment"> * currentDirectoryPath: 打开文件选取器时默认显示的文件夹（默认为用户文件夹）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   JFileChooser()</span><br><span class="line"></span><br><span class="line">JFileChooser(File currentDirectory)</span><br><span class="line"></span><br><span class="line">JFileChooser(String currentDirectoryPath)</span><br></pre></td></tr></table></figure><p>JFileChooser 常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置默认显示的文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCurrentDirectory</span><span class="params">(File dir)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置文件选择模式, 可选值如下:</span></span></span><br><span class="line"><span class="function"><span class="comment">//     JFileChooser.FILES_ONLY: 只能选文件</span></span></span><br><span class="line"><span class="function"><span class="comment">//     JFileChooser.DIRECTORIES_ONLY: 只能选文件夹</span></span></span><br><span class="line"><span class="function"><span class="comment">//     JFileChooser.FILES_AND_DIRECTORIES: 文件和文件夹都可以选</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFileSelectionMode</span><span class="params">(<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置是否允许同时选择多个（默认为不允许）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMultiSelectionEnabled</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加可供用户选择的文件过滤器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChoosableFileFilter</span><span class="params">(FileFilter filter)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置默认使用的文件过滤器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFileFilter</span><span class="params">(FileFilter filter)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置默认被选中的文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectedFile</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelectedFiles</span><span class="params">(File[] selectedFiles)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 显示 打开文件 或 保存文件 的对话框（线程将被阻塞, 直到选择框被关闭）。</span></span></span><br><span class="line"><span class="comment"><span class="function"> *</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 参数: </span></span></span><br><span class="line"><span class="comment"><span class="function"> *     parent: 文件选取器对话框的父组件, 对话框将会尽量显示在靠近 parent 的中心; 如果传 null, 则显示在屏幕中心。</span></span></span><br><span class="line"><span class="comment"><span class="function"> * </span></span></span><br><span class="line"><span class="comment"><span class="function"> * 返回值:</span></span></span><br><span class="line"><span class="comment"><span class="function"> *     JFileChooser.CANCEL_OPTION: 点击了取消或关闭</span></span></span><br><span class="line"><span class="comment"><span class="function"> *     JFileChooser.APPROVE_OPTION: 点击了确认或保存</span></span></span><br><span class="line"><span class="comment"><span class="function"> *     JFileChooser.ERROR_OPTION: 出现错误</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">showOpenDialog</span><span class="params">(Component parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">showSaveDialog</span><span class="params">(Component parent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取选择的文件（一般在用户选择完文件点击了确认或保存后通过该方法获取选中的文件）</span></span></span><br><span class="line"><span class="function">File <span class="title">getSelectedFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function">File[] <span class="title">getSelectedFiles</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileNameExtensionFilter;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">400</span>, <span class="number">250</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文本区域, 用于显示相关信息</span></span><br><span class="line">        <span class="keyword">final</span> JTextArea msgTextArea = <span class="keyword">new</span> JTextArea(<span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        msgTextArea.setLineWrap(<span class="keyword">true</span>);</span><br><span class="line">        panel.add(msgTextArea);</span><br><span class="line"></span><br><span class="line">        JButton openBtn = <span class="keyword">new</span> JButton(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">        openBtn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                showFileOpenDialog(jf, msgTextArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(openBtn);</span><br><span class="line"></span><br><span class="line">        JButton saveBtn = <span class="keyword">new</span> JButton(<span class="string">&quot;保存&quot;</span>);</span><br><span class="line">        saveBtn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                showFileSaveDialog(jf, msgTextArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        panel.add(saveBtn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 打开文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFileOpenDialog</span><span class="params">(Component parent, JTextArea msgTextArea)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个默认的文件选取器</span></span><br><span class="line">        JFileChooser fileChooser = <span class="keyword">new</span> JFileChooser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置默认显示的文件夹为当前文件夹</span></span><br><span class="line">        fileChooser.setCurrentDirectory(<span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置文件选择的模式（只选文件、只选文件夹、文件和文件均可选）</span></span><br><span class="line">        fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);</span><br><span class="line">        <span class="comment">// 设置是否允许多选</span></span><br><span class="line">        fileChooser.setMultiSelectionEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加可用的文件过滤器（FileNameExtensionFilter 的第一个参数是描述, 后面是需要过滤的文件扩展名 可变参数）</span></span><br><span class="line">        fileChooser.addChoosableFileFilter(<span class="keyword">new</span> FileNameExtensionFilter(<span class="string">&quot;zip(*.zip, *.rar)&quot;</span>, <span class="string">&quot;zip&quot;</span>, <span class="string">&quot;rar&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置默认使用的文件过滤器</span></span><br><span class="line">        fileChooser.setFileFilter(<span class="keyword">new</span> FileNameExtensionFilter(<span class="string">&quot;image(*.jpg, *.png, *.gif)&quot;</span>, <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;png&quot;</span>, <span class="string">&quot;gif&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开文件选择框（线程将被阻塞, 直到选择框被关闭）</span></span><br><span class="line">        <span class="keyword">int</span> result = fileChooser.showOpenDialog(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">            <span class="comment">// 如果点击了&quot;确定&quot;, 则获取选择的文件路径</span></span><br><span class="line">            File file = fileChooser.getSelectedFile();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果允许选择多个文件, 则通过下面方法获取选择的所有文件</span></span><br><span class="line">            <span class="comment">// File[] files = fileChooser.getSelectedFiles();</span></span><br><span class="line"></span><br><span class="line">            msgTextArea.append(<span class="string">&quot;打开文件: &quot;</span> + file.getAbsolutePath() + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 选择文件保存路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFileSaveDialog</span><span class="params">(Component parent, JTextArea msgTextArea)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个默认的文件选取器</span></span><br><span class="line">        JFileChooser fileChooser = <span class="keyword">new</span> JFileChooser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置打开文件选择框后默认输入的文件名</span></span><br><span class="line">        fileChooser.setSelectedFile(<span class="keyword">new</span> File(<span class="string">&quot;测试文件.zip&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开文件选择框（线程将被阻塞, 直到选择框被关闭）</span></span><br><span class="line">        <span class="keyword">int</span> result = fileChooser.showSaveDialog(parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">            <span class="comment">// 如果点击了&quot;保存&quot;, 则获取选择的保存路径</span></span><br><span class="line">            File file = fileChooser.getSelectedFile();</span><br><span class="line">            msgTextArea.append(<span class="string">&quot;保存到文件: &quot;</span> + file.getAbsolutePath() + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\13.png" alt="13"></p><h2 id="JDialog、JOptionPane（对话框）"><a href="#JDialog、JOptionPane（对话框）" class="headerlink" title="JDialog、JOptionPane（对话框）"></a>JDialog、JOptionPane（对话框）</h2><p>官方 JavaDocsApi：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JDialog.html">javax.swing.JDialog</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JOptionPane.html">javax.swing.JOptionPane</a></li></ul><p>JDialog 可以创建自定义有的对话框，或者调用 JOptionPane 中的多个静态方法快速创建各种标准的对话框。</p><p>JOptionPane 是 Java Swing 内部已实现好的，以静态方法的形式提供调用，能够快速方便的弹出要求用户提供值或向其发出通知的标准对话框。</p><p>JOptionPane 提供的<strong>标准对话框</strong>类型分为以下几种:</p><div class="table-container"><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>showMessageDialog</td><td>消息对话框，向用户展示一个消息，没有返回值。</td></tr><tr><td>showConfirmDialog</td><td>确认对话框，询问一个问题是否执行。</td></tr><tr><td>showInputDialog</td><td>输入对话框，要求用户提供某些输入。</td></tr><tr><td>showOptionDialog</td><td>选项对话框，上述三项的大统一，自定义按钮文本，询问用户需要点击哪个按钮。</td></tr></tbody></table></div><p>上述四个类型的方法（包括其若干重载）的参数遵循一致的模式，下面介绍各<strong>参数</strong>的含义:</p><p>(1) parentComponent：对话框的父级组件，决定对话框显示的位置，对话框的显示会尽量紧靠组件的中心，如果传 null，则显示在屏幕的中心。</p><p>(2) title：对话框标题。</p><p>(3) message：消息内容。</p><p>(4) messageType：消息类型，主要是提供默认的对话框图标。可能的值为：</p><ul><li>JOptionPane.PLAIN_MESSAGE 简单消息（不使用图标）</li><li>JOptionPane.INFORMATION_MESSAGE 信息消息（默认）</li><li>JOptionPane.QUESTION_MESSAGE 问题消息</li><li>JOptionPane.WARNING_MESSAGE 警告消息</li><li>JOptionPane.ERROR_MESSAGE 错误消息</li></ul><p>(5) icon：自定义的对话框图标，如果传 null，则图标类型由 messageType 决定。</p><p>(6) optionType：选项按钮的类型。</p><p>(7) options、initialValue：自定义的选项按钮（如果传 null，则选项按钮由 optionType 决定），以及默认选中的选项按钮。</p><p>(8) selectionValues、initialSelectionValue：提供的输入选项，以及默认选中的选项。</p><p>下面是 JOptionPane 类中各标准对话框的静态方法重载:</p><p>消息对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMessageDialog</span><span class="params">(Component parentComponent, </span></span></span><br><span class="line"><span class="params"><span class="function">                              Object message, </span></span></span><br><span class="line"><span class="params"><span class="function">                              String title, </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> messageType, </span></span></span><br><span class="line"><span class="params"><span class="function">                              Icon icon)</span></span></span><br></pre></td></tr></table></figure><p>确认对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">showConfirmDialog</span><span class="params">(Component parentComponent, </span></span></span><br><span class="line"><span class="params"><span class="function">                             Object message, </span></span></span><br><span class="line"><span class="params"><span class="function">                             String title, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> optionType, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">int</span> messageType, </span></span></span><br><span class="line"><span class="params"><span class="function">                             Icon icon)</span></span></span><br></pre></td></tr></table></figure><p>输入对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">showInputDialog</span><span class="params">(Component parentComponent, </span></span></span><br><span class="line"><span class="params"><span class="function">                              Object message, </span></span></span><br><span class="line"><span class="params"><span class="function">                              String title, </span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> messageType, </span></span></span><br><span class="line"><span class="params"><span class="function">                              Icon icon, </span></span></span><br><span class="line"><span class="params"><span class="function">                              Object[] selectionValues, </span></span></span><br><span class="line"><span class="params"><span class="function">                              Object initialSelectionValue)</span></span></span><br></pre></td></tr></table></figure><p>选项对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">showOptionDialog</span><span class="params">(Component parentComponent, </span></span></span><br><span class="line"><span class="params"><span class="function">                            Object message, </span></span></span><br><span class="line"><span class="params"><span class="function">                            String title, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int</span> optionType, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">int</span> messageType, </span></span></span><br><span class="line"><span class="params"><span class="function">                            Icon icon, </span></span></span><br><span class="line"><span class="params"><span class="function">                            Object[] options, </span></span></span><br><span class="line"><span class="params"><span class="function">                            Object initialValue)</span></span></span><br></pre></td></tr></table></figure><p><strong>代码实例：标准对话框</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 消息对话框（信息消息）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JButton btn01 = <span class="keyword">new</span> JButton(<span class="string">&quot;showMessageDialog（信息消息）&quot;</span>);</span><br><span class="line">        btn01.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 消息对话框无返回, 仅做通知作用</span></span><br><span class="line">                JOptionPane.showMessageDialog(</span><br><span class="line">                        jf,</span><br><span class="line">                        <span class="string">&quot;Information Message&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;消息标题&quot;</span>,</span><br><span class="line">                        JOptionPane.INFORMATION_MESSAGE</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2. 消息对话框（警告消息）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JButton btn02 = <span class="keyword">new</span> JButton(<span class="string">&quot;showMessageDialog（警告消息）&quot;</span>);</span><br><span class="line">        btn02.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 消息对话框无返回, 仅做通知作用</span></span><br><span class="line">                JOptionPane.showMessageDialog(</span><br><span class="line">                        jf,</span><br><span class="line">                        <span class="string">&quot;Warning Message&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;消息标题&quot;</span>,</span><br><span class="line">                        JOptionPane.WARNING_MESSAGE</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 3. 确认对话框</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JButton btn03 = <span class="keyword">new</span> JButton(<span class="string">&quot;showConfirmDialog（确认对话框）&quot;</span>);</span><br><span class="line">        btn03.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 返回用户点击的选项, 值为下面三者之一:</span></span><br><span class="line"><span class="comment">                 *     是:   JOptionPane.YES_OPTION</span></span><br><span class="line"><span class="comment">                 *     否:   JOptionPane.NO_OPTION</span></span><br><span class="line"><span class="comment">                 *     取消: JOptionPane.CANCEL_OPTION</span></span><br><span class="line"><span class="comment">                 *     关闭: JOptionPane.CLOSED_OPTION</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> result = JOptionPane.showConfirmDialog(</span><br><span class="line">                        jf,</span><br><span class="line">                        <span class="string">&quot;确认删除？&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;提示&quot;</span>,</span><br><span class="line">                        JOptionPane.YES_NO_CANCEL_OPTION</span><br><span class="line">                );</span><br><span class="line">                System.out.println(<span class="string">&quot;选择结果: &quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 4. 输入对话框（文本框输入）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JButton btn04 = <span class="keyword">new</span> JButton(<span class="string">&quot;showInputDialog（输入对话框）&quot;</span>);</span><br><span class="line">        btn04.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 显示输入对话框, 返回输入的内容</span></span><br><span class="line">                String inputContent = JOptionPane.showInputDialog(</span><br><span class="line">                        jf,</span><br><span class="line">                        <span class="string">&quot;输入你的名字:&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;默认内容&quot;</span></span><br><span class="line">                );</span><br><span class="line">                System.out.println(<span class="string">&quot;输入的内容: &quot;</span> + inputContent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 5. 输入对话框（下拉框选择）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JButton btn05 = <span class="keyword">new</span> JButton(<span class="string">&quot;showInputDialog（下拉框选择）&quot;</span>);</span><br><span class="line">        btn05.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                Object[] selectionValues = <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;雪梨&quot;</span>, <span class="string">&quot;苹果&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 显示输入对话框, 返回选择的内容, 点击取消或关闭, 则返回null</span></span><br><span class="line">                Object inputContent = JOptionPane.showInputDialog(</span><br><span class="line">                        jf,</span><br><span class="line">                        <span class="string">&quot;选择一项: &quot;</span>,</span><br><span class="line">                        <span class="string">&quot;标题&quot;</span>,</span><br><span class="line">                        JOptionPane.PLAIN_MESSAGE,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        selectionValues,</span><br><span class="line">                        selectionValues[<span class="number">0</span>]</span><br><span class="line">                );</span><br><span class="line">                System.out.println(<span class="string">&quot;输入的内容: &quot;</span> + inputContent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 6. 选项对话框</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JButton btn06 = <span class="keyword">new</span> JButton(<span class="string">&quot;showOptionDialog（选项对话框）&quot;</span>);</span><br><span class="line">        btn06.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 选项按钮</span></span><br><span class="line">                Object[] options = <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;香蕉&quot;</span>, <span class="string">&quot;雪梨&quot;</span>, <span class="string">&quot;苹果&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 显示选项对话框, 返回选择的选项索引, 点击关闭按钮返回-1</span></span><br><span class="line">                <span class="keyword">int</span> optionSelected = JOptionPane.showOptionDialog(</span><br><span class="line">                        jf,</span><br><span class="line">                        <span class="string">&quot;请点击一个按钮选择一项&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;对话框标题&quot;</span>,</span><br><span class="line">                        JOptionPane.YES_NO_CANCEL_OPTION,</span><br><span class="line">                        JOptionPane.ERROR_MESSAGE,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        options,    <span class="comment">// 如果传null, 则按钮为 optionType 类型所表示的按钮（也就是确认对话框）</span></span><br><span class="line">                        options[<span class="number">0</span>]</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (optionSelected &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;点击的按钮: &quot;</span> + options[optionSelected]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 垂直排列按钮</span></span><br><span class="line">        Box vBox = Box.createVerticalBox();</span><br><span class="line">        vBox.add(btn01);</span><br><span class="line">        vBox.add(btn02);</span><br><span class="line">        vBox.add(btn03);</span><br><span class="line">        vBox.add(btn04);</span><br><span class="line">        vBox.add(btn05);</span><br><span class="line">        vBox.add(btn06);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        panel.add(vBox);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\14.png" alt="14"></p><p><strong>代码实例：自定义对话框</strong></p><p>对话框 JDialog 和 JFrame 都是继承自 java.awt.Window，用法与 JFrame 类似。</p><p>对话框分为 模态 和 非模态:</p><ul><li>模态: 弹出对话框后，对话框的父级窗口不可操作。</li><li>非模态: 弹出对话框后，对话框的父级窗口可以正常操作。</li></ul><p>对话框不能最小化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JButton btn = <span class="keyword">new</span> JButton(<span class="string">&quot;显示自定义对话框&quot;</span>);</span><br><span class="line">        btn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                showCustomDialog(jf, jf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line">        panel.add(btn);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示一个自定义的对话框</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> owner 对话框的拥有者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentComponent 对话框的父级组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCustomDialog</span><span class="params">(Frame owner, Component parentComponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个模态对话框</span></span><br><span class="line">        <span class="keyword">final</span> JDialog dialog = <span class="keyword">new</span> JDialog(owner, <span class="string">&quot;提示&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置对话框的宽高</span></span><br><span class="line">        dialog.setSize(<span class="number">250</span>, <span class="number">150</span>);</span><br><span class="line">        <span class="comment">// 设置对话框大小不可改变</span></span><br><span class="line">        dialog.setResizable(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置对话框相对显示的位置</span></span><br><span class="line">        dialog.setLocationRelativeTo(parentComponent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个标签显示消息内容</span></span><br><span class="line">        JLabel messageLabel = <span class="keyword">new</span> JLabel(<span class="string">&quot;对话框消息内容&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个按钮用于关闭对话框</span></span><br><span class="line">        JButton okBtn = <span class="keyword">new</span> JButton(<span class="string">&quot;确定&quot;</span>);</span><br><span class="line">        okBtn.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 关闭对话框</span></span><br><span class="line">                dialog.dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对话框的内容面板, 在面板内可以根据自己的需要添加任何组件并做任意是布局</span></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加组件到面板</span></span><br><span class="line">        panel.add(messageLabel);</span><br><span class="line">        panel.add(okBtn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置对话框的内容面板</span></span><br><span class="line">        dialog.setContentPane(panel);</span><br><span class="line">        <span class="comment">// 显示对话框</span></span><br><span class="line">        dialog.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\15.png" alt="15"></p><h2 id="JMenuBar（菜单栏）"><a href="#JMenuBar（菜单栏）" class="headerlink" title="JMenuBar（菜单栏）"></a>JMenuBar（菜单栏）</h2><p>官方 JavaDocsApi：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JMenuBar.html">javax.swing.JMenuBar</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JMenu.html">javax.swing.JMenu</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JMenuItem.html">javax.swing.JMenuItem</a>，<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JCheckBoxMenuItem.html">javax.swing.JCheckBoxMenuItem</a>，<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JRadioButtonMenuItem.html">javax.swing.JRadioButtonMenuItem</a></li></ul><p>JMenuBar 表示一个菜单栏；</p><p>JMenu 表示菜单栏上的一个一级菜单；</p><p>JMenuItem, JCheckBoxMenuItem, JRadioButtonMenuItem 分别表示普通的子菜单、带复选框的子菜单、带单选按钮的子菜单。</p><p>JMenu、JCheckBoxMenuItem、JRadioButtonMenuItem 均继承自 JMenuItem。</p><p>JMenuItem 常用构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数说明:</span></span><br><span class="line"><span class="comment"> * text: 菜单显示的文本</span></span><br><span class="line"><span class="comment"> * icon: 菜单显示的图标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">JMenuItem()</span><br><span class="line"></span><br><span class="line">JMenuItem(String text)</span><br><span class="line"></span><br><span class="line">JMenuItem(Icon icon)</span><br><span class="line"></span><br><span class="line">JMenuItem(String text, Icon icon)</span><br></pre></td></tr></table></figure><p>JMenuItem 常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置菜单显示的文本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置菜单显示的图标</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(Icon defaultIcon)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置菜单的键盘助记符</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMnemonic</span><span class="params">(<span class="keyword">int</span> mnemonic)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置修改键，使用键盘快捷键直接触发菜单项的动作</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccelerator</span><span class="params">(KeyStroke keyStroke)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 例如按下 ALT+N 键触发菜单项动作:</span></span></span><br><span class="line"><span class="comment"><span class="function"> *     menuItem.setMnemonic(KeyEvent.VK_N);</span></span></span><br><span class="line"><span class="comment"><span class="function"> *     menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N, ActionEvent.ALT_MASK));</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加菜单被点击的监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addActionListener</span><span class="params">(ActionListener l)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 绑定菜单项的动作命令名称，如果所有菜单项使用同一个监听器，</span></span></span><br><span class="line"><span class="function"><span class="comment">// 可以再监听器回调时通过命令名称区别是哪个菜单项触发的动作。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setActionCommand</span><span class="params">(String actionCommand)</span></span></span><br></pre></td></tr></table></figure><p>JCheckBoxMenuItem、JRadioButtonMenuItem 常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 复选框/单选按钮 是否选中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSelected</span><span class="params">(<span class="keyword">boolean</span> b)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 复选框/单选按钮 是否选中</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSelected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加 复选框/单选按钮 状态被改变的监听器</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addChangeListener</span><span class="params">(ChangeListener l)</span></span></span><br></pre></td></tr></table></figure><p>JMenu 常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 子菜单 到 JMenu 中</span></span><br><span class="line"><span class="function">JMenuItem <span class="title">add</span><span class="params">(JMenuItem menuItem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 添加一个子菜单分割线</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSeparator</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.event.ChangeListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.KeyEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个菜单栏</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JMenuBar menuBar = <span class="keyword">new</span> JMenuBar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一级菜单</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JMenu fileMenu = <span class="keyword">new</span> JMenu(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line">        JMenu editMenu = <span class="keyword">new</span> JMenu(<span class="string">&quot;编辑&quot;</span>);</span><br><span class="line">        JMenu viewMenu = <span class="keyword">new</span> JMenu(<span class="string">&quot;视图&quot;</span>);</span><br><span class="line">        JMenu aboutMenu = <span class="keyword">new</span> JMenu(<span class="string">&quot;关于&quot;</span>);</span><br><span class="line">        <span class="comment">// 一级菜单添加到菜单栏</span></span><br><span class="line">        menuBar.add(fileMenu);</span><br><span class="line">        menuBar.add(editMenu);</span><br><span class="line">        menuBar.add(viewMenu);</span><br><span class="line">        menuBar.add(aboutMenu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建 &quot;文件&quot; 一级菜单的子菜单</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JMenuItem newMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;新建&quot;</span>);</span><br><span class="line">        JMenuItem openMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">        JMenuItem exitMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">        <span class="comment">// 子菜单添加到一级菜单</span></span><br><span class="line">        fileMenu.add(newMenuItem);</span><br><span class="line">        fileMenu.add(openMenuItem);</span><br><span class="line">        fileMenu.addSeparator();       <span class="comment">// 添加一条分割线</span></span><br><span class="line">        fileMenu.add(exitMenuItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建 &quot;编辑&quot; 一级菜单的子菜单</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JMenuItem copyMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;复制&quot;</span>);</span><br><span class="line">        JMenuItem pasteMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;粘贴&quot;</span>);</span><br><span class="line">        <span class="comment">// 子菜单添加到一级菜单</span></span><br><span class="line">        editMenu.add(copyMenuItem);</span><br><span class="line">        editMenu.add(pasteMenuItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建 &quot;视图&quot; 一级菜单的子菜单</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> JCheckBoxMenuItem checkBoxMenuItem = <span class="keyword">new</span> JCheckBoxMenuItem(<span class="string">&quot;复选框子菜单&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> JRadioButtonMenuItem radioButtonMenuItem01 = <span class="keyword">new</span> JRadioButtonMenuItem(<span class="string">&quot;单选按钮子菜单01&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> JRadioButtonMenuItem radioButtonMenuItem02 = <span class="keyword">new</span> JRadioButtonMenuItem(<span class="string">&quot;单选按钮子菜单02&quot;</span>);</span><br><span class="line">        <span class="comment">// 子菜单添加到一级菜单</span></span><br><span class="line">        viewMenu.add(checkBoxMenuItem);</span><br><span class="line">        viewMenu.addSeparator();                <span class="comment">// 添加一个分割线</span></span><br><span class="line">        viewMenu.add(radioButtonMenuItem01);</span><br><span class="line">        viewMenu.add(radioButtonMenuItem02);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其中两个 单选按钮子菜单，要实现单选按钮的效果，需要将它们放到一个按钮组中</span></span><br><span class="line">        ButtonGroup btnGroup = <span class="keyword">new</span> ButtonGroup();</span><br><span class="line">        btnGroup.add(radioButtonMenuItem01);</span><br><span class="line">        btnGroup.add(radioButtonMenuItem02);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认第一个单选按钮子菜单选中</span></span><br><span class="line">        radioButtonMenuItem01.setSelected(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 菜单项的点击/状态改变事件监听，事件监听可以直接设置在具体的子菜单上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 设置 &quot;新建&quot; 子菜单被点击的监听器</span></span><br><span class="line">        newMenuItem.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新建  被点击&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 设置 &quot;打开&quot; 子菜单被点击的监听器</span></span><br><span class="line">        openMenuItem.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;打开  被点击&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 设置 &quot;退出&quot; 子菜单被点击的监听器</span></span><br><span class="line">        exitMenuItem.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;退出  被点击&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 复选框子菜单 状态改变 监听器</span></span><br><span class="line">        checkBoxMenuItem.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;复选框是否被选中: &quot;</span> + checkBoxMenuItem.isSelected());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 单选按钮子菜单 状态改变 监听器</span></span><br><span class="line">        radioButtonMenuItem01.addChangeListener(<span class="keyword">new</span> ChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(ChangeEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;单选按钮01 是否被选中: &quot;</span> + radioButtonMenuItem01.isSelected());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最后 把菜单栏设置到窗口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        jf.setJMenuBar(menuBar);</span><br><span class="line"></span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\16.png" alt="16"></p><h2 id="JPopupMenu（弹出菜单）"><a href="#JPopupMenu（弹出菜单）" class="headerlink" title="JPopupMenu（弹出菜单）"></a>JPopupMenu（弹出菜单）</h2><p>官方JavaDocsApi：<a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JPopupMenu.html">javax.swing.JPopupMenu</a></p><p>弹出菜单是一个可弹出并显示一系列选项的悬浮小窗口。通常通过单击鼠标右键触发弹出显示。</p><p>JPopupMenu 的使用和 JMenuBar 类似。</p><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JFrame jf = <span class="keyword">new</span> JFrame(<span class="string">&quot;测试窗口&quot;</span>);</span><br><span class="line">        jf.setSize(<span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        jf.setLocationRelativeTo(<span class="keyword">null</span>);</span><br><span class="line">        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        JPanel panel = <span class="keyword">new</span> JPanel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接在内容面板上添加鼠标监听器</span></span><br><span class="line">        panel.addMouseListener(<span class="keyword">new</span> MouseListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 鼠标点击（按下并抬起）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mousePressed</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 鼠标按下</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseReleased</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 鼠标释放</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果是鼠标右键，则显示弹出菜单</span></span><br><span class="line">                <span class="keyword">if</span> (e.isMetaDown()) &#123;</span><br><span class="line">                    showPopupMenu(e.getComponent(), e.getX(), e.getY());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseEntered</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 鼠标进入组件区域</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseExited</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 鼠标离开组件区域</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        jf.setContentPane(panel);</span><br><span class="line">        jf.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showPopupMenu</span><span class="params">(Component invoker, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 弹出菜单 对象</span></span><br><span class="line">        JPopupMenu popupMenu = <span class="keyword">new</span> JPopupMenu();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 一级菜单</span></span><br><span class="line">        JMenuItem copyMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;复制&quot;</span>);</span><br><span class="line">        JMenuItem pasteMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;粘贴&quot;</span>);</span><br><span class="line">        JMenu editMenu = <span class="keyword">new</span> JMenu(<span class="string">&quot;编辑&quot;</span>);   <span class="comment">// 需要 添加 二级子菜单 的 菜单，使用 JMenu</span></span><br><span class="line">        JMenuItem fileMenu = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 二级菜单</span></span><br><span class="line">        JMenuItem findMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;查找&quot;</span>);</span><br><span class="line">        JMenuItem replaceMenuItem = <span class="keyword">new</span> JMenuItem(<span class="string">&quot;替换&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加 二级菜单 到 &quot;编辑&quot;一级菜单</span></span><br><span class="line">        editMenu.add(findMenuItem);</span><br><span class="line">        editMenu.add(replaceMenuItem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 一级菜单 到 弹出菜单</span></span><br><span class="line">        popupMenu.add(copyMenuItem);</span><br><span class="line">        popupMenu.add(pasteMenuItem);</span><br><span class="line">        popupMenu.addSeparator();       <span class="comment">// 添加一条分隔符</span></span><br><span class="line">        popupMenu.add(editMenu);</span><br><span class="line">        popupMenu.add(fileMenu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加菜单项的点击监听器</span></span><br><span class="line">        copyMenuItem.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;复制 被点击&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        findMenuItem.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;查找 被点击&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定位置显示弹出菜单</span></span><br><span class="line">        popupMenu.show(invoker, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\blog\source\_posts\Java swing\17.png" alt="17"></p><p><strong>参考资料：</strong></p><ul><li><p><a href="https://docs.oracle.com/javase/8/docs/api/index.html">Java swing 官方文档</a></p></li><li><p><a href="http://php-note.com/article/1719.html">Java Swing 图形界面开发 系列教程</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin语法</title>
    <link href="http://10185102110.github.io/2021/10/10/Kotlin%20%E8%AF%AD%E6%B3%95/"/>
    <id>http://10185102110.github.io/2021/10/10/Kotlin%20%E8%AF%AD%E6%B3%95/</id>
    <published>2021-10-10T12:06:36.000Z</published>
    <updated>2021-10-22T14:52:17.867Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Kotlin 中定义一个变量，只允许在变量前声明两种关键字：val 和 var。 </p><ul><li><p>val（value的简写）用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应 Java 中的 final 变量。 </p></li><li><p>var（variable的简写）用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应 Java 中的非 final 变量。</p></li></ul><p>编译器怎么知道变量的类型？</p><p>举个例子，对于以下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">10</span></span><br><span class="line">    println(<span class="string">&quot;a =&quot;</span> + a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用 val 关键字定义了一个变量 a，并将它赋值为 10，这里 a 就会被自动推导成整型变量。因为既然你要把一个整数赋值给 a，那么 a 就只能是整型变量，而如果你要把一个字符串赋值给 a 的话，那么 a 就会被自动推导成字符串变量，这就是 Kotlin 的类型推导机制。</p><p>但是 Kotlin 的类型推导机制并不总是可以正常工作的，比如说如果我们对一个变量延迟赋值的话，Kotlin 就无法自动推导它的类型，这时候就需要显式地声明变量类型才行，语法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>Kotlin 完全抛弃了 Java 中的基本数据类型，全部使用了对象数据类型。在 Java 中 int 是关键字，而在 Kotlin 中 Int 变成了一个类，它拥有自己的方法和继承结构。</p><p>Java 和 Kotlin 数据类型对照表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Java 基本数据类型</th><th style="text-align:center">Kotlin 对象数据类型</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">Int</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">Long</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">Short</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">Double</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">Boolean</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">Char</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">Byte</td></tr></tbody></table></div><h2 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h2><p>延迟初始化使用的是 lateinit 关键字，它可以告诉 Kotlin 编译器，晚些时候对这个变量进行初始化，这样就不用在一开始的时候将它赋值为 null 了。但是要确保它在被任何地方调用之前已经完成了初始化工作。</p><p>可以通过代码来判断一个全局变量是否已经完成了初始化，这样在某些时候能够有效地避免重复对某一个变量进行初始化操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), View.OnClickListener &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> adapter: MsgAdapter</span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">if</span> (!::adapter.isInitialized) &#123;</span><br><span class="line"> adapter = MsgAdapter(msgList)</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>自定义一个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1:<span class="type">Int</span>,num2:<span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(num1,num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun 是定义函数的关键字，紧跟的是函数名，后面括号里声明参数，参数的声明格式是“参数名：参数类型”；括号后面是可选的，用于声明返回值的类型，没有返回值可以不写。</p><p>当一个函数中只有一行代码时，Kotlin 允许我们不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = max(num1, num2)</span><br></pre></td></tr></table></figure><p>由于 max() 函数返回的是一个 Int 值，而我们在 largerNumber() 函数的尾部又使用等号连接了 max() 函数，因此 Kotlin 可以推导出 largerNumber() 函数返回的必然也是一个 Int 值，这样就不用再显式地声明返回值类型。</p><h2 id="函数的参数默认值"><a href="#函数的参数默认值" class="headerlink" title="函数的参数默认值"></a>函数的参数默认值</h2><p>给参数设置默认值，可以不给该参数传值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span>, str: <span class="type">String</span> = <span class="string">&quot;hello&quot;</span>)</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;num is <span class="variable">$num</span> , str is <span class="variable">$str</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> printParams(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：num is 123, str is hello</span></span><br></pre></td></tr></table></figure><p>如果第一个参数也有默认值，上述写法就行不通了，可以用键值对的方式来传参。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printParams</span><span class="params">(num: <span class="type">Int</span> = <span class="number">100</span>, str: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;num is <span class="variable">$num</span> , str is <span class="variable">$str</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> printParams(str = <span class="string">&quot;world&quot;</span>, num = <span class="number">123</span>) <span class="comment">//顺序没有影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主构造函数也可以设置默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> sno: String = <span class="string">&quot;&quot;</span>, <span class="keyword">val</span> grade: <span class="built_in">Int</span> = <span class="number">0</span>, name: String = <span class="string">&quot;&quot;</span>, age: <span class="built_in">Int</span> = <span class="number">0</span>) : Person(name, age) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="定义静态方法"><a href="#定义静态方法" class="headerlink" title="定义静态方法"></a>定义静态方法</h2><p>单例类的写法会将整个类中的所有方法全部变成类似于静态方法的调用方式，而如果只是希望让类中的某一个方法变成静态方法的调用方式该怎么办呢？这时就可以使用 companion object，示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doAction1</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;do action1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">doAction2</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;do action2&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类中直接定义了一个 doAction1() 方法，又在 companion objec t中定义了一个 doAction2() 方法。现在这两个方法就有了本质的区别，因为 doAction1() 方法是一定要先创建 Util 类的实例才能调用的，而 doAction2() 方法可以直接使用 Util.doAction2() 的方式调用。</p><p>不过，doAction2() 方法其实也并不是静态方法，companion object 这个关键字实际上会在 Util 类的内部创建一个伴生类，而 doAction2() 方法就是定义在这个伴生类里面的实例方法。只是 Kotlin 会保证 Util 类始终只会存在一个伴生类对象，因此调用 Util.doAction2() 方法实际上就是调用了 Util 类中伴生对象的 doAction2() 方法。</p><p>如果确实需要定义真正的静态方法， Kotlin 仍然提供了两种实现方式：注解和顶层方法。</p><ul><li><p>注解。如果给单例类或 companion object 中的方法加上 @JvmStatic 注解，那么 Kotlin 编译器就会将这些方法编译成真正的静态方法。注意，@JvmStatic 注解只能加在单例类或 companion object 中的方法上，如果尝试加在一个普通方法上，会直接提示语法错误。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">doAction1</span><span class="params">()</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;do action1&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"> <span class="meta">@JvmStatic</span></span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">doAction2</span><span class="params">()</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;do action2&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>顶层方法。顶层方法指的是那些没有定义在任何类中的方法，比如 main() 方法。Kotlin 编译器会将所有的顶层方法全部编译成静态方法。</p><p>想要定义一个顶层方法，先创建一个 Kotlin 文件，现在这个文件中定义的任何方法都会是顶层方法，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在 Kotlin 代码中调用，很简单，所有的顶层方法都可以在任何位置被直接调用，不用管包名路径，也不用创建实例，直接键入 doSomething() 即可。</p><p>但如果是在 Java 代码中调用，需要用 文件名.方法名 的形式来调用。</p></li></ul><h1 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h1><h2 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h2><p>与 Java 中的 if 区别不大，上面的函数可以写成以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line"> value = num1</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> value = num2</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但 Kotlin 中的 if 是可以有返回值的，可以改写成以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> value = <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">        num1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">largerNumber</span><span class="params">(num1: <span class="type">Int</span>, num2: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (num1 &gt; num2) num1 <span class="keyword">else</span> num2</span><br></pre></td></tr></table></figure><h2 id="when-条件语句"><a href="#when-条件语句" class="headerlink" title="when 条件语句"></a>when 条件语句</h2><p>类似于 Java 中的 switch 语句，但它又远比 switch 语句强大得多。</p><p>when 语句允许传入一个任意类型的参数，然后可以在 when 的结构体中定义一系列的条件，格式是： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配值 -&gt; &#123; 执行逻辑 &#125;</span><br></pre></td></tr></table></figure><p>当执行逻辑只有一行代码时，{ }可以省略。</p><p>编写一个查询考试成绩的功能，输入一个学生的姓名，返回该学生考试的分数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> (name) &#123;</span><br><span class="line">    <span class="string">&quot;Tom&quot;</span> -&gt; <span class="number">86</span></span><br><span class="line">    <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line">    <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line">    <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when 语句还允许进行类型匹配。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Number是Kotlin内置的一个抽象类，Int、Long、Float、Double等与数字相关的类都是它的子类</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">checkNumber</span><span class="params">(num: <span class="type">Number</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (num) &#123;</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt; println(<span class="string">&quot;number is Int&quot;</span>)</span><br><span class="line">        <span class="keyword">is</span> <span class="built_in">Double</span> -&gt; println(<span class="string">&quot;number is Double&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;number not support&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when 语句还有一种不带参数的用法。</p><p>假设所有名字以 Tom 开头的人的分数都是 86 分，这种场景如果用带参数的 when语句就无法实现，而使用不带参数的 when 语句就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getScore</span><span class="params">(name: <span class="type">String</span>)</span></span> = <span class="keyword">when</span> &#123;</span><br><span class="line"> name.startsWith(<span class="string">&quot;Tom&quot;</span>) -&gt; <span class="number">86</span></span><br><span class="line"> name == <span class="string">&quot;Jim&quot;</span> -&gt; <span class="number">77</span></span><br><span class="line"> name == <span class="string">&quot;Jack&quot;</span> -&gt; <span class="number">95</span></span><br><span class="line"> name == <span class="string">&quot;Lily&quot;</span> -&gt; <span class="number">100</span></span><br><span class="line"> <span class="keyword">else</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>Kotlin 提供了 while 循环和 for 循环，其中 while 循环不管是在语法还是使用技巧上都和 Java 中的 while 循环没有任何区别。</p><p>Kotlin 在 for 循环方面做了很大幅度的修改，Java 中最常用的 for-i 循环在 Kotlin 中直接被舍弃了，而 Java 中另一种 for-each 循环则被 Kotlin 进行了大幅度的加强，变成了 for-in 循环。</p><p>区间的概念：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个0到10的区间，并且两端都是闭区间</span></span><br><span class="line"><span class="keyword">val</span> range = <span class="number">0.</span><span class="number">.10</span></span><br><span class="line"><span class="comment">//左闭右开区间</span></span><br><span class="line"><span class="keyword">val</span> range = <span class="number">0</span> until <span class="number">10</span></span><br><span class="line"><span class="comment">//降序闭区间</span></span><br><span class="line"><span class="keyword">val</span> range = <span class="number">10</span> downTo <span class="number">1</span></span><br></pre></td></tr></table></figure><p>有了区间之后，我们就可以通过 for-in 循环来遍历这个区间：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;</span><br><span class="line"> println(i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，for-in 循环每次执行循环时会在区间范围内递增 1，如果想跳过其中的一些元素，可以使用 step 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span> step <span class="number">2</span>) &#123;</span><br><span class="line"> println(i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot; is eating. He is &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person()</span><br><span class="line">    p.name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    p.age = <span class="number">19</span></span><br><span class="line">    p.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 中实例化一个类的方式和 Java 是基本类似的，只是去掉了 new 关键字而已。</p><h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><p>Java 和 Kotlin 函数可见性修饰符对照表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">Java</th><th style="text-align:center">Kotlin</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">所有类可见</td><td style="text-align:center">所有类可见（默认）</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">当前类可见</td><td style="text-align:center">当前类可见</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">当前类、子类、同一包路径下的类可见</td><td style="text-align:center">当前类、子类可见</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">同一包路径下的类可见（默认）</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">internal</td><td style="text-align:center">无</td><td style="text-align:center">同一模块中的类可见</td></tr></tbody></table></div><h2 id="继承与构造函数"><a href="#继承与构造函数" class="headerlink" title="继承与构造函数"></a>继承与构造函数</h2><p>Kotlin 默认所有非抽象类都是不可以被继承的，如果想让一个类被继承，加上 open 关键字就可以。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line"> <span class="keyword">var</span> sno = <span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 将构造函数分成了两种：<strong>主构造函数</strong>和<strong>次构造函数</strong>。</p><p>主构造函数是最常用的构造函数，每个类默认都会有一个不带参数的主构造函数，当然也可以显式地给它指明参数。主构造函数的特点是没有函数体，直接定义在类名的后面即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于构造函数中的参数是在创建实例的时候传入的，因此可以将参数全部声明成 val。</p><p>主构造函数没有函数体，如果想在主构造函数中编写一些逻辑，使用 init 结构体，所有主构造函数中的逻辑都可以写在里面。</p><p>将 Person 改造一下，将姓名和年龄都放到主构造函数当中，Person类现在已经没有无参的构造函数。由于子类中的构造函数必须调用父类中的构造函数，在 Student 类的主构造函数中加上 name 和 age 这两个参数，再将这两个参数传给 Person 类的构造函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name,age) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;sno is &quot;</span> + sno)</span><br><span class="line">        println(<span class="string">&quot;grade is &quot;</span> + grade)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;a123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在 Student 类的主构造函数中增加 name 和 age 这两个字段时，不能再将它们声明成 val，因为在主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，这就会导致和父类中同名的 name 和 age 字段造成冲突。</p><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，只不过它是有函数体的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> sno: String, <span class="keyword">val</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) : Person(name,age) &#123;</span><br><span class="line">    <span class="comment">//第一个次构造函数接收name和age参数，通过this关键字调用主构造函数，并将sno和grade这两个参数赋值成初始值</span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, name, age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个次构造函数不接收任何参数，通过this关键字调用第一个次构造函数，并将name和age参数也赋值成初始值</span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//三种实例化方式</span></span><br><span class="line">    <span class="keyword">val</span> student1 = Student()</span><br><span class="line">    <span class="keyword">val</span> student2 = Student(<span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    <span class="keyword">val</span> student3 = Student(<span class="string">&quot;a123&quot;</span>, <span class="number">5</span>, <span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的，因此继承 Person 类时就不用加上括号了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;</span></span></span><br><span class="line">    <span class="comment">//由于没有主构造函数，次构造函数只能直接调用父类的构造函数</span></span><br><span class="line"> <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age) &#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name: String, age: <span class="built_in">Int</span>) : Person(name, age), Study &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot; is reading.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name + <span class="string">&quot; is doing homework.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student = Student(<span class="string">&quot;Jack&quot;</span>, <span class="number">19</span>)</span><br><span class="line">    doStudy(student)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于Student类实现了Study接口，因此Student类的实例是可以传递给doStudy()函数的</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于继承和实现接口，Kotlin 统一使用冒号，中间用逗号进行分隔。接口的后面不用加上括号，因为它没有构造 函数。</p><p>对接口中的函数进行默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">readBooks</span><span class="params">()</span></span></span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">doHomework</span><span class="params">()</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;do homework default implementation.&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果接口中的一个函数拥有了函数体，这个函数体中的内容就是它的默认实现。现在当一个类去实现 Study接口时，只会强制要求实现 readBooks() 函数，而 doHomework() 函数则可以自由选择实现或者不实现，不实现时就会自动使用默认的实现逻辑。</p><h2 id="数据类与单例类"><a href="#数据类与单例类" class="headerlink" title="数据类与单例类"></a>数据类与单例类</h2><p>在一个规范的系统架构中，数据类通常占据着非常重要的角色，它们用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。</p><p>数据类通常需要重写 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code> 这几个方法。equals() 方法用于判断两个数据类是否相等。hashCode() 方法是 equals() 的配套方法，需要一起重写，否则会导致 HashMap、HashSet 等 hash 相关的系统类无法正常工作。toString() 方法用于提供更清晰的输入日志。</p><p>构建一个手机数据类，只有品牌和价格两个字段。</p><p>如果用 Java 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cellphone</span> </span>&#123;</span><br><span class="line"> String brand;</span><br><span class="line"> <span class="keyword">double</span> price;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Cellphone</span><span class="params">(String brand, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.brand = brand;</span><br><span class="line"> <span class="keyword">this</span>.price = price;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Cellphone) &#123;</span><br><span class="line"> Cellphone other = (Cellphone) obj;</span><br><span class="line"> <span class="keyword">return</span> other.brand.equals(brand) &amp;&amp; other.price == price;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> brand.hashCode() + (<span class="keyword">int</span>) price;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Cellphone(brand=&quot;</span> + brand + <span class="string">&quot;, price=&quot;</span> + price + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的功能使用 Kotlin 来实现只需要一行代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Cellphone</span></span>(<span class="keyword">val</span> brand: String, <span class="keyword">val</span> price: <span class="built_in">Double</span>)</span><br></pre></td></tr></table></figure><p>data 关键字声明这个类是数据类，Kotlin 会根据主构造函数中的参数帮你将 equals()、hashCode()、toString() 等固定且无实际逻辑意义的方法自动生成。</p><p>单例类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">singletonTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;singletonTest is called.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Singleton.singletonTest() <span class="comment">//类似于Java静态方法的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lambda编程"><a href="#Lambda编程" class="headerlink" title="Lambda编程"></a>Lambda编程</h1><h2 id="集合的创建与遍历"><a href="#集合的创建与遍历" class="headerlink" title="集合的创建与遍历"></a>集合的创建与遍历</h2><p>创建一个包含许多水果名称的集合，可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Orange&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Pear&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Grape&quot;</span>)</span><br></pre></td></tr></table></figure><p>Kotlin 专门提供了一个内置的 <code>listOf()</code> 函数来简化初始化集合的写法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>listOf()</code> 函数创建的是一个不可变的集合，可变集合需要用 <code>mutableListOf()</code> 函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">list.add(<span class="string">&quot;Watermelon&quot;</span>)</span><br></pre></td></tr></table></figure><p>Set 集合的用法一样，只是将创建集合的方式换成了 <code>setOf()</code> 和 <code>mutableSetOf()</code> 函数而已。</p><p>Map 集合使用类似于数组下标的语法结构：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = HashMap&lt;String, <span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">map[<span class="string">&quot;Apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">map[<span class="string">&quot;Banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">map[<span class="string">&quot;Orange&quot;</span>] = <span class="number">3</span></span><br><span class="line">map[<span class="string">&quot;Pear&quot;</span>] = <span class="number">4</span></span><br><span class="line">map[<span class="string">&quot;Grape&quot;</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>Kotlin 提供了一对 mapOf() 和 mutableMapOf() 函数来继续简化 Map 的用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="string">&quot;Apple&quot;</span> to <span class="number">1</span>, <span class="string">&quot;Banana&quot;</span> to <span class="number">2</span>, <span class="string">&quot;Orange&quot;</span> to <span class="number">3</span>, <span class="string">&quot;Pear&quot;</span> to <span class="number">4</span>, <span class="string">&quot;Grape&quot;</span> to <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> ((fruit, number) <span class="keyword">in</span> map) &#123;</span><br><span class="line">        println(<span class="string">&quot;fruit is &quot;</span> + fruit + <span class="string">&quot;, number is &quot;</span> + number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合的函数式-API"><a href="#集合的函数式-API" class="headerlink" title="集合的函数式 API"></a>集合的函数式 API</h2><p>思考一个需求：在一个水果集合里面找到单词最长的那个水果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lambda = &#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxByOrNull(lambda)</span><br></pre></td></tr></table></figure><p>Lambda 就是一小段可以作为参数传递的代码，Lambda 表达式的语法结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>参数列表的结尾使用一个 -&gt; 符号，表示参数列表的结束以及函数体的开始，函数体中可以编写任意行代码，并且最后一行代码会自动作为 Lambda 表达式的返回值。</p><p>可以看到，maxByOrNull 函数实质上就是接收了一个 Lambda 参数而已，并且这个 Lambda 参数是完全按照刚才学习的表达式的语法结构来定义的。</p><p>简化代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以直接将lambda表达式传入函数当中</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxByOrNull(&#123; fruit: String -&gt; fruit.length &#125;)</span><br><span class="line"><span class="comment">//当Lambda参数是函数的最后一个参数时，可以将Lambda表达式移到函数括号的外面</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxByOrNull() &#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"><span class="comment">//如果Lambda参数是函数的唯一一个参数的话，还可以将函数的括号省略</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxByOrNull &#123; fruit: String -&gt; fruit.length &#125;</span><br><span class="line"><span class="comment">//由于类型推导机制，不必声明参数类型</span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxByOrNull &#123; fruit -&gt; fruit.length &#125;</span><br><span class="line"><span class="comment">//当Lambda表达式的参数列表中只有一个参数时，可以使用it关键字来代替                           </span></span><br><span class="line"><span class="keyword">val</span> maxLengthFruit = list.maxByOrNull &#123; it.length &#125;                                 </span><br></pre></td></tr></table></figure><p>集合中几个常见的函数式 API：</p><ul><li><p>map 函数。用于将集合中的每个元素都映射成一个另外的值，映射的规则在 Lambda 表达式中指定，最终生成一个新的集合。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> newList = list.map &#123; it.uppercase() &#125; <span class="comment">//变成大写</span></span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> newList) &#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>filter 函数。用来过滤集合中的数据。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> newList = list.filter &#123; it.length &lt;= <span class="number">5</span> &#125;.map &#123; it.uppercase() &#125;</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> newList) &#123;</span><br><span class="line">        println(fruit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>any 和 all 函数。any 函数用于判断集合中是否至少存在一个元素满足指定条件，all 函数用于判断集合中是否所有元素都满足指定条件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>, <span class="string">&quot;Watermelon&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> anyResult = list.any &#123; it.length &lt;= <span class="number">5</span> &#125;</span><br><span class="line">    <span class="keyword">val</span> allResult = list.all &#123; it.length &lt;= <span class="number">5</span> &#125;</span><br><span class="line">    println(<span class="string">&quot;anyResult is &quot;</span> + anyResult + <span class="string">&quot;, allResult is &quot;</span> + allResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java-函数式-API-的使用"><a href="#Java-函数式-API-的使用" class="headerlink" title="Java 函数式 API 的使用"></a>Java 函数式 API 的使用</h2><p>条件限制：如果我们在 Kotlin 代码中调用了一个 Java 方法，并且该方法接收一个 Java 单抽象方法接口参数，就可以使用函数式 API。</p><p>举个例子：</p><p>Java 原生 API 中有一个最为常见的单抽象方法接口——Runnable接口。这个接口中只有一个待实现的 run() 方法，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于任何一个 Java 方法，只要它接收 Runnable 参数，就可以使用函数式 API。不过 Runnable 接口主要还是结合线程来一起使用的。</p><p>Thread 类的构造方法中接收了一个Runnable 参数，可以使用如下 Java 代码创建并执行一个子线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>翻译成 Kotlin 版本：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread(<span class="keyword">object</span> : Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line"> println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;).start()</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.因为Runnable类中只有一个待实现方法，即使这里没有显式地重写run()方法，Kotlin也能自动明白Runnable后面的Lambda表达式就是要在run()方法中实现的内容。</span></span><br><span class="line"><span class="comment"> *2.如果一个Java方法的参数列表中有且仅有一个Java单抽象方法接口参数，可以将接口名进行省略</span></span><br><span class="line"><span class="comment"> *3.当Lambda表达式是方法的最后一个参数时，可以将Lambda表达式移到方法括号的外面</span></span><br><span class="line"><span class="comment"> *4.如果Lambda表达式还是方法的唯一一个参数，还可以将方法的括号省略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Thread &#123;</span><br><span class="line"> println(<span class="string">&quot;Thread is running&quot;</span>)</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><h1 id="空指针检查"><a href="#空指针检查" class="headerlink" title="空指针检查"></a>空指针检查</h1><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line"> study.readBooks()</span><br><span class="line"> study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 默认所有的参数和变量都不可为空，所以这里传入的 Study 参数也一定不会为空，我们可以放心地调用它的任何函数。也就是说，Kotlin 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>如果需要可为空的类型，只需要在类名后面加个 ‘?’。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    doStudy(<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(study != <span class="literal">null</span>)&#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line"> study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判空辅助工具"><a href="#判空辅助工具" class="headerlink" title="判空辅助工具"></a>判空辅助工具</h2><ul><li><p><code>?.</code> 操作符：当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>使用 <code>?.</code> 操作符对 doStudy() 函数进行优化， 代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line"> study?.readBooks()</span><br><span class="line"> study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>?:</code> 操作符：左右两边都接收一个表达式， 如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) &#123; a &#125; <span class="keyword">else</span> &#123; b &#125;</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure></li></ul><p>要编写一个函数用来获得一段文本的长度，使用传统的写法就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (text != <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> text.length</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 <code>?.</code> 和 <code>`?:</code> 操作符简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextLength</span><span class="params">(text: <span class="type">String</span>?)</span></span> = text?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>不过 Kotlin 的空指针检查机制也并非总是那么智能，有的时候我们可能从逻辑上已经将空指针异常处理了，但是 Kotlin 的编译器并不知道，这个时候它还是会编译失败。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content: String? = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (content != <span class="literal">null</span>) &#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = content.uppercase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 printUpperCase() 函数并不知道外部已经对 content 变量进行了非空检查，在调用 uppercase() 方法时，还认为这里存在空指针风险，从而无法编译通过。</p><p>在这种情况下，如果我们想要强行通过编译，可以使用非空断言工具：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = content!!.uppercase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>let 函数。将原始调用对象作为参数传递到 Lambda 表达式中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.let &#123; obj2 -&gt;</span><br><span class="line"> <span class="comment">// 编写具体的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 obj 对象的 let 函数，然后 Lambda 表达式中的代码就会立即执行，并且这个 obj 对象本身还会作为参数传递到 Lambda 表达式中。不过，为了防止变量重名，这里将参数名改成了 obj2，但实际上它们是同一个对象。</p><p>let 函数的特性配合 <code>?.</code> 操作符 可以在空指针检查的时候起到很大的作用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line"> study?.readBooks()</span><br><span class="line"> study?.doHomework()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line"> study?.let &#123; stu -&gt;</span><br><span class="line"> stu.readBooks()</span><br><span class="line"> stu.doHomework()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line"> study?.let &#123;</span><br><span class="line"> it.readBooks()</span><br><span class="line"> it.doHomework()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let 函数是可以处理全局变量的判空问题的，而 if 判断语句则无法做到这一点。</p></li></ul><h1 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h1><h2 id="字符串内嵌表达式"><a href="#字符串内嵌表达式" class="headerlink" title="字符串内嵌表达式"></a>字符串内嵌表达式</h2><p>用 <code>$&#123;&#125;</code> 代替加号连接符，实现字符串拼接，如果表达式只有一个变量，可以省略大括号。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> brand = <span class="string">&quot;Samsung&quot;</span></span><br><span class="line"><span class="keyword">val</span> price = <span class="number">1299.99</span></span><br><span class="line">println(<span class="string">&quot;Cellphone(brand=<span class="variable">$brand</span>, price=<span class="variable">$price</span>)&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="标准函数-with、run-和-apply"><a href="#标准函数-with、run-和-apply" class="headerlink" title="标准函数 with、run 和 apply"></a>标准函数 with、run 和 apply</h2><ul><li><p>with 函数</p><p>接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个 Lambda 表达式。with 函数会在 Lambda 表达式中提供第一个参数对象的上下文，并使用 Lambda 表达式中的最后一行代码作为返回值返回。示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(obj) &#123;</span><br><span class="line"> <span class="comment">// 这里是obj的上下文</span></span><br><span class="line"> <span class="string">&quot;value&quot;</span> <span class="comment">// with函数的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以在连续调用同一个对象的多个方法时让代码变得更加精简。</p><p>比如有一个水果列表，现在我们想吃完所有水果，并将结果打印出来，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = builder.toString()</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码连续调用了很多次 builder 对象的方法。这时可以考虑使用 with 函数来让代码变得更加精简：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = with(StringBuilder()) &#123;</span><br><span class="line">        append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">            append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>run 函数</p><p>run 函数通常不会直接调用， 而是要在某个对象的基础上调用；run函数只接收一个 Lambda 参数，并且会在 Lambda 表达式中提供调用对象的上下文。其他方面和 with 函数是一样的，包括也会使用 Lambda 表达式中的最后一行代码作为返回值返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder().run &#123;</span><br><span class="line">        append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">            append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>apply 函数</p><p>apply 函数和 run 函数也是极其类似的，都要在某个对象上调用，并且只接收一个 Lambda 参数，也会在Lambda 表达式中提供调用对象的上下文，但是 apply 函数无法指定返回值，而是自动返回调用对象本身。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder().apply &#123;</span><br><span class="line">        append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">            append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(result.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 启动 Activity 的代码也可以优化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, SecondActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line"> putExtra(<span class="string">&quot;param1&quot;</span>, <span class="string">&quot;data1&quot;</span>)</span><br><span class="line"> putExtra(<span class="string">&quot;param2&quot;</span>, <span class="string">&quot;data2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure></li></ul><h2 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h2><p>统计字符串中字母的数量，可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> StringUtil &#123;</span><br><span class="line"> <span class="function"><span class="keyword">fun</span> <span class="title">lettersCount</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> (char <span class="keyword">in</span> str) &#123;</span><br><span class="line"> <span class="keyword">if</span> (char.isLetter()) &#123;</span><br><span class="line"> count++</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> count</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> str = <span class="string">&quot;ABC123xyz!@#&quot;</span></span><br><span class="line"><span class="keyword">val</span> count = StringUtil.lettersCount(str)</span><br></pre></td></tr></table></figure><p>还可以将 <code>lettersCount()</code> 函数添加到 String 类。</p><p>定义扩展函数的语法结构：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ClassName.<span class="title">methodName</span><span class="params">(param1: <span class="type">Int</span>, param2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义扩展函数只需要在函数名的前面加上一个 ClassName. 的语法结构，就表示将该函数添加到指定类当中。</p><p>优化后的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lettersCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"> <span class="keyword">for</span> (char <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (char.isLetter()) &#123;</span><br><span class="line"> count++</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> count = <span class="string">&quot;ABC123xyz!@#&quot;</span>.lettersCount()</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>例如重载加法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Money</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) &#123;</span><br><span class="line"> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(money: <span class="type">Money</span>)</span></span>: Money &#123;</span><br><span class="line"> <span class="keyword">val</span> sum = value + money.value</span><br><span class="line"> <span class="keyword">return</span> Money(sum)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> money1 = Money(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> money2 = Money(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> money3 = money1 + money2</span><br><span class="line">println(money3.value)</span><br></pre></td></tr></table></figure><p>语法糖表达式和实际调用函数对照表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">语法糖表达式</th><th style="text-align:center">实际调用函数</th></tr></thead><tbody><tr><td style="text-align:center">a + b</td><td style="text-align:center">a.plus(b)</td></tr><tr><td style="text-align:center">a - b</td><td style="text-align:center">a.minus(b)</td></tr><tr><td style="text-align:center">a * b</td><td style="text-align:center">a.times(b)</td></tr><tr><td style="text-align:center">a / b</td><td style="text-align:center">a.div(b)</td></tr><tr><td style="text-align:center">a % b</td><td style="text-align:center">a.rem(b)</td></tr><tr><td style="text-align:center">a++</td><td style="text-align:center">a.inc()</td></tr><tr><td style="text-align:center">a—</td><td style="text-align:center">a.dec()</td></tr><tr><td style="text-align:center">+a</td><td style="text-align:center">a.unaryPlus()</td></tr><tr><td style="text-align:center">-a</td><td style="text-align:center">a.unaryMinus()</td></tr><tr><td style="text-align:center">!a</td><td style="text-align:center">a.not()</td></tr><tr><td style="text-align:center">a == b</td><td style="text-align:center">a.equals(b)</td></tr><tr><td style="text-align:center">a &gt; b</td><td style="text-align:center">a.equals(b)</td></tr><tr><td style="text-align:center">a &lt; b</td><td style="text-align:center">a.equals(b)</td></tr><tr><td style="text-align:center">a &gt;= b</td><td style="text-align:center">a.equals(b)</td></tr><tr><td style="text-align:center">a &lt;= b</td><td style="text-align:center">a.compareTo(b)</td></tr><tr><td style="text-align:center">a..b</td><td style="text-align:center">a.rangeTo(b)</td></tr><tr><td style="text-align:center">a[b]</td><td style="text-align:center">a.get(b)</td></tr><tr><td style="text-align:center">a[b] = c</td><td style="text-align:center">a.set(b, c)</td></tr><tr><td style="text-align:center">a in b</td><td style="text-align:center">b.contains(a)</td></tr></tbody></table></div><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数，那么该函数就称为高阶函数。</p><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">example</span><span class="params">(func: (<span class="type">String</span>, <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line"> func(<span class="string">&quot;hello&quot;</span>, <span class="number">123</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-&gt; 左边的部分用来声明该函数接收的参数，多个参数之间使用逗号隔开，如果不接收任何参数，写一对空括号即可；而 -&gt; 右边的部分用于声明该函数的返回值类型，如果没有返回值就使用 Unit，它相当于 Java 中的 void。</p><p><strong>参考资料：</strong></p><p>[1] 郭霖 ：第一行代码 Android（第3版)）. 北京：人民邮电出版社，2020</p><p>[2] <a href="https://kotlinlang.org/docs/home.html">Kotlin docs | Kotlin (kotlinlang.org)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h1&gt;&lt;p&gt;Kotlin 中定义一个变量，只允许在变量前声明两种关键字：val 和 var。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p</summary>
      
    
    
    
    <category term="Android" scheme="http://10185102110.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://10185102110.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>高质量代码</title>
    <link href="http://10185102110.github.io/2021/09/23/%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/"/>
    <id>http://10185102110.github.io/2021/09/23/%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/</id>
    <published>2021-09-23T07:58:03.000Z</published>
    <updated>2021-09-27T13:20:25.045Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h2 id="程序的书写格式"><a href="#程序的书写格式" class="headerlink" title="程序的书写格式"></a>程序的书写格式</h2><h3 id="版本的声明格式"><a href="#版本的声明格式" class="headerlink" title="版本的声明格式"></a>版本的声明格式</h3><p>每个 C++/C 的通常分为两个文件，一个文件用于保存程序的声明，称为头文件；另一个用于保存程序的实现，称为定义文件。</p><p>在头文件和 C 程序文件中都必须包含版权和版本的声明。</p><p>版权和版本的声明位于头文件和定义文件的开头，主要内容如下：</p><ul><li>版权信息；</li><li>文件名称、标识符、摘要；</li><li>当前版本号、作者/修改者、完成日期；</li><li>版本历史信息。</li></ul><blockquote><p>【范例 1】</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Copyright @2016，北京侏罗纪公司XX部</span></span><br><span class="line"><span class="comment">//All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//文件名称：filename.h</span></span><br><span class="line"><span class="comment">//文件标识：见配置管理计划书</span></span><br><span class="line"><span class="comment">//摘   要：简要描述本文件的内容</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//当前版本：2.1</span></span><br><span class="line"><span class="comment">//作   者：输入作者名字</span></span><br><span class="line"><span class="comment">//完成日期：2016年3月20日</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//取代版本：2.0</span></span><br><span class="line"><span class="comment">//原作者 ：输入作者名字</span></span><br><span class="line"><span class="comment">//完成日期：2016年2月10日</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="头文件的书写格式"><a href="#头文件的书写格式" class="headerlink" title="头文件的书写格式"></a>头文件的书写格式</h3><p>用户可以通过头文件来调用库功能。</p><p>在很多场合源代码不便向用户公布，向用户提供头文件和二进制的库即可，用户只需要按照头文件中的接口声明来调用库功能，而不必关系接口是怎么实现的，编译器会从库中提取相应的代码。</p><p>头文件能加强类型安全检查，如果某个接口被实现或被使用时其方式与头文件中的声明不一致，编译器就会指出错误。</p><p>头文件必须包含下列内容：</p><ul><li>版权和版本声明；</li><li>预处理块；</li><li>函数和类结构声明等。</li></ul><p>正确使用预处理块：为了防止头文件被重复引用，应当用 <code>ifndef-define-endif</code> 结构产生预处理块。</p><p>正确引用头文件的格式：</p><p>（1）用 #include<filename.h> 格式引用标准库的头文件（编译器从标准库目录搜索）；</p><p>（2）用 #include “filename.h” 格式引用非标准库的头文件（编译器从用户的工作目录搜索）。</p><p>在头文件中只存放“声明“，而不存放”定义“。为了代码风格一致，建议将成员函数的定义与声明分开。</p><blockquote><p>【范例 2】</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权和版本声明见范例1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> GRAPHICS_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> GRAPHICS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;myheader.h&quot;</span></span></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">(...)</span></span>;</span><br><span class="line">   ...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="定义文件的书写格式"><a href="#定义文件的书写格式" class="headerlink" title="定义文件的书写格式"></a>定义文件的书写格式</h3><p>定义文件必须包含以下内容：</p><ul><li><p>版权和版本声明；</p></li><li><p>对一些头文件的引用；</p></li><li>程序的实现体（数据和代码）。</li></ul><blockquote><p>【范例 3】</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权和版本声明见范例1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;graphics.h&quot;</span></span></span><br><span class="line">   ...</span><br><span class="line">       </span><br><span class="line"><span class="comment">//全局函数的实现体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类成员函数的实现体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空行的使用"><a href="#空行的使用" class="headerlink" title="空行的使用"></a>空行的使用</h3><p>空行起着分隔程序段落的作用，而且不会浪费内存。</p><p>在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方应加空行分割。</p><ul><li>关键字之后要留空格。例如 <code>const、virtual、inline、case</code> 等关键字之后至少留一个空格，否则无法辨析关键字。<code>if、for、while</code> 等关键字之后应留一个空格再跟 ‘<code>(</code>‘，以突出关键字。</li><li>函数名之后不要留空格，紧跟 ‘<code>(</code>‘ 以区别于关键字。</li><li>‘<code>,</code>’ 之后要留空格，如果 ‘<code>;</code>‘ 不是一行的结束符号，其后也要留空格。</li><li>赋值操作符、比较操作符、算术操作符、逻辑操作符等二元操作符的前后要加空格。</li><li>一元操作符如 ’<code>!</code>’，’<code>++</code>‘，‘<code>&amp;</code>’（地址运算符） 等前后不加空格。</li><li>‘<code>[]</code>’，’<code>.</code>‘，’<code>-&gt;</code>‘ 这类操作符前后不加空格。</li></ul><h2 id="Windows-程序命名规则"><a href="#Windows-程序命名规则" class="headerlink" title="Windows 程序命名规则"></a>Windows 程序命名规则</h2><p>匈牙利命名法是一种编程时的命名规范，基本原则是变量名=属性+类型+对象描述，其中每个对象名都要求有明确的含义，可以取对象全称的一部分。</p><p>在 Windows 下开发程序应该尽量使用匈牙利命名法，用小写字母的前缀表示变量的类型，前缀的下一个字母用大写。</p><p>常见的数据类型前缀：</p><div class="table-container"><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">类型</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">b</td><td style="text-align:center">bool</td><td style="text-align:center">bIsParent</td></tr><tr><td style="text-align:center">by/byte</td><td style="text-align:center">byte</td><td style="text-align:center">byFlag</td></tr><tr><td style="text-align:center">ch</td><td style="text-align:center">char</td><td style="text-align:center">chText</td></tr><tr><td style="text-align:center">fn</td><td style="text-align:center">函数变量</td><td style="text-align:center">fnCallback</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">句柄</td><td style="text-align:center">hWnd</td></tr><tr><td style="text-align:center">i/n</td><td style="text-align:center">int</td><td style="text-align:center">iValue/nValue</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">unsigned int</td><td style="text-align:center">uFlag</td></tr><tr><td style="text-align:center">dw</td><td style="text-align:center">dword</td><td style="text-align:center">dwData</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">指针</td><td style="text-align:center">pBuffer</td></tr><tr><td style="text-align:center">sz/str</td><td style="text-align:center">字符串</td><td style="text-align:center">szBuffer</td></tr><tr><td style="text-align:center">lpstr/lpsz</td><td style="text-align:center">lpstr</td><td style="text-align:center">lpstrMessage</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">word</td><td style="text-align:center">wData</td></tr><tr><td style="text-align:center">x,y</td><td style="text-align:center">坐标</td><td style="text-align:center">xPos，yPos</td></tr><tr><td style="text-align:center">m_</td><td style="text-align:center">类成员变量</td><td style="text-align:center">m_bFlag</td></tr><tr><td style="text-align:center">g_</td><td style="text-align:center">全局变量</td><td style="text-align:center">g_bFlag</td></tr></tbody></table></div><p>常见的控件名前缀：</p><div class="table-container"><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">控件类型</th></tr></thead><tbody><tr><td style="text-align:center">frm/wnd</td><td style="text-align:center">窗口</td></tr><tr><td style="text-align:center">cmd/btn</td><td style="text-align:center">按钮</td></tr><tr><td style="text-align:center">cmb/combo</td><td style="text-align:center">下拉式列表框</td></tr><tr><td style="text-align:center">txt</td><td style="text-align:center">文本输入框</td></tr><tr><td style="text-align:center">lbl</td><td style="text-align:center">标签</td></tr><tr><td style="text-align:center">grd</td><td style="text-align:center">Grid、网络</td></tr><tr><td style="text-align:center">scr</td><td style="text-align:center">滚动条</td></tr><tr><td style="text-align:center">lst</td><td style="text-align:center">列表框</td></tr><tr><td style="text-align:center">frame</td><td style="text-align:center">框架</td></tr></tbody></table></div><p>对于多个单词组成的变量名，每个单词的首字母应该大写。</p><p>类名和数据结构定义用大写字母开头的单词组合而成，类名前加前缀‘<code>C</code>’，数据结构不加前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNode</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLeafNode</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure><p>变量和参数用小写字母开头的单词组合而成，即第一个单词全部小写，后续单词首字母大写。</p><p>函数名用大写字母开头的单词组合而成。</p><h2 id="共性规则"><a href="#共性规则" class="headerlink" title="共性规则"></a>共性规则</h2><ul><li><p>较短的单词可以去掉元音形成缩写，较长的单词可取单词的头几个字形成缩写。</p><p>一些单词有公认的缩写，例如：</p><p>|   单词    | 缩写 |<br>| :———-: | :—: |<br>|   temp    | tmp  |<br>|   flag    | flg  |<br>| statistic | stat |<br>| increment | inc  |<br>|  message  | msg  |</p></li><li><p>应该在源文件的开始处对所使用的缩写或约定进行必要的注释说明。</p></li><li><p>Windows 下的源代码通常采用“大小写混排”的方式，如 AddChild；而 UNIX/Linux 应用程序的标识符通常采用“小写+下划线”的方式，如 add_child。</p></li><li><p>在程序中不要出现仅靠大小写区分的相似标识符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容易混淆</span></span><br><span class="line"><span class="keyword">int</span> x,X;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FOO</span><span class="params">(<span class="keyword">float</span> x)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在程序中不要出现标识符完全相同的局部变量和全局变量。</p></li><li><p>变量的名字应使用“形容词+名词”或“名词”的形式，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> value;</span><br><span class="line"><span class="keyword">float</span> oldValue;</span><br><span class="line"><span class="keyword">float</span> newValue;</span><br></pre></td></tr></table></figure></li><li><p>全局函数的名字应使用“动词“或”动词+名词“的形式。类的成员函数应只使用”动词“，被省略掉的名词就是对象本身。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DrawBox</span>(); <span class="comment">//全局函数</span></span><br><span class="line">box-&gt;<span class="built_in">Draw</span>(); <span class="comment">//类的成员函数</span></span><br></pre></td></tr></table></figure></li><li><p>用正确的反义词组命名具有互斥意义的变量或相反动作的函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> minValue;</span><br><span class="line"><span class="keyword">int</span> maxValue;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetValue</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure><p>常见的反义词组：</p><p>|    正     |    反     |<br>| :———-: | :———-: |<br>|    add    |  remove   |<br>|  insert   |  delete   |<br>| increment | decrement |<br>|    min    |    max    |<br>|   next    | previous  |<br>|   send    |  receive  |<br>|    cut    |   paste   |<br>|   begin   |    end    |<br>|   first   |   last    |<br>|    put    |    get    |<br>|   lock    |  unlock   |<br>|    old    |    new    |<br>|  source   |  target   |<br>|    up     |   down    |<br>|  create   |  destroy  |<br>|   open    |   close   |<br>|   start   |   stop    |<br>|   show    |   hide    |</p></li><li><p>应该避免名字中出现数字编号，如 Value1，Value2 等，除非逻辑上需要编号。</p></li></ul><h2 id="表达式和表达语句"><a href="#表达式和表达语句" class="headerlink" title="表达式和表达语句"></a>表达式和表达语句</h2><ul><li><p>复合表达式</p><p>如 ”<code>a = b = c = 0</code>“ 这样的表达式称为复合表达式，它书写简洁，可以提高编译效率，但要防止滥用复合表达式。</p><ul><li><p>不要编写太复杂的复合表达式，如：</p><p><code>i = a &gt;= b &amp;&amp; c&lt;d &amp;&amp; c + f &lt;= g + b;</code></p><p><code>* stat_poi ++ +=1;</code></p><p>应改为 <code>* stat_poi +=1; stat_poi++;</code></p></li><li><p>不要有多用途的复合表达式，如：</p><p><code>d = (a = b + c) + r;</code></p><p>该表达式既求 a 值又求 d 值，应该拆分为两个独立语句。</p></li><li><p>已删除的对象指针要赋予空指针值。</p></li></ul></li><li><p>if 语句</p><ul><li><p>不可将布尔变量直接与 TRUE、FALSE 或者 1、0 进行比较。</p><p>因为 TRUE 的值是什么并没有统一的标准。</p><p>flag 与零值比较的标准 if 语句如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(flag)   <span class="comment">//表示flag为真</span></span><br><span class="line"><span class="keyword">if</span>(!flag)  <span class="comment">//表示flag为假</span></span><br></pre></td></tr></table></figure></li><li><p>整型变量不可模仿布尔风格。</p><p>整型变量 value 与零值比较的标准 if 语句如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span>(value != <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>不可将浮点变量用 “==” 或 “!=” 与任何数字比较。</p><p>因为 float 和 double 变量都有精度限制，应该设法转化成“&gt;=”或“&lt;=”形式。</p><p>例如浮点变量 x，E 是允许的误差（即精度）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == <span class="number">0.0</span>)</span><br><span class="line"><span class="comment">//转化为</span></span><br><span class="line"><span class="keyword">if</span>((x&gt;=-E) &amp;&amp; (x&lt;=E))</span><br></pre></td></tr></table></figure></li><li><p>指针变量应该用“==”或“!=”与 NULL 比较。</p></li></ul></li><li><p>循环语句的效率</p><p>提高循环体效率的基本方法是降低循环体的复杂性。</p><ul><li><p>在多重循环中，应当将最长的循环放在最内层，将最短的循环放在最外层，以减少 CPU 跨切循环层的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//低效率</span></span><br><span class="line"><span class="keyword">for</span> (row = <span class="number">0</span>;row &lt; <span class="number">100</span>;row++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">0</span>;col &lt; <span class="number">5</span>;col++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + a[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高效率</span></span><br><span class="line"><span class="keyword">for</span> (col = <span class="number">0</span>;col &lt; <span class="number">5</span>;col++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (raw = <span class="number">0</span>;raw &lt; <span class="number">100</span>;raw++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + a[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体外面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//效率低但程序简介</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition)</span><br><span class="line">        <span class="built_in">DoSomething</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">DoOtherthing</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//效率高但程序不简洁</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        <span class="built_in">DoOtherthing</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>C++ 类中的常量</p><p>const 修饰的数据成员只在某个对象生命周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同对象的 const 成员的值可以不同。</p><p>若要建立在整个类中都恒定的常量，应该用枚举类型来实现，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">enum</span>&#123;</span>SIZE1 = <span class="number">100</span>,SIZE2 = <span class="number">200</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> array[SIZE1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>枚举常量不会占用对象的存储空间，它们在编译时被全部求值。缺点是它隐含的数据类型是整数，最大值有限且不能表示浮点数。</p></li></ul><h1 id="函数设计规则"><a href="#函数设计规则" class="headerlink" title="函数设计规则"></a>函数设计规则</h1><p>函数接口的两个要素是参数和返回值。在 C++ 中，函数参数和返回值的传递方式有 $3$ 种，即<strong>值传递、指针传递和引用传递</strong>。</p><h2 id="函数外部特性的注释规则"><a href="#函数外部特性的注释规则" class="headerlink" title="函数外部特性的注释规则"></a>函数外部特性的注释规则</h2><p>函数外部特性的注释必须在函数体上部采用中文说明，标准格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//输入参数：</span><br><span class="line">//参数1：（指出物理意义、量纲和取值范围）</span><br><span class="line">//...</span><br><span class="line">//参数N：</span><br><span class="line">//函数返回：（指出物理意义、量纲和取值范围）</span><br><span class="line">//功能描述：</span><br><span class="line">//注意事项：</span><br><span class="line">//...</span><br></pre></td></tr></table></figure><p>公用代码库中的函数必须说明对公用代码库的影响和要求，例如可重用性等。</p><p>使用的全局变量，特别是修改全局变量时，必须进行说明。</p><h2 id="参数规则"><a href="#参数规则" class="headerlink" title="参数规则"></a>参数规则</h2><ul><li><p>参数命名要恰当，顺序要遵循程序员的习惯，一般将目的参数放前面，源参数放后面。</p></li><li><p>如果参数是指针，且仅作输入用，应在类型前加 const，防止该指针在函数体内被修改。</p></li><li><p>对仅作输入的参数尽量使用 const 修饰符。</p><p>如果输入参数以值传递的方式传递对象，宜改用 ”const &amp;“ 方式来传递，这样可以省去临时对象的构造和析构过程。</p></li><li><p>参数默认值只能出现在函数声明中，不能出现在定义体内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>,<span class="keyword">int</span> y = <span class="number">0</span>)</span></span>; <span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>,<span class="keyword">int</span> y = <span class="number">0</span>)</span>  <span class="comment">//错误</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个参数，参数只能从后往前依次默认。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y = <span class="number">0</span>，<span class="keyword">int</span> z = <span class="number">0</span>)</span></span>; <span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>,<span class="keyword">int</span> y,<span class="keyword">int</span> z = <span class="number">0</span>)</span></span>;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li><li><p>避免函数有太多参数，尽量控制在 $5$ 个以内。</p></li><li><p>尽量不使用类型和数目不确定的参数，否则在编译时会丧失严格的类型安全检查。</p></li><li><p>非调度函数应减少控制参数，尽量使用数据参数，降低代码的控制耦合。</p></li></ul><h2 id="函数内部的实现规则"><a href="#函数内部的实现规则" class="headerlink" title="函数内部的实现规则"></a>函数内部的实现规则</h2><p>函数体内的局部变量的声明与应用应遵循标准 C 的语法，即需要用到的所有局部变量在函数定义的开始部分统一声明，而不能在首次引用的代码行同时进行声明和定义。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,i;</span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">        a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><p>[1] 秦航，杨强 . 软件质量保证与测试(第 2 版)[M] . 北京：清华大学出版社，2017</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;代码风格&quot;&gt;&lt;a href=&quot;#代码风格&quot; class=&quot;headerlink&quot; title=&quot;代码风格&quot;&gt;&lt;/a&gt;代码风格&lt;/h1&gt;&lt;h2 id=&quot;程序的书写格式&quot;&gt;&lt;a href=&quot;#程序的书写格式&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="软件测试" scheme="http://10185102110.github.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot相关原理</title>
    <link href="http://10185102110.github.io/2021/08/17/SpringBoot%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"/>
    <id>http://10185102110.github.io/2021/08/17/SpringBoot%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-17T07:53:37.000Z</published>
    <updated>2021-08-28T03:35:48.371Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring Web MVC 是一种基于 Java 的轻量级 Web 框架，使用 MVC架构模式的思想将 web 层进行职责解耦，基于请求驱动即使用请求-响应模型，框架的目的就是帮助我们简化开发。</p><p>Spring MVC 主要由前端控制器(DispatcherServlet)、处理器映射(HandlerMapping)、控制器(Controller)、视图解析器(ViewResolver)、视图组成。</p><p>Spring 的 Web MVC 框架提供了模型 - 视图 - 控制器架构：</p><ul><li><strong>模型（Model ）</strong>封装了应用程序的数据和一般他们会组成的 POJO。</li><li><strong>视图（View）</strong>是负责呈现模型数据和一般它生成的 HTML 输出，客户端的浏览器能够解释。</li><li><strong>控制器（Controller ）</strong>负责处理用户的请求，并建立适当的模型，并把它传递给视图渲染。</li></ul><h2 id="Spring-MVC-运行原理"><a href="#Spring-MVC-运行原理" class="headerlink" title="Spring MVC 运行原理"></a>Spring MVC 运行原理</h2><p><img src="mvc1.png" alt=""></p><p>$(1)$ HTTP请求：客户端请求提交到 DispatcherServlet。<br>$(2)$ 寻找处理器：由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的 Controller。<br>$(3)$ 调用处理器：DispatcherServlet 将请求提交到 Controller。<br>$(4)$ 调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。<br>$(5)$ 处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图。<br>$(6)$ HTTP 响应：视图负责将结果显示到客户端。</p><h2 id="Spring-MVC-接口"><a href="#Spring-MVC-接口" class="headerlink" title="Spring MVC 接口"></a>Spring MVC 接口</h2><ol><li>DispatcherServlet 接口：<br>Spring 提供的前端控制器，所有的请求都有经过它来统一分发。在 DispatcherServlet 将请求分发给 Controller 之前，需要借助 Spring 提供的 HandlerMapping 定位到具体的 Controller。</li><li>HandlerMapping 接口：<br>能够完成客户请求到 Controller 的映射。</li><li>Controller 接口：<br>需要为并发用户处理上述请求，因此实现 Controller 接口时，必须保证线程安全并且可重用。<br>Controller 将处理用户请求，并返回 ModelAndView 对象给 DispatcherServlet 前端控制器。ModelAndView 类对象包含模型和视图。</li><li>ViewResolver 接口：<br>Spring 提供的视图解析器，在 Web 应用中查找 View 对象，从而将相应结果渲染给客户。</li></ol><h2 id="自动配置源码分析与实例"><a href="#自动配置源码分析与实例" class="headerlink" title="自动配置源码分析与实例"></a>自动配置源码分析与实例</h2><p>除了装载 DispatcherServlet 外，Spring Boot 还做了如下默认配置：</p><ul><li>自动配置视图解析器；</li><li>静态资源文件处理；</li><li>自动注册大量的转换器和格式化器；</li><li>提供 HttpMessageConverter 对请求参数和返回结果进行处理；</li><li>自动注册 MessageCodeResolver；</li><li>默认欢迎页配置；</li><li>favicon 自动配置；</li><li>可配置的 Web 初始化绑定器。</li></ul><p>以上自动配置都是在 WebMvcAutoConfiguration 自动配置类中操作的。</p><h3 id="WebMvcAutoConfiguration自动配置类"><a href="#WebMvcAutoConfiguration自动配置类" class="headerlink" title="WebMvcAutoConfiguration自动配置类"></a>WebMvcAutoConfiguration自动配置类</h3><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定该类为配置类</span></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 当前应用是Servlet Web应用时该配置类才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(</span></span><br><span class="line"><span class="meta">    type = Type.SERVLET</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="comment">// 判断当前classpath是否存在Servlet类、DispatcherServlet类和WebMvcConfigurer类，存在则生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span></span><br><span class="line"><span class="comment">// 判断IOC容器中是否存在WebMvcConfigurationSupport类型的Bean，不存在则生效</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)</span></span><br><span class="line"><span class="comment">// 类的加载顺序，数值越小越优先加载</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(-2147483638)</span></span><br><span class="line"><span class="comment">// 自动配置的生效时间在这三个自动配置类之后</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上源码可知 WebMvcAutoConfiguration 自动配置类的自动配置触发条件。</p><h3 id="ViewResolver视图解析器"><a href="#ViewResolver视图解析器" class="headerlink" title="ViewResolver视图解析器"></a>ViewResolver视图解析器</h3><p>Spring MVC 中的 Controller 控制器可以返回各种各样的视图，比如 JSP、JSON、Velocity、FreeMarker、Thymeleaf、HTML 字符流等。这些视图的解析需要各种视图解析器，视图解析器的作用就是将逻辑视图转为物理视图，所有的视图解析器都必须实现 ViewResolver 接口。开发者可以设置一个视图解析器或混用多个视图解析器并指定优先顺序，Spring MVC 会按照视图解析器的优先顺序对逻辑视图进行解析，直到解析成功并返回视图对象，否则抛出异常。</p><p>WebMvcAutoConfiguration 的子类 WebMvcAutoConfigurationAdapter 中，在前置条件满足的情况下自动配置类会向 IOC 容器中注册三个视图解析器，分别是 InternalResourceViewResolver、BeanNameViewResolver 和 ContentNegotiatingViewResolver。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span>, <span class="title">ServletContextAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="comment">// 如果没有，就在IOC容器中注册一个InternalResourceViewResolver类型的Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> InternalResourceViewResolver <span class="title">defaultViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">            resolver.setPrefix(<span class="keyword">this</span>.mvcProperties.getView().getPrefix());</span><br><span class="line">            resolver.setSuffix(<span class="keyword">this</span>.mvcProperties.getView().getSuffix());</span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean(&#123;View.class&#125;)</span></span><br><span class="line">        <span class="comment">// IOC容器中存在View.class</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="comment">// 满足上一个条件时，如果没有，就在IOC容器中注册一个BeanNameViewResolver类型的Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BeanNameViewResolver <span class="title">beanNameViewResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            BeanNameViewResolver resolver = <span class="keyword">new</span> BeanNameViewResolver();</span><br><span class="line">            resolver.setOrder(<span class="number">2147483637</span>);</span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnBean(&#123;ViewResolver.class&#125;)</span></span><br><span class="line">        <span class="comment">// IOC容器中存在ViewResolver.class</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">            name = &#123;&quot;viewResolver&quot;&#125;,</span></span><br><span class="line"><span class="meta">            value = &#123;ContentNegotiatingViewResolver.class&#125;</span></span><br><span class="line"><span class="meta">        )</span></span><br><span class="line">        <span class="comment">// 满足上一个条件时，如果IOC容器中没有名称为ViewResolver且类型为ContentNegotiatingViewResolver类的Bean，就向容器中注册一个</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ContentNegotiatingViewResolver <span class="title">viewResolver</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">            ContentNegotiatingViewResolver resolver = <span class="keyword">new</span> ContentNegotiatingViewResolver();</span><br><span class="line">            resolver.setContentNegotiationManager((ContentNegotiationManager)beanFactory.getBean(ContentNegotiationManager.class));</span><br><span class="line">            resolver.setOrder(-<span class="number">2147483648</span>);</span><br><span class="line">            <span class="keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>InternalResourceViewResolver：通过设置前缀、后缀和控制器中的方法来返回视图名的字符串，从而得到实际视图内容。</p><p>BeanNameViewResolver：在控制器中，一个方法的返回值的字符串会根据 BeanNameViewResolver 查找 Bean 的名称并为返回字符串的 View 渲染视图。</p><p>ContentNegotiatingViewResolver：特殊的视图解析器，它不会为自己处理视图，而是委派给其他视图解析器来处理不同的视图，级别最高。</p><p>Spring Boot 的自动配置机制会直接在项目启动过程中将视图解析器注册到 IOC 容器中，当然，如果开发者不想使用默认的配置策略，也可以自行添加视图解析器到 IOC 容器中。</p><h3 id="Converter、Formatter类型转换器"><a href="#Converter、Formatter类型转换器" class="headerlink" title="Converter、Formatter类型转换器"></a>Converter、Formatter类型转换器</h3><p>在 WebMvcAutoConfigurationAdapter 内部类中含有 <code>addFormatters()</code> 方法，该方法会向 FormatterRegistry 添加 IOC 容器中拥有的 Converter、GenericConverter、Formatter 类型的 Bean。</p><p> <code>addFormatters()</code> 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">    ApplicationConversionService.addBeans(registry, <span class="keyword">this</span>.beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了 <code>ApplicationConversionService.addBeans()</code> 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addBeans</span><span class="params">(FormatterRegistry registry, ListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Set&lt;Object&gt; beans = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(GenericConverter.class).values());</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(Converter.class).values());</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(Printer.class).values());</span><br><span class="line">    beans.addAll(beanFactory.getBeansOfType(Parser.class).values());</span><br><span class="line">    Iterator var3 = beans.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">        Object bean = var3.next();</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> GenericConverter) &#123;</span><br><span class="line">            registry.addConverter((GenericConverter)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Converter) &#123;</span><br><span class="line">            registry.addConverter((Converter)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Formatter) &#123;</span><br><span class="line">            registry.addFormatter((Formatter)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Printer) &#123;</span><br><span class="line">            registry.addPrinter((Printer)bean);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Parser) &#123;</span><br><span class="line">            registry.addParser((Parser)bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单类型转换的案例：</p><p>在 Controller 包中新建 TestController 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test/type/conversion&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">typeConversionTest</span><span class="params">(String name,<span class="keyword">float</span> weight,<span class="keyword">int</span> type,Boolean onSale)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;weight:&quot;</span>+weight);</span><br><span class="line">        System.out.println(<span class="string">&quot;type:&quot;</span>+type);</span><br><span class="line">        System.out.println(<span class="string">&quot;onSale:&quot;</span>+onSale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 Spring Boot 项目，在浏览器中输入 <a href="http://localhost:8080/test/type/conversion?name=iPhoneX&amp;weight=174.5&amp;type=1&amp;onSale=true">http://localhost:8080/test/type/conversion?name=iPhoneX&amp;weight=174.5&amp;type=1&amp;onSale=true</a> ，查看控制台的打印结果：</p><p><img src="1.png" alt=""></p><p>HTTP 请求传递的数据都是字符串 String 类型的，而类型转换方法可以将其转换成其他数据类型。</p><h3 id="HttpMessageConverter消息转换器"><a href="#HttpMessageConverter消息转换器" class="headerlink" title="HttpMessageConverter消息转换器"></a>HttpMessageConverter消息转换器</h3><p> HttpMessageConverter 的设置也是通过 WebMvcAutoConfigurationAdapter 完成的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.messageConvertersProvider.ifAvailable((customConverters) -&gt; &#123;</span><br><span class="line">        converters.addAll(customConverters.getConverters());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Spring MVC 开发 Web 项目时，@RequestBody、@ResponseBody 注解用来进行请求实体的转换和响应结果的格式化输出。以 JSON 数据为例，前者的作用是将请求中的数据解析成 JOSN 并绑定为实体对象，后者的作用是将响应结果以 JSON 格式返回给请求发起者。两者结合起来就是 HttpMessageConverter 的作用。</p><p>举个例子，在项目中新建 entity 包并定义一个实体类 SaleGoods，然后通过 @RequestBody、@ResponseBody 注解进行参数的读取和响应，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleGoods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String goodsName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">private</span> Boolean onSale;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGoodsName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goodsName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGoodsName</span><span class="params">(String goodsName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.goodsName = goodsName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">float</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getOnSale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onSale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnSale</span><span class="params">(Boolean onSale)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onSale = onSale;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SaleGoods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;,goodsName=&#x27;&quot;</span> + goodsName +<span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;,weight=&#x27;&quot;</span> + weight +</span><br><span class="line">                <span class="string">&quot;,type=&#x27;&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;,onSale=&#x27;&quot;</span> + onSale + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TestController 类中添加 <code>httpMessageConverterTest()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/test/httpmessageconverter&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SaleGoods <span class="title">httpMessageConverterTest</span><span class="params">(<span class="meta">@RequestBody</span> SaleGoods saleGoods)</span></span>&#123;</span><br><span class="line">    System.out.println(saleGoods.toString());</span><br><span class="line">    saleGoods.setType(saleGoods.getType() + <span class="number">1</span>);</span><br><span class="line">    saleGoods.setGoodsName(<span class="string">&quot;商品名:&quot;</span> + saleGoods.getGoodsName());</span><br><span class="line">    <span class="keyword">return</span> saleGoods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码作用是拿到封装好的 SaleGoods 对象，进行简单的修改后，最后将对象数据返回。</p><p>由于这里是 POST 请求，使用 Postman 软件模拟请求：</p><p><img src="2.png" alt=""></p><p>同时控制台输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SaleGoods&#123;id=1,goodsName=&#x27;Spring Boot&#x27;,weight=&#x27;10.5,type=&#x27;2,onSale=&#x27;true&#125;</span><br></pre></td></tr></table></figure><p>消息转换器使得对象数据的读取不仅简单而且正确，响应时也不用自行封装工具类。</p><h3 id="静态资源的映射规则"><a href="#静态资源的映射规则" class="headerlink" title="静态资源的映射规则"></a>静态资源的映射规则</h3><p>这部分配置依然是 WebMvcAutoConfigurationAdapter 内部类完成的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// webjars文件访问配置</span></span><br><span class="line">        <span class="keyword">this</span>.addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态资源映射配置</span></span><br><span class="line">        <span class="keyword">this</span>.addResourceHandler(registry, <span class="keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;</span><br><span class="line">            registration.addResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ServletContextResource resource = <span class="keyword">new</span> ServletContextResource(<span class="keyword">this</span>.servletContext, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">                registration.addResourceLocations(<span class="keyword">new</span> Resource[]&#123;resource&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态资源的映射是在 <code>addResourceHandler()</code> 方法中配置的，StaticPathPattern 的值为 “/**”，表示访问当前项目的任何资源，只要没有匹配的处理映射，则都去静态资源的文件夹找映射。实际的静态资源存放目录通过 <code>getStaticLocations()</code> 方法获取，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] staticLocations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> addMappings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> customized;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebProperties.Resources.Chain chain;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebProperties.Resources.Cache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line">        <span class="keyword">this</span>.addMappings = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.customized = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.chain = <span class="keyword">new</span> WebProperties.Resources.Chain();</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> WebProperties.Resources.Cache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStaticLocations() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.staticLocations;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，Spring Boot 默认的静态资源处理目录为：”classpath:/META-INF/resources/“, “classpath:/resources/“, “classpath:/static/“, “classpath:/public/“。开发 Web 项目时只需要包含这几个目录中的一个或者多个，并将静态资源文件放入其中即可。</p><p>为验证该配置，在类路径下分别创建 public 目录、resources 目录、static 目录，并分别在三个文件夹中放入静态文件，如图所示：</p><p><img src="3.png" alt=""></p><p>重启 Spring Boot，打开浏览器分别进行请求：</p><p><img src="4.png" alt=""></p><p><img src="5.png" alt=""></p><p><img src="6.png" alt=""></p><p><img src="7.png" alt=""></p><p>可见静态资源虽然在不同的目录中，但都能被正确返回，这就是 Spring Boot 对静态资源的拦截处理。</p><p>开发者也可以在配置文件 application.properties 中修改拦截地址和静态资源目录。</p><h3 id="welcomePage-和-favicon-配置"><a href="#welcomePage-和-favicon-配置" class="headerlink" title="welcomePage 和 favicon 配置"></a>welcomePage 和 favicon 配置</h3><p>welcomePage 即默认欢迎页面，配置源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(ApplicationContext applicationContext,FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider)</span> </span>&#123;</span><br><span class="line">    WelcomePageHandlerMapping welcomePageHandlerMapping = <span class="keyword">new</span> WelcomePageHandlerMapping(<span class="keyword">new</span> TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),<span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));</span><br><span class="line">    welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">    <span class="keyword">return</span> welcomePageHandlerMapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getWelcomePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String location : <span class="keyword">this</span>.resourceProperties.getStaticLocations()) &#123;</span><br><span class="line">        Resource indexHtml = getIndexHtml(location);</span><br><span class="line">        <span class="keyword">if</span> (indexHtml != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> indexHtml;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ServletContext servletContext = getServletContext();</span><br><span class="line">    <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getIndexHtml(<span class="keyword">new</span> ServletContextResource(servletContext, SERVLET_LOCATION));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getIndexHtml</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getIndexHtml(<span class="keyword">this</span>.resourceLoader.getResource(location));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource <span class="title">getIndexHtml</span><span class="params">(Resource location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Resource resource = location.createRelative(<span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (resource.exists() &amp;&amp; (resource.getURL() != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> resource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行 Web MVC 自动配置时程序会向 IOC 容器注册一个 WelcomePageHandlerMapping 类型的 Bean，即默认欢迎页面，其路径为静态资源目录下的 index.html 文件。</p><p>在 /static/ 目录下添加 index.html 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>welcome page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    这里是默认欢迎页</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启项目，再访问 <a href="http://localhost:8080/">http://localhost:8080/</a> ，效果如下：</p><p><img src="8.png" alt=""></p><p>favicon 即网页图标，Spring Boot 2.2 版本之后不提供默认 favicon 图标，开发者可以自定义配置。只要将 favicon 文件放入静态资源目录然后重启项目即可。</p><p><img src="9.png" alt=""></p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spring Boot 就是一个 Java web 的开发框架。</p><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>习惯优于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p><p>主要优点：</p><ul><li>可以快速创建独立运行的 Spring 项目</li><li>拥有大量的自动配置</li><li>starter 自动依赖与版本控制</li><li>使用嵌入式的  Servlet 容器</li></ul><h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><p>convention over configuration ，意为惯例优先原则。约定优于配置不是说不需要配置，它其实是一种开发原则，目的是在一定限度内减少需要开发人员手动配置的工作量，用默认的配置达到开发人员的需求。</p><p>比如在项目中加入 spring-boot-starter-web 后，Spring Boot 会自动导入 Spring MVC 的相关依赖和一个内置的 Tomcat 容器。在导入 spring-boot-starter-web 后，就表示开发人员与 Spring Boot 之间约定当前项目是一个 Web 项目，进一步约定开发人员会使用 Spring MVC，从而自动装配 DispatchServlet 到 IOC 容器中。同理，在项目中加入 jdbc-starter 后就表示开发人员与 Spring Boot 之间约定会对数据库进行操作，Spring Boot 会自动导入 JDBC 相关的依赖并配置一个数据源对象供开发人员调用。</p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>打开 pom.xml 文件，可以看到一个 parent 属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该项目依赖父项目：spring-boot-starter-parent，按住 Ctrl 键并点击 spring-boot-starter-parent，进入 spring-boot-starter-parent-2.5.3.pom 文件，部分源码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Parent pom providing dependency and plugin management for applications built with Maven<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource.delimiter</span>&gt;</span>@<span class="tag">&lt;/<span class="name">resource.delimiter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该文件仅仅定义了 JDK 所需版本为 1.8、项目的默认编码 UTF-8 和 Maven 项目编译设置，并且它也依赖一个父项目：spring-boot-dependencies。</p><p>进入 spring-boot-dependencies-2.5.3.pom 文件中，部分源码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Boot Dependencies<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://spring.io/projects/spring-boot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache License, Version 2.0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://www.apache.org/licenses/LICENSE-2.0<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pivotal<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">email</span>&gt;</span>info@pivotal.io<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organization</span>&gt;</span>Pivotal Software, Inc.<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>https://www.spring.io<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/spring-projects/spring-boot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.2<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.90<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.17.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">awaitility.version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">awaitility.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build-helper-maven-plugin.version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">build-helper-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">byte-buddy.version</span>&gt;</span>1.10.22<span class="tag">&lt;/<span class="name">byte-buddy.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caffeine.version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">caffeine.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cassandra-driver.version</span>&gt;</span>4.11.2<span class="tag">&lt;/<span class="name">cassandra-driver.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classmate.version</span>&gt;</span>1.5.1<span class="tag">&lt;/<span class="name">classmate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该文件定义了大量依赖信息，如 commons 相关依赖、log 相关依赖、数据库相关依赖、Spring 相关依赖、ElasticSearch 搜索引擎相关依赖、消息队列相关依赖等。这就是 Spring Boot 项目依赖的版本管理中心。版本管理中心默认配置好大部分依赖的版本信息，这些版本信息随着 Spring Boot 版本的更新而更改。这种设计让开发者导入依赖包时不需要写版本号，但如果不是 dependencies 中默认管理的依赖，就需要声明版本号。</p><p>结合 Spring Boot 约定优于配置的特性，可以这样理解：Spring Boot 为开发者设置了默认编码、默认 JDK 版本及 Maven 编译的默认设置，同时维护了一套项目依赖的配置，相关依赖可以直接导入，并不需要声明版本号。这就是 Spring Boot 与开发者之间的约定，如果认可这个约定就可以减少一些基本配置和依赖配置；如果不认可也可以自行配置，这些配置会覆盖默认配置。</p><p>在 pom.xml 文件中还有一个 spring-boot-starter-web，即在创建项目时选择的 Web 模块。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开 spring-boot-starter-web-2.5.3.pom 文件，可以发现 Spring MVC 所需的依赖和内置的 Tomcat 依赖都已经定义在文件中，这就是为什么仅仅在 pom.xml 文件中加入 spring-boot-starter-web 场景启动器就可以进行 Web 项目的开发。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SpringBootApplication-注解分析"><a href="#SpringBootApplication-注解分析" class="headerlink" title="@SpringBootApplication 注解分析"></a>@SpringBootApplication 注解分析</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p><code>@SpringBootApplication</code> 标注在一个主程序类上，说明这是一个 Spring Boot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动Spring应用</span></span><br><span class="line">        SpringApplication.run(MallApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按住 Ctrl 并点击  <code>@SpringBootApplication</code>，查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>@SpringBootApplication</code> 注解是一个复合注解，前面四个是 Java 元注解：</p><ul><li>@Target({ElementType.TYPE})：类、接口和 enum 声明；</li><li>@Retention(RetentionPolicy.RUNTIME)：运行时注解；</li><li>@Documented：将注解添加到 Java doc 中；</li><li>@Inherited：允许继承。</li></ul><p>重要的是后面三个注解：</p><ul><li>@SpringBootConfiguration：Spring Boot 配置注解；</li><li>@EnableAutoConfiguration：启动自动配置注解；</li><li>@ComponentScan：组件自动扫描注解。</li></ul><p>Java 元注解并无特殊意义，因此如果主程序中不使用 <code>@SpringBootApplication</code> 注解，也可以替换成后三个注解，效果是一样的。</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>表示某个类是一个 Spring Boot 的配置类。</p><p>查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Configuration.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Configuration 注解主要用于定义配置类，替代 XML 配置文件。</p><p> @SpringBootConfiguration 注解仅仅是对 @Configuration 注解进行了包装，本质上依然是 @Configuration 注解。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>表示开启自动配置功能。自动配置是“约定大于配置”设计思想的主要体现， 而 @EnableAutoConfiguration 注解是这个功能的入口。</p><p>查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 AutoConfigurationImportSelector 这个类注册到 Spring 的 IOC容器中，AutoConfigurationImportSelector 可以帮助 Spring Boot 应用将所有符合条件的 @Configuration 配置都加载到当前 Spring Boot 使用的 IOC 容器中。</p><h3 id="AutoConfigurationImportSelector-class"><a href="#AutoConfigurationImportSelector-class" class="headerlink" title="AutoConfigurationImportSelector.class"></a>AutoConfigurationImportSelector.class</h3><p>该类是整个自动配置的核心实现，它负责把返回自动配置的相关组件名称注册到 IOC 容器中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">protected</span> AutoConfigurationImportSelector.<span class="function">AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">// 获取自动装配配置项</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            <span class="comment">// 获取停用配置项</span></span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            <span class="comment">// 移除停用配置项</span></span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="comment">// 返回所有的自动装配配置</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Group&gt; getImportGroup() &#123;</span><br><span class="line">        <span class="keyword">return</span> AutoConfigurationImportSelector.AutoConfigurationGroup.class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否开启自动配置，默认为true</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getClass() == AutoConfigurationImportSelector.class ? (Boolean)<span class="keyword">this</span>.getEnvironment().getProperty(<span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>, Boolean.class, <span class="keyword">true</span>) : <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AnnotationAttributes <span class="title">getAttributes</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        String name = <span class="keyword">this</span>.getAnnotationClass().getName();</span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, <span class="keyword">true</span>));</span><br><span class="line">        Assert.notNull(attributes, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;No auto-configuration attributes found. Is &quot;</span> + metadata.getClassName() + <span class="string">&quot; annotated with &quot;</span> + ClassUtils.getShortName(name) + <span class="string">&quot;?&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getAnnotationClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>其中 <code>getCandidateConfigurations</code> 方法会调用 <code>SpringFactoriesLoader.loadFactoryNames</code> 获取所有自动配置类的类名。SpringFactoriesLoader 类源码此处省略。</p><p>从源码可以看出：Spring Boot 启动时从类路径 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的配置项，过滤后将这些值作为自动配置类导入容器中。</p><p>有哪些自动配置类项？</p><p><img src="0.png" alt=""></p><p>可以查看 spring.factories 文件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Initializers</span></span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section"># Auto Configure</span></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>org.springframework.boot.autoconfigure.EnableAutoConfiguration 配置项定义的就是 Spring Boot 默认加载的所有自动配置类。如果 pom.xml 文件没有引入相应的 jar 包和依赖，部分自动配置无法生效。</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>在 Spring IOC 容器中 @Controller、@Service、@Repository、@Component 等注解的默认装配标识是 @ComponentScan 注解。</p><p> @ComponentScan 注解的作用就是让 Spring 容器从对应包下获取需要注册的类，开发者通过注解来定义哪些包需要被自动扫描并装配。Spring 将会在被指定的包及其子包中寻找标注了 @ComponentScan 注解的 Bean 并注册到容器中。</p><h2 id="SpringApplication-启动流程"><a href="#SpringApplication-启动流程" class="headerlink" title="SpringApplication 启动流程"></a>SpringApplication 启动流程</h2><p>Spring Boot 项目通过运行启动类中的 run() 方法来启动应用，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先实例化SpringApplication</span></span><br><span class="line">        <span class="keyword">return</span> run(<span class="keyword">new</span> Class[]&#123;primarySource&#125;, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 再执行run()方法</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(primarySources)).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终执行的run()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        <span class="comment">// 代码执行时间监控开启</span></span><br><span class="line">        stopWatch.start();</span><br><span class="line">        DefaultBootstrapContext bootstrapContext = <span class="keyword">this</span>.createBootstrapContext();</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 配置Headless属性，默认为true</span></span><br><span class="line">        <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">        <span class="comment">// 获取SpringApplicationRunListener集合</span></span><br><span class="line">        SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">        <span class="comment">// 调用所有SpringApplicationRunListener对象的starting()方法</span></span><br><span class="line">        listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ApplicationArguments对象</span></span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">            <span class="comment">// 创建Environment对象，加载属性配置</span></span><br><span class="line">            ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">            <span class="comment">// 设置系统参数</span></span><br><span class="line">            <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="comment">// 获取需要打印的Spring Boot Banner</span></span><br><span class="line">            Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">            <span class="comment">// 创建Spring容器ApplicationContext</span></span><br><span class="line">            context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">            context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">            <span class="comment">// 准备容器</span></span><br><span class="line">            <span class="keyword">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="comment">// 刷新容器</span></span><br><span class="line">            <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">            <span class="comment">// 执行容器初始化的后置逻辑</span></span><br><span class="line">            <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            <span class="comment">// 代码执行时间监控结束</span></span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="comment">// 打印Spring Boot的启动时长日志</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">                (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发布容器启动事件</span></span><br><span class="line">            listeners.started(context);</span><br><span class="line">            <span class="comment">// 调用启动方法</span></span><br><span class="line">            <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleRunFailure(context, var10, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            listeners.running(context);</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleRunFailure(context, var9, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>Spring Boot 项目启动步骤：</strong></p><p>$(1)$ 实例化 SpringApplication 对象。</p><p>SpringApplication 类的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 设置当前应用类型</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 加载ApplicationContextInitializer，配置在META-INF/spring.factories文件中</span></span><br><span class="line">    <span class="keyword">this</span>.bootstrapRegistryInitializers = <span class="keyword">this</span>.getBootstrapRegistryInitializersFromSpringFactories();</span><br><span class="line">    <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 加载ApplicationListener</span></span><br><span class="line">    <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webApplicationType 值的设置是为了获取当前应用的类型，对后续构造容器环境和 Spring 容器的初始化起作用。deduceFromClasspath() 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">WebApplicationType</span> </span>&#123;</span><br><span class="line">    NONE,</span><br><span class="line">    SERVLET,</span><br><span class="line">    REACTIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_INDICATOR_CLASSES = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;javax.servlet.Servlet&quot;</span>, <span class="string">&quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBMVC_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBFLUX_INDICATOR_CLASS = <span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JERSEY_INDICATOR_CLASS = <span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">&quot;org.springframework.web.reactive.DispatcherHandler&quot;</span>, (ClassLoader)<span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class="string">&quot;org.springframework.web.servlet.DispatcherServlet&quot;</span>, (ClassLoader)<span class="keyword">null</span>) &amp;&amp; !ClassUtils.isPresent(<span class="string">&quot;org.glassfish.jersey.servlet.ServletContainer&quot;</span>, (ClassLoader)<span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> REACTIVE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String[] var0 = SERVLET_INDICATOR_CLASSES;</span><br><span class="line">            <span class="keyword">int</span> var1 = var0.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var1; ++var2) &#123;</span><br><span class="line">                String className = var0[var2];</span><br><span class="line">                <span class="keyword">if</span> (!ClassUtils.isPresent(className, (ClassLoader)<span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NONE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SERVLET;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webApplicationType 值有 $3$ 个：</p><ol><li>SERVLET：Servlet 环境；</li><li>REACTIVE：Reactive 环境；</li><li>NONE：非 Web 环境。</li></ol><p>deduceFromClasspath() 方法多次调用 ClassUtils.isPresent() 方法，先判断 webflux 相关类是否存在，存在则认为当前应用为 REACTIVE 类型；不存在则继续判断 SERVLET 相关类是否存在，若存在则当前应用为 SERVLET 类型；不存在则为 NONE 类型。</p><p>$(2)$ 开始执行 <code>run()</code> 方法，代码执行时间的监控开启，Spring Boot 应用启动成功后会打印启动时间。</p><p>$(3)$ 配置 headless 属性，java.awt.headless 是 J2SE 的一种模式，用于在缺失显示屏、鼠标或键盘时的系统配置，默认为 true。作用是没有检测到显示器也能继续执行后续步骤。</p><p>$(4)$ 获取  SpringApplicationRunListeners；</p><p>$(5)$ 回调 SpringApplicationRunListener 对象的 <code>starting()</code> 方法；</p><p>$(6)$ 解析 <code>run()</code> 方法的 args 参数并封装为 DefaultApplicationArguments 类；</p><p>$(7)$ 为当前应用准备一个 Environment 对象，即运行环境；</p><p>$(8)$ 设置系统参数；</p><p>$(9)$ 获取需要打印的 Spring Boot Banner 对象。默认打印在控制台上，Spring Boot 目前支持图片 Banner 和文字 Banner。</p><p>$(10)$ 创建 Spring 容器 ApplicationContext。根据 webApplicationType 决定创建哪种 contextClass。</p><p>$(11)$ 准备 ApplicationContext 实例。至此，主启动类加载完成，容器准备好。</p><p>$(12)$ 刷新容器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="comment">// 注册一个Hook函数，作用是监听JVM在关闭时销毁的IOC容器</span></span><br><span class="line">        shutdownHook.registerApplicationContext(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.refresh(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先注册一个 Hook 函数，然后调用 refresh() 方法，经过层层调用，最终执行 AbstractApplicationContext 的 refresh() 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化上下文环境</span></span><br><span class="line">        <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">        <span class="comment">// 初始化BeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">            StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行BeanFactory的后置处理器</span></span><br><span class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 执行Bean的后置处理器</span></span><br><span class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            beanPostProcess.end();</span><br><span class="line">            <span class="comment">// 初始化MessageSource组件</span></span><br><span class="line">            <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">            <span class="comment">// 初始化ApplicationContext事件广播器</span></span><br><span class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">            <span class="keyword">this</span>.onRefresh();</span><br><span class="line">            <span class="comment">// 注册监听器，BeanFactory创建完成</span></span><br><span class="line">            <span class="keyword">this</span>.registerListeners();</span><br><span class="line">            <span class="comment">// 初始化剩余的单例Bean</span></span><br><span class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// 完成容器的创建工作</span></span><br><span class="line">            <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var10) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var10);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.cancelRefresh(var10);</span><br><span class="line">            <span class="keyword">throw</span> var10;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.resetCommonCaches();</span><br><span class="line">            contextRefresh.end();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是 Spring Bean 加载的核心，用于刷新整个 Spring 上下文信息，定义加载流程。</p><p>$(13)$ 调用 <code>afterRefresh()</code> 方法，执行 Spring 容器初始化的后置逻辑，默认实现是一个空的方法；</p><p>$(14)$ 代码执行时间的监控停止，知道启动应用花费的时间；</p><p>$(15)$ 发布容器启动事件；</p><p>$(16)$ 在 ApplicationContext 完成启动后，程序会对 ApplicationRunner 和 CommandLineRunner 进行回调处理，查找当前 ApplicationContext 中是否注册有 CommandLineRunner，如果有则遍历执行它们。</p><p>CommandLineRunner 接口的组件会在所有 Spring Beans 初始化之后，SpringApplication.run() 之前执行，一般用于应用程序启动之初的加载数据工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Spring-MVC&quot;&gt;&lt;a href=&quot;#Spring-MVC&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC&quot;&gt;&lt;/a&gt;Spring MVC&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; cl</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot项目的创建</title>
    <link href="http://10185102110.github.io/2021/08/12/SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>http://10185102110.github.io/2021/08/12/SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2021-08-12T13:36:43.000Z</published>
    <updated>2021-08-28T04:49:43.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><ul><li><p>JDK 1.8.0_301</p><p><img src="sf.png" alt=""></p></li><li><p>Maven 3.8.1</p><p><img src="2[4}FJJ50D{Y@T1QG]D8ZMR.png" alt=""></p><p>由于每次下载新的依赖文件都需要通过外网访问 Maven 中央仓库，所以需要配置国内镜像。</p><p>进入 Maven 安装目录，打开 conf/settings.xml 配置文件，添加阿里云镜像仓库的链接：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.2.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.2.0 http://maven.apache.org/xsd/settings-1.2.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 本地仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D://CS_Software//maven//LocalWare<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 配置阿里云镜像服务器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">blocked</span>&gt;</span>true<span class="tag">&lt;/<span class="name">blocked</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>IntelliJ IDEA 2021.2 专业版</p><p>IDEA 编辑器自带 Maven 环境，将其设置为自己安装的 Maven 环境。</p><p><img src="D:\blog\source\_posts\Springboot项目的搭建\2.png" alt="2"></p></li></ul><h1 id="创建一个SpringBoot项目"><a href="#创建一个SpringBoot项目" class="headerlink" title="创建一个SpringBoot项目"></a>创建一个SpringBoot项目</h1><p>Spring 官方提供了 Spring Initializr 进行 Spring Boot 项目的初始化，如下图：</p><p><img src="awd.png" alt=""></p><p>添加依赖和 Starter：选择 Spring Web 依赖</p><p><img src="asdd.png" alt=""></p><p>创建完成，等待文件加载完毕</p><p><img src="adsadas.png" alt=""></p><p>src/main/java 表示 Java 程序开发目录，在该目录下进行业务代码的开发。</p><p>该目录下的 HelloWorldApplication 文件是程序主入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.avebai.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序主入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HelloWorldApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main/resources 表示配置文件目录，主要用于存放静态文件、模板文件和配置文件。</p><p>static 目录用于存放静态资源文件，如 JavaScript 文件、图片、CSS 文件等。</p><p>templates 目录用于存放模板类文件，如 Thymeleaf 文件或 FreeMarker 文件。</p><p>src/main/test 表示测试类文件。</p><p>pom.xml 用于配置项目依赖。</p><p>运行主程序，效果如下图：</p><p><img src="trh.png" alt=""></p><p>可以看到 Tomcat 运行在 $8080$ 端口。</p><p>Tomcat：一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器。</p><p><img src="0.png" alt=""></p><p>该页面是 Spring Boot 项目的默认错误页面，404 错误。</p><h1 id="编写一个Web接口"><a href="#编写一个Web接口" class="headerlink" title="编写一个Web接口"></a>编写一个Web接口</h1><p>在主程序目录新建一个 package，命名为 controller，在 controller 下新建 class，命名为 HelloController。</p><p>实现一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.avebai.helloworld.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的含义是处理请求为 /hello 的 GET 请求并返回一个字符串。</p><p>运行结果：</p><p><img src="1.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDK 1.8.0_301&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;sf.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://10185102110.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://10185102110.github.io/2021/08/11/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://10185102110.github.io/2021/08/11/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-11T02:44:18.000Z</published>
    <updated>2021-09-16T02:27:19.195Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常有小端和大端两种方式。</p><ol><li>小端：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。</li><li>大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。</li></ol><p>Java 语言的字节序是<strong>大端</strong>。</p><h2 id="JDK-与-JRE"><a href="#JDK-与-JRE" class="headerlink" title="JDK 与 JRE"></a>JDK 与 JRE</h2><ol><li>JDK：Java 开发工具包 (Java Development Kit)，提供 Java 的开发环境和运行环境。</li><li>JRE：Java 运行环境 (Java Runtime Environment)，提供 Java 运行所需的环境，包括 Java 虚拟机、Java 核心类库和支持文件。</li></ol><p>JDK 包含 JRE。如果只运行 Java 程序，安装 JRE 即可，要编写 Java 程序需安装 JDK。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。反射机制使得 Java具有动态获取程序信息和动态调用对象方法的能力。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ol><li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改类的成员变量；</li><li><strong>Method</strong> ：可以使用 invoke() 方法获取类的方法信息；</li><li><strong>Constructor</strong> ：可以用 Constructor 创建新的对象，获取类的构造方法。</li></ol><p>优点：</p><p>运行期类型的判断，class.forName() 动态加载类，提高代码的灵活度。</p><p>缺点：</p><p>（1）性能开销 ：反射涉及动态类型的解析，JVM 无法对这些代码进行优化。因此，反射操作的效率比非反射操作低得多，应避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p><p>（2）安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。</p><p>（3）内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如：访问私有的属性和方法），所以使用反射可能会导致代码功能失调并破坏可移植性。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化：将 Java 对象转化为字节序列。</p><p>反序列化：将字节序列转化为 Java 对象。</p><p>应用场景：</p><p>Web 服务器中的 Session 会话对象，当有 $10$ 万用户并发访问，就有可能出现 $10$ 万个 Session 对象，显然这种情况内存可能是吃不消的。于是 Web 容器就会把一些 Session 先序列化，让他们离开内存空间，序列化到硬盘中，当需要调用时，再把保存在硬盘中的对象还原到内存中。</p><p>序列化与反序列化实现了 <strong>数据的持久化与进程通信间的对象传送</strong>，发送方需要把这个 Java 对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为 Java 对象。</p><p>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个User类，实现Serializable接口，并生成一个版本号</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String userId; </span><br><span class="line">    <span class="keyword">private</span> String userName; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userId, String userName)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.userId = userId; </span><br><span class="line">        <span class="keyword">this</span>.userName = userName; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类，来对该对象进行读写操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 将User对象作为文本写入磁盘 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeObj</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        user user = <span class="keyword">new</span> user(<span class="string">&quot;1001&quot;</span>, <span class="string">&quot;AveBai&quot;</span>); </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:/Users/AveBai/Desktop/user.txt&quot;</span>)); </span><br><span class="line">            objectOutputStream.writeObject(user); </span><br><span class="line">            objectOutputStream.close(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readObj</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:/Users/AveBai/Desktop/user.txt&quot;</span>)); </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                Object object = objectInputStream.readObject(); </span><br><span class="line">                user user = (user) object; </span><br><span class="line">                System.out.println(user); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123; </span><br><span class="line">        writeObj();</span><br><span class="line">        readObj(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>反序列化输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.user@180bc464</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如加日志、事务等。</p><p>给类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，还在原来的基础上添加额外处理的新功能。这个代理类并不是定义好的，是动态生成的，具有解耦意义，灵活，扩展性强。</p><p>动态代理的应用：Spring 的 AOP 、加事务、加权限、加日志。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p><blockquote><p>元注解</p></blockquote><p>元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为：</p><ul><li>@Retention: 定义该注解的生命周期。<ul><li>RetentionPolicy.SOURCE：注解在编译阶段丢弃，它们不会写入字节码。@Override, @SuppressWarnings 都属于这类注解。</li><li>RetentionPolicy.CLASS : 在类加载的时候丢弃，注解默认使用这种方式。</li><li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。自定义的注解通常使用这种方式。</li></ul></li><li>@Target：表示注解作用的范围。 </li><li>@Documented：表示是否将注解信息添加在 java 文档中。 </li><li>@Inherited：@Inherited 修饰的注解修饰一个父类，如果它的子类没有被其他注解修饰，则它的子类也继承父类的注解。 </li><li>@Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但每次注解可以代表不同的含义。</li></ul><p><strong>注解的作用</strong></p><ol><li>生成文档。这是最常见的，也是 Java 最早提供的注解。常用的有 @param @return 等</li><li>跟踪代码依赖性，实现替代配置文件功能。</li><li>在编译时进行格式检查。如@override 放在方法前，如果该方法并没有覆盖超类方法，则编译时就能检查出。</li></ol><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Java-中的参数传递是传值还是传引用？"><a href="#Java-中的参数传递是传值还是传引用？" class="headerlink" title="Java 中的参数传递是传值还是传引用？"></a>Java 中的参数传递是传值还是传引用？</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><ul><li><p>基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;before change, i = &quot;</span>+i);</span><br><span class="line">        change(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change, i = &quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        i = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change, i = 1</span><br><span class="line">after change, i = 1</span><br></pre></td></tr></table></figure></li><li><p>对象作为参数传递时，是把对象在内存中的地址的拷贝传给参数。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;before change, s is &quot;</span>+s.toString());</span><br><span class="line">        change(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change, s is &quot;</span>+s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer stringBuffer)</span></span>&#123;</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;World !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change, s is Hello </span><br><span class="line">after change, s is Hello World !</span><br></pre></td></tr></table></figure><p>可见 s 指向的对象的值被改变了，那么是否可以推论出，在Java中，当对象作为参数传递时，传递的是该对象的引用呢？再看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;before change, s is &quot;</span>+s.toString());</span><br><span class="line">        change(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;after change, s is &quot;</span>+s.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer stringBuffer)</span></span>&#123;</span><br><span class="line">        stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;Hi &quot;</span>);</span><br><span class="line">        stringBuffer.append(<span class="string">&quot;World !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的推论是正确的，即传递的是对象的引用，那么在调用 change 函数之后，原对象的值应该是会改变的，变为 “Hi World ！”，但运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before change, s is Hello </span><br><span class="line">after change, s is Hello </span><br></pre></td></tr></table></figure><p>当执行 <code>StringBuffer sb = new StringBuffer(“Hello “)</code> 时，创建了一个指向新建对象 <code>“Hello “</code> 的引用 <code>“s”</code>。在例 1 中，调用 change 函数后，实际上，形参 stringBuffer 也指向了实参 s 所指向的对象，那么执行 <code>stringBuffer.append(“world !”)</code> 后，便通过对象的引用 “stringBuffer” 修改了对象的值，使之变成 “Hello world ！”。但是在例 2 中又新建了一个对象 <code>“new StringBuffer(“Hi “)”</code>，让形参 stringBuffer 实际指向了这个新建的对象，并将新对象的值设置为 “Hi World ！”，但是因为值没有被 return 返回赋值给 s 对象，所以 s 对象并没有被改变，所以输出的仍然是 “Hello ”。</p></li></ul><h2 id="Java-中的-IO-流的分类？"><a href="#Java-中的-IO-流的分类？" class="headerlink" title="Java 中的 IO 流的分类？"></a>Java 中的 IO 流的分类？</h2><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流 和 字符流。</p><p>字节流：InputStream/OutputStream 是字节流的抽象类。</p><p>字符流：Reader/Writer 是字符的抽象类。</p><p>字节流按 $8$ 位传输，以字节为单位输入输出数据，字符流按 $16$ 位传输，以字符为单位输入输出数据。</p><p>但是不管文件读写还是网络发送接收，信息的最小存储单元都是字节。</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ul><li><p>修饰类：表示类不可被继承；</p></li><li><p>修饰方法：表示方法不可被子类覆盖，但可以重载；</p></li><li><p>修饰变量：表示变量一旦被赋值就不可以更改它的值。</p><p>$(1)$ 修饰类变量：只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</p><p>$(2)$ 修饰成员变量：可以在非静态初始化块声明该变量或者构造器中执行初始值。</p><p>$(3)$ 修饰局部变量：系统不会为局部变量初始化，必须由程序员显式初始化。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//类变量：在声明的时候赋值 或者 静态代码块赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">0</span>;<span class="comment">//成员变量：在声明的时候赋值 或者 构造器赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> local; <span class="comment">// 局部变量</span></span><br><span class="line">        local = <span class="number">0</span>; <span class="comment">// 使用之前一定要赋值</span></span><br><span class="line">        <span class="comment">//local = 1; 不允许第二次赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   $(4)$ 修饰基本数据类型的变量：数值初始化后不能修改。<br>   $(5)$ 修饰引用类型的变量：初始化后不能指向另一个变量，但是引用的值是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] mylist = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">mylist[<span class="number">2</span>] = -<span class="number">3</span>; <span class="comment">// 合法</span></span><br><span class="line">mylist = <span class="keyword">null</span>; <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Person p = <span class="keyword">new</span> Person(<span class="number">25</span>);</span><br><span class="line">p.setAge(<span class="number">24</span>); <span class="comment">// 合法</span></span><br><span class="line">p = <span class="keyword">null</span>; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure><h3 id="为什么局部内部类和匿名内部类只能访问局部-final-变量？"><a href="#为什么局部内部类和匿名内部类只能访问局部-final-变量？" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部 final 变量？"></a>为什么局部内部类和匿名内部类只能访问局部 final 变量？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 局部final变量a,b</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outPrint</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inclass</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">                System.out.println(age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> InClass().InPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类和外部类是同一级别的，比如 Test 类编译之后会生成两个 class文件：Test.class、Test1.class。内部类不会因为定义在方法中而随着方法执行完毕就被销毁。当外部类的方法结束时，局部变量会被销毁，但是内部类对象可能还存在(没人引用时才死亡)，这时就出现了矛盾：内部类对象访问了一个不存在的变量。为解决这个问题，将方法中的局部变量复制一份作为内部类的成员变量，当局部变量被销毁，内部类还可以访问它的 “copy”。将局部变量设置为 final，内部类就无法修改这个变量，可以保证内部类的成员变量和方法中的局部变量保持一致。</p><h3 id="final、finally-和-finalize-的区别"><a href="#final、finally-和-finalize-的区别" class="headerlink" title="final、finally 和 finalize 的区别"></a>final、finally 和 finalize 的区别</h3><ol><li><p>final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。</p></li><li><p>finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块表示这个语句最后执行(在 return 之前执行)，经常被用在需要释放资源的情况下。</p><p><strong>当遇到下面情况 finally 代码块不会执行</strong>：</p><ul><li>当程序在进入 try 语句块之前就出现异常时会直接结束。</li><li>当程序在 try 块中强制退出时，如使用 System.exit(0)。</li></ul></li><li><p>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize() 方法。当垃圾回收器准备好释放对象占用空间时，首先会调用finalize()方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。</p></li></ol><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>1. 静态变量</strong> </p><p>静态变量在内存中只存在一份，只在类第一次实例化时初始化一次。</p><ul><li>静态变量：静态变量在内存中仅有一个拷贝，类所有的实例都共享静态变量，可以直接通过类名来访问它；</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;        <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 静态方法</strong> </p><p>在类中使用 static 修饰的静态方法会随着类的定义而被分配和装载入内存中；而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段。</p><p>非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员；<br>非静态方法既可以访问静态方法又可以访问非静态方法，而静态方法只能访问静态数据方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(S.getStatic());<span class="comment">//使用类名加前缀访问静态方法</span></span><br><span class="line">        S s=<span class="keyword">new</span> S();</span><br><span class="line">        System.out.println(s.getStatic());<span class="comment">//使用实例化对象名访问静态方法</span></span><br><span class="line">        System.out.println(s.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态初始器：由static和&#123;&#125;组成，只在类装载时（第一次使用类）执行一次，用来初始化静态变量。</span></span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            a=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态方法只能访问静态数据成员</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStatic</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getT</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> t;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//非静态方法可以访问静态方法和非静态方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            getT();</span><br><span class="line">            getStatic();</span><br><span class="line">            t=a;<span class="comment">//非静态方法可以访问非静态数据成员和静态数据成员</span></span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3. 静态语句块</strong> </p><p>静态语句块和静态变量一样在类第一次实例化时运行一次。</p><p><strong>4. 初始化顺序</strong> </p><p>静态数据优先于其它数据的初始化，静态变量和静态语句块的运行顺序取决于它们在代码中的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例变量和普通语句块的初始化在静态变量和静态语句块初始化结束之后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String field = <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后才是构造函数中的数据进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InitialOrderTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在继承的情况下，初始化顺序为：</p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><h1 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h1><p>Object 里面有的方法，所有类都是继承 Object，所以“所有对象都有这些方法”。</p><blockquote><p>Java 中创建对象的几种方式？</p></blockquote><ul><li>使用 new 关键字；</li><li>反射，使用 Class 类的 newInstance 方法，该方法调用无参的构造器创建对象；</li><li>使用 clone() 方法；</li><li>反序列化。</li></ul><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals() 与 == 的区别"></a>equals() 与 == 的区别</h3><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个实例是否引用同一个对象，而 equals() 判断引用对象的值是否相等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>重写</strong></p><p>以 Dog 类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="comment">// 判断地址是否相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="comment">// 判断对象是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(getClass()!=obj.getClass()) <span class="comment">// getClass()可以得到类对象，判断类型是否一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Dog other = (Dog) obj;</span><br><span class="line">    <span class="keyword">if</span>(age!=other.age) <span class="comment">// 判断属性值是否一样</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 如果地址相同，对象不为空，类型一样，属性值一样则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>obj.getClass()</code> 得到的类对象和类的对象不同，前者得到的是类的定义，后者是实例化的具体类。</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>哈希码是通过哈希算法生成的一个字符串，它是用来<strong>唯一</strong>区分我们对象的地址码。</p><p>理想的散列函数应当具有均匀性，即不相等的实例应当均匀分不到所有可能的散列值上。</p><h3 id="两个对象的-hashCode-相同，则-equals-也一定为-true-吗？"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true-吗？" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true 吗？</h3><p>hasCode() 返回散列值，而 equals() 是用来判断两个实例是否相等。相等的两个实例散列值一定要相同，但是散列值相同的两个实例不一定相等。</p><h3 id="为什么重写-equals-就一定要重写-hashCode-方法？"><a href="#为什么重写-equals-就一定要重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 就一定要重写 hashCode() 方法？"></a>为什么重写 equals() 就一定要重写 hashCode() 方法？</h3><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证相等的两个实例散列值也相等。如果没有重写 hasCode()，则两个对象无论如何都不会相等，即使它们指向相同的数据。</p><p>这个问题应该是有个前提，就是你需要用到 HashMap、HashSet 等 Java 集合，用不到哈希表的话，其实仅仅重写 equals() 方法也可以。而工作中的场景是常常用到 Java 集合，所以 Java 官方建议重写 equals() 就一定要重写 hashCode() 方法。</p><p>对于对象集合的判重，如果一个集合含有大量对象实例，仅仅使用 equals() 方法的话，那么对于一个对象判重就需要比较很多次，随着集合规模的增大，时间开销很大。但是同时使用哈希表的话，就能快速定位到对象的大概存储位置，并且在后续比较过程中，如果两个对象的 hashCode 不相同，就不需要调用 equals() 方法，从而大大减少了 equals() 比较次数。</p><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>Object 类的 <code>toString</code> 方法返回一个字符串，该字符串由类名、@和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">&#x27;@&#x27;</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><p>它通常只是为了方便输出，比如 System.out.println(xx)，括号里面的 “xx” 如果不是 String 类型的话，就自动调用 xx 的 toString() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;this is A&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    A obj = <span class="keyword">new</span> A();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：this is A</span></span><br><span class="line"><span class="comment">// 如果去掉重写的toString，会输出：MyType$A@1e643faf</span></span><br></pre></td></tr></table></figure><p>打印 StringBuffer 类型必须用 toString，自动调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StringBuffer MyStrBuff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">MyStrBuff.append(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">System.out.println(MyStrBuff.toString());</span><br><span class="line">System.out.println(MyStrBuff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Hello!</span></span><br><span class="line"><span class="comment">//Hello!</span></span><br></pre></td></tr></table></figure><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p><strong>1. cloneable</strong> </p><p>clone() 是 Object 的受保护方法，这意味着，如果一个类不显式去重载 clone() 就没有这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">CloneExample e1 = <span class="keyword">new</span> CloneExample();</span><br><span class="line">CloneExample e2 = e1.clone(); <span class="comment">// &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span></span><br></pre></td></tr></table></figure><p>接下来重载 Object 的 clone() 得到以下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MyType <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (MyType)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">MyType e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><p><strong>2. 深拷贝与浅拷贝</strong> </p><ul><li>浅拷贝：拷贝实例和原始实例的引用类型引用同一个对象；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MyType <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (MyType) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line">MyType e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 222</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深拷贝：拷贝实例和原始实例的引用类型引用不同对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> MyType <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    MyType result = (MyType) <span class="keyword">super</span>.clone();</span><br><span class="line">        result.arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            result.arr[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line">MyType e2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    e2 = e1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(MyType original)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[original.arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; original.arr.length; i++) &#123;</span><br><span class="line">            arr[i] = original.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        arr[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyType e1 = <span class="keyword">new</span> MyType();</span><br><span class="line">MyType e2 = <span class="keyword">new</span> MyType(e1);</span><br><span class="line">e1.set(<span class="number">2</span>, <span class="number">222</span>);</span><br><span class="line">System.out.println(e2.get(<span class="number">2</span>)); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>成员可见表示其它类可以用这个类的实例访问到该成员；</li><li>类可见表示其它类可以用这个类创建对象。</li></ul><p>protected：子类可以用它修饰的成员。</p><p>private：访问权限仅限于类的内部，是一种封装的体现。</p><p>default：有时也称为friendly，任何处于本包下的类、接口、异常等，都可以相互访问。</p><div class="table-container"><table><thead><tr><th></th><th>类内部</th><th>本包</th><th>子类</th><th>外部包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table></div><p>如果子类的方法覆盖了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例。</p><p>字段绝不能是公有的，因为这么做的话就失去了对这个实例域修改行为的控制，客户端可以对其随意修改。可以使用共有的 getter 和 setter 方法来替换共有字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessWithInnerClassExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InnerClass innerClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessWithInnerClassExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClass.x; <span class="comment">// 直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><ul><li>this关键字<strong>代表当前对象</strong></li></ul><p>　　this.属性 操作当前对象的属性</p><p>　　this.方法 调用当前对象的方法。</p><ul><li><p>封装对象的属性的时候，经常会使用this关键字。</p></li><li><p>当 getter 和 setter 函数参数名和成员函数名重合的时候，可以使用 this 区别。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScreen</span><span class="params">(<span class="keyword">float</span> screen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.screen = screen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类 (Inner Class) 就是定义在另外一个类里面的类。</p><ul><li>内部类提供了<strong>更好的封装</strong>，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li><li>内部类的方法可以<strong>直接访问外部类的所有数据</strong>，包括私有的数据。</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。</li></ul><p>内部类可分为以下几种： </p><ul><li><p>成员内部类</p><p>最常见，也称为普通内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">99</span>; <span class="comment">// 外部类的私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;访问内部类中的a：&quot;</span>+a);</span><br><span class="line">            System.out.println(<span class="string">&quot;this访问内部类中的a：&quot;</span>+<span class="keyword">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;this访问外部类中的a：&quot;</span>+Outer.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">        Inner i = o.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        i.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问外部类中的a：2</span><br><span class="line">this访问内部类中的a：2</span><br><span class="line">访问外部类中的a：99</span><br></pre></td></tr></table></figure></li><li><p>静态内部类</p><p>静态内部类是 <strong>static 修饰的</strong>内部类，这种内部类的特点是：</p><ul><li>静态内部类不能直接访问外部类的非静态成员，但可以通过<strong>new 外部类().成员</strong>的方式访问。</li><li>如果外部类的静态成员与内部类的成员<strong>名称相同</strong>，可通过“<strong>类名.静态成员</strong>”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称<strong>不相同</strong>，则可通过“<strong>成员名”</strong>直接调用外部类的静态成员。</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <strong>内部类 对象名= new 内部类();</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SOuter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">99</span>; <span class="comment">// 外部类的私有属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SInner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>; <span class="comment">// 内部类的变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;访问外部类中的a：&quot;</span>+<span class="keyword">new</span> SOuter().a);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问外部类中的b：&quot;</span>+SOuter.b);</span><br><span class="line">            System.out.println(<span class="string">&quot;访问内部类中的b：&quot;</span>+b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SInner si = <span class="keyword">new</span> SInner(); <span class="comment">// 直接创建内部类的对象</span></span><br><span class="line">        si.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">访问外部类中的a：99</span><br><span class="line">访问外部类中的b：1</span><br><span class="line">访问内部类中的b：2</span><br></pre></td></tr></table></figure></li><li><p>方法内部类</p><p>方法内部类就是内部类定义在外部类的<strong>方法中</strong>，方法内部类只在该方法的内部可见，即<strong>只在该方法内可以使用</strong>。因此方法内部类不能使用访问控制符和 static 修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MOuter</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">13</span>;</span><br><span class="line"><span class="comment">// 方法内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MInner</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;访问外部类的方法中的a：&quot;</span>+a);</span><br><span class="line">                System.out.println(<span class="string">&quot;访问内部类中的c：&quot;</span>+c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MInner mi = <span class="keyword">new</span> MInner();</span><br><span class="line">mi.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MOuter e = <span class="keyword">new</span> MOuter();</span><br><span class="line">e.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">访问外部类的方法中的a：25</span><br><span class="line">访问内部类中的c：2</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类　　</p><p>匿名类是<strong>不能有名称的类</strong>，所以没办法引用他们。必须在创建时，作为<strong>new语句</strong>的一部分来声明他们。但使用匿名内部类还有个前提条件：<strong>必须继承一个父类或实现一个接口。</strong></p><p>匿名类的声明是在编译时进行的，实例化在运行时进行。这意味着 for 循环中的一个 new 语句会创建相同匿名类的几个实例，而不是创建几个不同匿名类的一个实例。</p><p>假如要执行的任务需要一个对象，但却不值得创建全新的对象，匿名类就显得很有用。</p><ul><li><p>匿名内部类的基本实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在接口上使用匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat something&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.eat();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在使用匿名内部类的过程中，需要注意如下几点：</p><ol><li>使用匿名内部类时，必须继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</li><li>匿名内部类中是不能定义构造函数的。</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li>匿名内部类为局部内部类（即方法内部类），所以局部内部类的所有限制同样对匿名内部类生效。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ol></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是类与类的一种关系，是一种 “is a” 的关系。比如“狗”继承“动物”，这里动物类是狗类的父类或者基类，狗类是动物类的子类或者派生类。Java 中的继承是单继承，即一个类只有一个父类。</p><p>优点：子类拥有父类的所有属性和方法（除了 private 修饰的属性）从而实现代码的复用。</p><p><strong>重写</strong>：子类如果对继承的父类的方法不满意，可以自己编写继承的方法，这种方式就称为方法的重写。当调用方法时会优先调用子类的方法。</p><h2 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h2><ul><li>重载：发生在同一个类中的多态手段，方法名必须相同，参数列表不同(个数、顺序)，返回值和访问修饰符可以不同，发生在编译时。</li><li>重写：发生在父子类中，方法名、参数列表必须相同，返回值范围和抛出的异常范围小于等于父类，访问修饰符范围大于等于父类，如果父类方法访问修饰符为 private 则子类不能重写该方法。</li></ul><h3 id="是否可以重写一个-private-或者-static-方法？"><a href="#是否可以重写一个-private-或者-static-方法？" class="headerlink" title="是否可以重写一个 private 或者 static 方法？"></a>是否可以重写一个 private 或者 static 方法？</h3><p>Java 中 static 方法可以被继承但不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。</p><p>Java 中也不能覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的。</p><h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><ul><li><p>重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu a =  <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li><li><p>重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String name,<span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> i,String name)</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Smoking sk = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//学生是类，Smoking是接口 </span></span><br></pre></td></tr></table></figure></li><li><p>抽象类和抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line"><span class="comment">//Animal是父类抽象类</span></span><br></pre></td></tr></table></figure></li></ul><p>多态特点：</p><ol><li>方法成员变量、静态方法看父类</li><li>非静态方法编译时看父类，运行时看子类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu method_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu method_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">8</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi method_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi method_2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(f.num);<span class="comment">//与父类一致</span></span><br><span class="line">        f.method1();<span class="comment">//与父类一致</span></span><br><span class="line">        f.method2();<span class="comment">//编译时与父类一致，运行时与子类一致</span></span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(z.num);</span><br><span class="line">        z.method1();</span><br><span class="line">        z.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">fu method<span class="emphasis">_1</span></span><br><span class="line"><span class="emphasis">zi method_</span>2</span><br><span class="line">8</span><br><span class="line">zi method<span class="emphasis">_1</span></span><br><span class="line"><span class="emphasis">zi method_</span>2</span><br></pre></td></tr></table></figure><h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><p><strong>1. 抽象类</strong> </p><p>抽象类和抽象方法都使用 abstract 进行声明。</p><ul><li><p>抽象类不能被实例化，如果被实例化，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</p></li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Telephone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类的普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">Telephone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="comment">//继承抽象类的子类必须重写抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写抽象类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Telephone p = <span class="keyword">new</span> Phone();</span><br><span class="line">        p.call();</span><br><span class="line">        p.message();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写抽象类的方法</span><br><span class="line">抽象类的普通方法</span><br></pre></td></tr></table></figure><p><strong>2. 接口</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义的语法</span></span><br><span class="line">[可见度] <span class="class"><span class="keyword">interface</span> 接口名称 [<span class="keyword">extends</span> 其他的接口名] </span>&#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承父类实现接口的语法</span></span><br><span class="line">[修饰符] <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 接口1，接口2...</span>&#123;</span><br><span class="line">    <span class="comment">//如果继承了抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口（Interface），在 Java 中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p><ul><li><p>接口无法被实例化，没有构造方法，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。</p></li><li><p>接口不能包含成员变量，除了 static 和 final 变量。接口中的变量会被隐式的指定为 <code>public static final</code> 变量。</p></li></ul><ul><li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。接口中的方法会被隐式的指定为 <code>public abstract</code>。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 <code>default</code> 关键字修饰。</li><li>接口中的方法都是公有的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPlayGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paly</span><span class="params">()</span></span>; <span class="comment">//abstract 关键字可以省略，系统会自动加上</span></span><br><span class="line">    <span class="keyword">public</span> String name=<span class="string">&quot;游戏名字&quot;</span>; <span class="comment">//static final关键字可以省略，系统会自动加上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> <span class="keyword">extends</span> <span class="title">Telephone</span> <span class="keyword">implements</span> <span class="title">IPlayGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;<span class="comment">//继承抽象类的子类必须重写抽象方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写抽象类的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IPlayGame i=<span class="keyword">new</span> Phone(); <span class="comment">//用接口的引用指向子类的对象</span></span><br><span class="line">        i.paly(); <span class="comment">//调用接口的方法</span></span><br><span class="line">        System.out.println(i.name); <span class="comment">//输出接口的常量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重写接口的方法</span><br><span class="line">游戏名字</span><br></pre></td></tr></table></figure><p><strong>3. 比较</strong> </p><ul><li>从设计层面上看，抽象类是对类本质的抽象，表达 is a 的关系，比如 BMW is a Car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类实现。而接口是对方法的抽象，表达 like a 的关系，比如 Bird like a Aircraft(鸟像飞机一样可以飞)，鸟可以实现飞机飞的方法但鸟不是飞机。接口的核心是定义方法，即实现类可以做什么，至于谁实现，如何实现，接口并不关心。</li><li>从使用上来看，一个类可以实现多个接口，但只能继承一个抽象类。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型。</li><li>抽象类可以有抽象方法和具体方法，而接口中只能存在抽象(public abstract)方法。</li><li>抽象类中可以定义构造函数，接口不能定义构造函数。</li></ul><p>在 JDK1.8中，允许在接口中包含带有具体实现的方法，使用 default 修饰，这类方法就是默认方法。</p><p><strong>4. 使用选择</strong> </p><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码；</li><li>需要能控制继承来的方法和域的访问权限，而不是都为 public。</li><li>需要继承非静态（non-static）和非常量（non-final）字段。</li></ul><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而完成一些初始化的工作。</li><li>访问父类的成员：如果子类覆盖了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperExtendExample</span> <span class="keyword">extends</span> <span class="title">SuperExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperExtendExample</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>.z = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperExtendExample.func()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SuperExample e = <span class="keyword">new</span> SuperExtendExample(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">e.func();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperExample.func()</span><br><span class="line">SuperExtendExample.func()</span><br></pre></td></tr></table></figure><h3 id="在-Java-中定义一个不做事且没有参数的构造方法有什么作用？"><a href="#在-Java-中定义一个不做事且没有参数的构造方法有什么作用？" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法有什么作用？"></a>在 Java 中定义一个不做事且没有参数的构造方法有什么作用？</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误。</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String、StringBuffer-和-StringBuilder"><a href="#String、StringBuffer-和-StringBuilder" class="headerlink" title="String、StringBuffer 和 StringBuilder"></a>String、StringBuffer 和 StringBuilder</h2><p><strong>1. 是否可变</strong> </p><ul><li>String 是 final 修饰的，不可变，意味着每次操作都会产生新的 String 对象；</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><strong>2. 是否线程安全</strong> </p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 来同步</li><li>StringBuilder 不是线程安全的</li></ul><p>性能：StringBuilder &gt; StringBuffer &gt; String</p><p>使用场景：优先使用 StringBuilder，多线程使用共享变量时用 StringBuffer。</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><p>使用 String.intern() 可以保证相同内容的字符串实例引用相同的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用，这个方法首先把 s1 引用的对象放到 String Poll（字符串常量池）中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">System.out.println(s1.intern() == s3);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Poll 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s4 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">String s5 = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Java 6 之前，字符串常量池被放在永久代中，而在 Java 7 时，它被放在堆的其它位置。这是因为永久代的空间有限，如果大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="String-为什么要设计为不可变类？"><a href="#String-为什么要设计为不可变类？" class="headerlink" title="String 为什么要设计为不可变类？"></a>String 为什么要设计为不可变类？</h2><p>（1）字符串常量池的需要：当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；</p><p>（2）允许 String 对象缓存 HashCode：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，意味着不必每次都去计算新的哈希码；</p><p>（3）String 被许多的 Java 类(库)用来当做参数，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。</p><h1 id="基本类型与运算"><a href="#基本类型与运算" class="headerlink" title="基本类型与运算"></a>基本类型与运算</h1><h2 id="基本类型与包装类型"><a href="#基本类型与包装类型" class="headerlink" title="基本类型与包装类型"></a>基本类型与包装类型</h2><p>八个基本类型：</p><ul><li><p>byte: 占用 1 个字节，</p><p>取值范围 $-128$ ~ $127$ </p></li><li><p>short: 占用 2 个字节</p><p>取值范围 $-2^{15} $~ $2^{15} -1 $</p></li><li><p>int：占用 4 个字节</p><p>取值范围 $-2^{31} $~ $2^{31} -1 $</p></li><li><p>long：占用 8 个字节 </p></li><li><p>float：占用 4 个字节 </p></li><li><p>double：占用 8 个字节 </p></li><li><p>char: 占用 2 个字节 </p></li><li><p>boolean：占用大小根据实现虚拟机不同有所差异</p></li></ul><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用<strong>自动装箱与拆箱</strong>完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><h2 id="Integer-和-int-的区别"><a href="#Integer-和-int-的区别" class="headerlink" title="Integer 和 int 的区别"></a>Integer 和 int 的区别</h2><p>（1）int 是 Java 的八种基本数据类型之一，而 Integer 是 Java 为 int 类型提供的封装类；</p><p>（2）int 型变量的默认值是 0，Integer 变量的默认值是 null，说明 Integer 可以区分未赋值和值为 0；</p><p>（3）Integer 变量必须实例化后才可以使用，而 int 不需要。</p><p>延伸：</p><ul><li>Integer 变量和 int 变量比较时，只要两个变量的值是相等的，则结果为 true。因为包装类 Integer 和基本数据类型 int 类型进行比较时，Java 会自动拆包装类为 int，然后进行比较，实际上就是两个 int 型变量在进行比较；</li><li>由于 Integer 变量实际上是对一个 Integer 对象的引用，所以两个通过 new 生成的 Integer 变量永远是不相等的，因为其内存地址是不同的；</li><li>非 new 生成的 Integer 变量和 new Integer() 生成的变量进行比较时，结果为 false。因为非 new 生成的 Integer 变量指向的是 Java 常量池中的对象，而 new Integer() 生成的变量指向堆中新建的对象；</li><li>对于两个非 new 生成的 Integer 对象进行比较时，如果两个变量的值在区间 $[-128, 127]$ 之间，则比较结果为 true，否则为 false。</li></ul><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和 &amp;&amp; 的区别"></a>&amp; 和 &amp;&amp; 的区别</h2><p>Java 中 &amp;&amp; 和 &amp; 都表示逻辑运算符与(and)，当两边的表达式都为 true 的时候，整个运算结果才为 true，否则为 false。</p><p>&amp;&amp;：有短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；</p><p>&amp;：不管第一个表达式结果是否为 true，第二个都会执行。</p><p>&amp; 还可以用作位运算符，当 &amp; 两边的表达式不是 Boolean 类型的时候，&amp; 表示按位操作。</p><h3 id="Math-round-1-5"><a href="#Math-round-1-5" class="headerlink" title="Math.round(-1.5)"></a>Math.round(-1.5)</h3><p>round 表示四舍五入，算法为 <code>Math.floor(x+0.5)</code> ，即将原来的数字加上 $0.5$ 后再向下取整，所以 <code>Math.round(1.5)</code> 的结果为 $2$，<code>Math.round(-1.5)</code> 的结果为 $-1$。</p><h3 id="两个二进制数的异或结果"><a href="#两个二进制数的异或结果" class="headerlink" title="两个二进制数的异或结果"></a>两个二进制数的异或结果</h3><p>两个二进制数异或结果是这两个二进制数差的绝对值。表达式如下：$a\bigoplus b = |a-b|$。</p><h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于，new Integer(123) 每次都会新建一个对象，而 Integer.valueOf(123) 可能会使用缓存对象，因此多次使用 Integer.valueOf(123) 会取得同一个对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>编译器会在自动装箱过程调用 <code>valueOf()</code> 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>valueOf()</code> 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 中，Integer 缓存池的大小默认为 $-128$~$127$。</p><p>Java 还将一些其它基本类型的值放在缓冲池中，包含以下这些：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>因此在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 switch(expr 1) 中，expr1 只能是一个整数表达式或者枚举常量。而整数表达式可以是 int 基本数据类型或者 Integer 包装类型。由于，byte、short、char 都可以隐式转换为 int，所以，这些类型以及这些类型的包装类型也都是可以的。而 long 类型都不符合 switch 的语法规定，并且不能被隐式的转换为 int 类型，所以不能作用于 switch 语句中。</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong>  和 <strong>Exception</strong>。其中 Error 一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防；Exception 分为两种：</p><ol><li><strong>受检异常</strong> ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复；</li><li><strong>非受检异常</strong> ：是运行时异常，如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。可以编译通过，但是一运行就崩溃，程序不会自己处理；</li></ol><p><img src="PPjwP.png" alt=""></p><h2 id="throw与throws"><a href="#throw与throws" class="headerlink" title="throw与throws"></a>throw与throws</h2><ul><li><p>throw：用在方法体内，用来抛出一个具体的异常类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> Exception1,Exception3</span>&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">                 ......</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception1 e)&#123;</span><br><span class="line">              <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;<span class="keyword">catch</span>(Exception2 e)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(a!=b)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span>  Exception3(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throws 用在方法声明后面，用来声明一个方法可能产生的所有异常，不做任何处理而是将异常往上传，谁调用我我就抛给谁。throws 表示出现异常的一种可能性，并不一定会发生这些异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun()可能出现两种异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span><span class="keyword">throws</span> IOException,SQLException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用fun()时要准备处理两种异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="try-catch-finally-中，若-catch-中-return，finally-还执行吗？"><a href="#try-catch-finally-中，若-catch-中-return，finally-还执行吗？" class="headerlink" title="try-catch-finally 中，若 catch 中 return，finally 还执行吗？"></a>try-catch-finally 中，若 catch 中 return，finally 还执行吗？</h2><p>会执行。程序在执行到 return 时会首先将返回值存储在一个指定的位置，其次去执行 finally 块，最后再返回。因此，对基本数据类型，在 finally 块中改变 return 的值没有任何影响，直接覆盖掉；而对引用类型是有影响的，返回的是在 finally 对前面 return 语句返回对象的修改值。</p><h2 id="主线程可以捕获到子线程的异常吗？"><a href="#主线程可以捕获到子线程的异常吗？" class="headerlink" title="主线程可以捕获到子线程的异常吗？"></a>主线程可以捕获到子线程的异常吗？</h2><p>正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。如果想要在主线程中捕获子线程的异常，可以用如下的方式进行处理，使用 Thread 的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandle());</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。</p><p>自定义泛型类和方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">&quot;corn&quot;</span>);</span><br><span class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name class:&quot;</span> + name.getClass());      <span class="comment">// class test.Box</span></span><br><span class="line">        System.out.println(<span class="string">&quot;age class:&quot;</span> + age.getClass());        <span class="comment">// class test.Box</span></span><br><span class="line">        System.out.println(name.getClass() == age.getClass());    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// T stands for &quot;Type&quot;</span></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">this</span>.t = t; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型类时，虽然传入不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然在逻辑上可以理解成多个不同的泛型类型。</p><p>Java 中泛型这一概念只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的 class 文件中是不包含任何泛型信息的。</p><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>Java 编译器生成的字节码不包含泛型信息，泛型类型信息将在编译处理时被擦除，这个过程被称为泛型擦除。</p><h2 id="泛型中的限定通配符和非限定通配符"><a href="#泛型中的限定通配符和非限定通配符" class="headerlink" title="泛型中的限定通配符和非限定通配符"></a>泛型中的限定通配符和非限定通配符</h2><p>两种限定通配符:</p><ul><li>&lt; ? extends T &gt; 通过确保类型必须是 T 的子类来设定类型的上界；</li><li>&lt; ? super T &gt; 通过确保类型必须是 T 的父类来设定类型的下界。</li></ul><p>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。<br>&lt; ? &gt; 表示非限定通配符，因为 &lt; ? &gt; 可以用任意类型来替代。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;字节序&quot;&gt;&lt;a href=&quot;#字节序&quot; class=&quot;headerlink&quot; title=&quot;字节序&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://10185102110.github.io/2021/08/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://10185102110.github.io/2021/08/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-08-08T08:56:52.000Z</published>
    <updated>2021-08-28T04:49:00.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><h1 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给每个对象添加一个计数器，当有地方引用该对象时计数器加 $1$，当引用失效时计数器减 $1$。用对象计数器是否为 $0$ 来判断对象是否可被回收。</p><p>缺点：<strong>无法解决循环引用的问题</strong>。</p><p>例如创建一个字符串，<code>String m = new String(&quot;jack&quot;);</code>，这时候 “jack” 有一个引用，就是 m。然后将 m 设置为 null，这时候 “jack” 的引用次数为 $0$ ，在引用计数算法中，意味着这块内容需要被回收了。</p><p>引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。但 JVM 的垃圾回收就是 Stop-The-World(暂停整个程序) 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object instance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">&quot;objA&quot;</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">&quot;objB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最后这 $2$ 个对象已经不会再被访问了，但由于它们相互引用对方，导致它们的引用计数永远都不会为 $0$，通过引用计数算法无法通知 GC 收集器回收它们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>以 GC ROOT 的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收。</p><p><img src="2269232-97bf646f648d6ff7.webp" alt=""></p><p>可达性算法解决了引用计数所无法解决的循环依赖问题，只要对象无法与 GC Root 建立直接或间接的连接，系统就会将其判定为可回收对象。</p><p>Java 内存区域中可以作为 GC ROOT 的对象：</p><ul><li><p>虚拟机栈中引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 s 即为 GC Root，当 s 置空时，“example1” 对象也断掉了与 GC Root 的引用链，将被回收。</p></li><li><p>方法区中类静态属性引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MyType m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s.m = <span class="keyword">new</span> MyType(<span class="string">&quot;example2&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 s 即为 GC Root，s 置为 null，经过GC后，s 所指向的 “example1” 对象由于无法与 GC Root 建立关系被回收。而 m 作为类的静态属性，也属于 GC Root，“example2” 对象依然与 GC root 建立着连接，所以 “example2” 对象不会被回收。</p></li><li><p>方法区中常量引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MyType m = MyType(<span class="string">&quot;final&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m 即为方法区中的常量引用，也是 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。</p></li><li><p>本地方法栈中引用的对象</p><p>任何 native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，只是简单地动态连接并直接调用指定的本地方法。</p></li></ul><blockquote><p>引用类型</p></blockquote><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 中有四种强度不同的引用类型。引用由强到若分为：强引用、软引用、弱引用、虚引用。</p><ul><li><p><strong>强引用：</strong>使用 new 一个新对象的方式来创建强引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p><strong>软引用：</strong>一些还有用但并非必须的对象。软引用关联着的对象，在系统要发生内存溢出之前，会把这些对象进行垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用：</strong>也是描述一些非必须对象，强度比软引用更弱，只要发生垃圾回收，它就一定会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用：</strong>是最弱的一种引用。设置虚引用的唯一目的是能在这个对象被回收时会收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p><img src="2269232-5b023b00f7bf8f1b.webp" alt=""></p><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>缺点：<strong>内存碎片</strong>。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><img src="2269232-46c30f2ffb8c18af.webp" alt=""></p><p>复制算法（Copying）能解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。</p><p>缺点：内存利用率只有 $50\%$。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><img src="2269232-d7cb73cb0e50c060.webp" alt=""></p><p>标记-整理算法标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>标记整理算法解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。</p><p>缺点：对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上较差。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代收集算法融合上述3种基础的算法思想，根据对象存活周期的不同将内存划分为几块。</p><ul><li><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p><p>JVM 新生代采用这种算法，但并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>Eden 和 Survivor 大小比例默认为 $8:1$，保证了内存的利用率达到 $90\%$。</p></li><li><p>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记-清理算法</strong>或者<strong>标记-整理算法</strong>来进行回收。</p></li></ul><h1 id="内存区域与回收策略"><a href="#内存区域与回收策略" class="headerlink" title="内存区域与回收策略"></a>内存区域与回收策略</h1><h2 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h2><p>大多数情况下，对象会在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC。通过 Minor GC 之后，Eden 区中绝大部分对象会被回收，而那些存活对象，将会送到 Survivor 的 From 区（若 From 区空间不够，则直接进入 Old 区） 。</p><p><strong>Minor GC：</strong></p><p>当年轻代满时就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。通过<strong>复制算法</strong> ,回收垃圾。</p><p><strong>Major GC：</strong></p><p>Major GC 又称为 <strong>Full GC</strong>。当年老代空间不够用的时候，虚拟机会使用“<strong>标记-清除</strong>”或者“<strong>标记-整理</strong>”算法清理出连续的内存空间，分配对象使用。</p><p>调用 System.gc() 时，系统建议执行 Full GC，但是不必然执行。</p><h2 id="Survivor区"><a href="#Survivor区" class="headerlink" title="Survivor区"></a>Survivor区</h2><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲。Survivor 分为 $2$ 个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区中存活的对象放到 Survivor 的 From 区，而在 From 区中，仍存活的对象会根据他们的年龄值来决定去向。（From Survivor 和 To Survivor 的逻辑关系会发生颠倒：From 变 To ， To 变 From，目的是保证有连续的空间存放对方，避免碎片化的发生）</p><blockquote><p>Survivor 区存在的意义</p></blockquote><p>如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor的预筛选保证，只有经历 $16$ 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓大对象是指，需要大量连续内存空间的Java对象，典型的大对象就是很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。</p><p>虚拟机提供了一个 <code>XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中（正常情况下对象会不断的在Survivor的From与To区之间移动），并且对象年龄设为 $1$。对象在 Survivor 区中每经历一次 Minor GC，年龄就增加 $1$ 岁，当它的年龄增加到一定程度（默认 $15$ 岁），就会晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>XX:MaxPretenuringThreshold</code> 设置。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>为了能更好地适应不同程度的内存状况，虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxPretenuringThreshold</code> 才能晋升老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到 <code>MaxPretenuringThreshold</code>中要求的年龄。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-08-08T08:56:22.000Z</published>
    <updated>2021-08-28T05:02:11.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存结构，主要就是分析 JVM 运行时数据存储区域。</p><p>JVM 的运行时数据区主要包括：<strong>堆、栈、方法区、程序计数器</strong>等。</p><p>而 JVM 的优化问题主要在<strong>线程共享的数据区</strong>中：<strong>堆、方法区</strong>。</p><p><img src="2019040912492050.png" alt=""></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，<strong>一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行</strong>。</p><p>为了确保线程切换后（<strong>上下文切换</strong>）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。也就是说程序计数器是<strong>线程私有的内存</strong>。</p><p>如果线程执行 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，计数器值为 Undefined。</p><p>程序计数器<strong>不会发生内存溢出</strong>（OutOfMemoryError 即 OOM）问题。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>JVM 中的栈包括 <strong>Java 虚拟机栈</strong> 和 <strong>本地方法栈</strong>，两者的区别就是，Java 虚拟机栈为 JVM 执行 Java 方法服务，本地方法栈则为 JVM 使用到的 Native 方法服务。Java 虚拟机栈，以下简称栈。</p><blockquote><p>Native 方法是什么？</p></blockquote><p>JDK 中有很多方法是使用 <strong>Native</strong> 修饰的。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）。Native 方法可以理解为是与操作系统直接交互的。比如通知垃圾收集器进行垃圾回收的代码 System.gc()，就是使用 native 修饰的。</p><blockquote><p>栈是什么？​</p></blockquote><p>定义：限定仅在表头进行插入和删除操作的线性表。即压栈（入栈）和弹栈（出栈）都是对栈顶元素进行操作的。所以栈是后进先出的。</p><p>栈是<strong>线程私有的</strong>，他的生命周期与线程相同。每个线程都会分配一个栈的空间，即每个线程拥有独立的栈空间。</p><blockquote><p>栈中存储的是什么？</p></blockquote><p><strong>栈帧</strong>是栈的元素。每个方法在执行时都会创建一个栈帧。栈帧中存储了<strong>局部变量表、操作数、动态链接和返回地址</strong>等信息。每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。</p><p><img src="20190409182042686.png" alt=""></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（String、数组、对象等），但是<strong>不存储对象的内容</strong>。局部变量表所需的内存空间<strong>在编译期间完成分配</strong>，在方法运行期间不会改变局部变量表的大小。</p><p>局部变量的容量以<strong>变量槽（Slot）</strong>为最小单位，每个变量槽最大存储 $32$ 位的数据类型。对于 $64$ 位的数据类型（long、double），JVM 会为其分配两个连续的变量槽来存储。</p><p>JVM 通过索引定位的方式使用局部变量表，索引的范围从 $0$ 开始至局部变量表中最大的变量槽数量。普通方法与 static 方法在第 $0$ 个槽位的存储有所不同，非 static 方法的第 $0$ 个槽位存储方法所属对象实例的引用。</p><blockquote><p>Slot 复用？</p></blockquote><p>为了尽可能的节省栈帧空间，局部变量表中的 <strong>Slot 是可以复用</strong>的。方法中定义的局部变量，其作用域不一定会覆盖整个方法。当方法运行时，如果已经超出了某个变量的作用域，即变量失效了，那这个变量对应的 Slot 就可以交给其他变量使用，也就是所谓的 Slot 复用。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">66</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当虚拟机运行 test 方法，就会创建一个栈帧，并压入到当前线程的栈中。当运行到 <code>int a = 66</code> 时，在当前栈帧的局部变量中创建一个 Slot 存储变量 a，当运行到 <code>int b = 55</code> 时，此时已经超出变量 a 的作用域（变量 a 的作用域在{}所包含的代码块中），此时 a 就失效了，变量 a 占用的 Slot 可以交给 b 来使用，这就是 Slot 复用。</p><p>Slot 复用虽然节省了栈帧空间，但是会直接影响到系统的垃圾收集行为。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码很简单，先向内存中填充了 64M 的数据，然后通知虚拟机进行垃圾回收。为了更清晰的查看垃圾回收的过程，在虚拟机的运行参数中加上 <code>-verbose:gc</code>，这个参数的作用就是打印 GC 信息。</p><p><img src="afas.png" alt=""></p><p>打印的GC信息如下：</p><p><img src="reh.png" alt=""></p><p>箭头前后的数据分别表示垃圾收集 GC 前后所有存活对象使用的内存容量，说明有70M-68M=2M 的对象容量被回收，而虚拟机没有回收这 64M 内存。为什么没有被回收？当执行 System.gc() 方法时，变量 placeholder 还在作用域范围之内，虚拟机是不会回收的，它还是“有效”的。</p><p>对上面的代码稍作修改，使其作用域“失效”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是虚拟机还是没有回收 placeholder 变量占用的 64M 内存，再对代码稍作修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 System.gc() 方法之前，加入 <code>int a = 0</code>，再执行方法，查看垃圾回收情况。</p><p><img src="qfgh.png" alt=""></p><p>发现 placeholder 变量占用的 64M 内存空间被回收了。</p><p>第一次修改中，限定了 placeholder 的作用域，但之后并没有任何对局部变量表的读写操作，placeholder 变量在局部变量表中占用的 Slot 没有被其它变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。所以 placeholder 变量没有被回收。</p><p>第二次修改后，运行到 int a = 0 时，已经超过了 placeholder 变量的作用域，此时 placeholder 在局部变量表中占用的 Slot 可以交给其他变量使用。而变量a正好复用了 placeholder 占用的 Slot，至此局部变量表中的 Slot 已经没有 placeholder 的引用了，虚拟机就回收了 placeholder 占用的 64M 内存空间。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈的<strong>元素可以是任意的Java数据类型</strong>。方法刚开始执行时，操作数栈是空的，在方法执行过程中，通过字节码指令对操作数栈进行压栈和出栈的操作。</p><p>通常进行<strong>算数运算</strong>的时候是通过操作数栈来进行的，又或者是在调用其他方法的时候通过操作数栈进行<strong>参数传递</strong>。操作数栈可以理解为栈帧中用于计算的临时数据存储区。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStack</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        add(<span class="number">100</span>, <span class="number">98</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add 方法刚开始执行时，操作数栈是空的。首先把局部变量 $0$ 压栈，即 $100$ 入操作数栈。然后执行把局部变量 $1$ 压栈，即 $98$ 入操作数栈。接着执行弹出两个变量（$100$ 和 $98$ 出操作数栈），对 $100$ 和 $98$ 进行求和，然后将结果 $198$ 压栈。然后弹出结果（出栈）。<br>局部变量表和操作数栈的变化情况如下图：</p><p><img src="20190409205401344.jpg" alt=""></p><blockquote><p>栈中可能出现哪些异常？</p></blockquote><ul><li>StackOverflowError：如果采用固定大小的 Java 虚拟机栈，线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，则抛出栈溢出错误。</li><li>OutOfMemoryError：如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，则抛出内存不足。</li></ul><blockquote><p>如何设置栈参数？</p></blockquote><p>使用参数 <strong>-Xss</strong> 设置线程的最大栈空间。由于栈是<strong>线程私有</strong>的，线程数越多，占用栈空间越大。</p><p>栈的大小直接决定函数调用的最大可达深度，这也是慎用递归调用的原因。递归调用时，每次调用方法都会创建栈帧并压栈。当调用一定次数之后，所需栈的大小已经超过了虚拟机运行配置的最大栈参数，就会抛出 StackOverflowError 异常。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>堆是 Java 虚拟机所管理的内存中最大的一块存储区域。堆内存被所有<strong>线程共享</strong>。主要存放使用 <strong>new</strong> 关键字创建的对象。所有<strong>对象实例以及数组</strong>都要在堆上分配。垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间。</p><p>Java 堆分为<strong>年轻代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation）；年轻代又分为伊甸园（Eden）和幸存区（Survivor区）；幸存区又分为 From Survivor 空间和 To Survivor 空间。</p><p>老年代存储<strong>长期存活的对象和大对象</strong>。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发 <strong>Full GC</strong>。</p><p><strong>Full GC </strong>是清理整个堆空间，包括年轻代和老年代。如果 Full GC 之后，堆中仍然无法存储对象，就会抛出<strong>OutOfMemoryError </strong>异常。</p><p>Java 堆设置常用参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>堆内存初始大小</td></tr><tr><td>-Xmx（MaxHeapSize）</td><td>堆内存最大允许大小，一般不要大于物理内存的80%</td></tr><tr><td>-XX:NewSize（-Xns）</td><td>年轻代内存初始大小</td></tr><tr><td>-XX:MaxNewSize（-Xmn）</td><td>年轻代内存最大允许大小，也可以缩写</td></tr><tr><td>-XX:NewRatio</td><td>新生代和老年代的比值，值为4 表示新生代:老年代=1:4</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>年轻代中Eden区与Survivor区的容量比例值，默认为8</td></tr><tr><td>XX:+HeapDumpOnOutOfMemoryError</td><td>内存溢出时，导出堆信息到文件</td></tr><tr><td>-XX:MaxTenuringThreshold=7</td><td>表示如果在幸存区移动多少次没有被垃圾回收，进入老年代</td></tr></tbody></table></div><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区同 Java 堆一样是被所有<strong>线程共享</strong>的区间，用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。关闭 JVM 会释放方法区的内存。</p><p>JDK1.8 使用元空间 <strong>MetaSpace</strong> 替代方法区，元空间并不在 JVM 中，而是使用本地内存。元空间两个参数：</p><ul><li>MetaSpaceSize：初始化元空间大小，控制发生 GC 的阈值</li><li>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</li></ul><p>常量池是方法区的一部分，存储编译器生成的各种字面量和符号引用。</p><p>字面量就是 Java 中常量的意思，包括字符串，final 修饰的常量和基本数据类型的值。</p><p>符号引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符。</p><blockquote><p>常量池有什么用 ？</p></blockquote><p>常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><ul><li><strong>Integer 常量池</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestIntegerCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="number">66</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> integer(<span class="number">66</span>);</span><br><span class="line">        Integer i3 = <span class="number">66</span>;</span><br><span class="line">        Integer i4 = <span class="number">66</span>;</span><br><span class="line">        Integer i5 = <span class="number">150</span>;</span><br><span class="line">        Integer i6 = <span class="number">150</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i5 == i6);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i1 和 i2 使用 new 关键字，每 new 一次都会在堆上创建一个对象，所以 <code>i1 == i2</code> 为 false。</p><p><code>Integer i3 = 66</code> 实际上有一步<strong>装箱</strong>的操作，即将 int 型的 66 装箱成 Integer，通过 Integer 的 valueOf 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Integer 的 valueOf 方法判断变量是否在 <strong>IntegerCache</strong> 的最小值（$-128$）和最大值（$127$）之间，如果在，则返回常量池中的内容，否则 new 一个 Integer 对象。而 IntegerCache 是 Integer的静态内部类，作用就是将 $[-128,127]$ 之间的数”缓存”在 IntegerCache 类的 cache 数组中(这个 Integer 数组包含 $-128$ 到 $127$ 之间的所有值)，valueOf 方法就是调用常量池的 cache 数组，将 i3、i4 变量的引用指向常量池中，没有真正的创建对象。</p><p>而 <code>i5 == i6</code> 为 false，就是因为 $150$ 不在 Integer 常量池的最大最小值之间 $[-128,127]$，从而 new 了一个对象。</p><p>IntegerCache 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;<span class="comment">//最小值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;<span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];<span class="comment">//缓存数组</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//私有化构造方法，不让别人创建它。单例模式的思想</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//类加载的时候，执行静态代码块。作用是将-128到127之间的数缓冲在cache[]数组中</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];<span class="comment">//初始化cache数组，根据最大最小值确定</span></span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)<span class="comment">//遍历将数据放入cache数组中</span></span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一段<strong>拆箱</strong>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Integer i1 = <span class="keyword">new</span> Integer(<span class="number">4</span>);</span><br><span class="line">       Integer i2 = <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">       Integer i3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">       System.out.print(i3 == i1+i2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于 i1 和 i2 是 Integer 对象，是不能使用+运算符的。首先 i1 和 i2 进行自动拆箱操作，拆箱成int后再进行数值加法运算。i3 也是拆箱后再与之比较数值是否相等的。所以 <code>i3 == i1+i2</code> 其实是比较的 int 型数值是否相等，所以为 true。</p><ul><li>String 常量池</li></ul><p>String 是由 final 修饰的类，是不可以被继承的。通常有两种方式来创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则直接将 str 引用指向常量池中的“abcd”。</span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p>对于 String 类，equals 方法用于比较字符串内容是否相同；== 号用于比较内存地址是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       String str2 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在栈上存放变量引用 str1，然后通过符号引用去常量池中找是否有 abcd，没有，则将 abcd 存储在常量池中，然后将 str1 指向常量池的 abcd。创建 str2 对象时，在常量池中发现已经有 abcd 了，就将 str2 引用直接指向 abcd 。所以 <code>str1 == str2</code>，指向同一个内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str1 和 str2 使用 new 创建对象，两个引用指向堆中两个不同的对象，所以为 false。</p><blockquote><p>关于字符串 + 号连接问题</p></blockquote><p>对于字符串<strong>常量</strong>的 + 号连接，在程序编译期，JVM就会将其优化为 + 号连接后的值。所以在编译期其字符串常量的值就确定了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a1&quot;</span>;   </span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;   </span><br><span class="line">System.out.println((a == b)); <span class="comment">//result = true</span></span><br></pre></td></tr></table></figure><p>对于字符串<strong>引用</strong>的 + 号连接问题，由于字符串引用在编译期是无法确定下来的，在程序的运行期动态分配并创建新的地址存储对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    System.out.print(str2 == str3);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 jad 反编译工具反编译代码后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s2 = (<span class="keyword">new</span> StringBuilder()).append(s).append(<span class="string">&quot;b&quot;</span>).toString();</span><br><span class="line">        System.out.print(s1 = s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 new 了一个 StringBuilder 对象，然后使用 append 方法优化了 + 操作符。new 在堆上创建对象，而 <code>String s1=“ab”</code> 则是在常量池中创建对象，两个应用所指向的内存地址是不同的，所以 <code>s1 == s2</code> 结果为 false。</p><p><strong>在 for 循环中操作字符串的优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用+号连接字符串，每循环一次，就会新建StringBuilder对象，append后就“抛弃”了它。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果在循环外创建StringBuilder对象，在循环中使用append方法追加字符串，可以节省 n-1 次创建和销毁对象的时间。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>使用 final 修饰的字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        System.out.print(str2 == str3);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final 修饰的变量是一个常量，编译期就能确定其值，所以 <code>str1 + &quot;b&quot;</code> 就等同于 “a” + “b”，结果是 true。</p><p><strong>String 对象的 intern 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3.intern() == s);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s3 调用 intern 方法，返回的是s3的内容 “ab” 在常量池中的地址值。所以 <code>s3.intern() == s</code> 结果为 true。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运行时数据区&quot;&gt;&lt;a href=&quot;#运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区&quot;&gt;&lt;/a&gt;运行时数据区&lt;/h1&gt;&lt;p&gt;Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JMM&amp;volatile关键字</title>
    <link href="http://10185102110.github.io/2021/08/08/JMM-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://10185102110.github.io/2021/08/08/JMM-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-08-08T08:55:59.000Z</published>
    <updated>2021-09-14T13:53:20.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-内存模型-JMM"><a href="#Java-内存模型-JMM" class="headerlink" title="Java 内存模型 (JMM)"></a>Java 内存模型 (JMM)</h1><p><img src="1.png.jpg" alt=""></p><p>JMM 规定所有变量都存在主存中，每个线程又有自己的工作内存，可以理解成 CPU 上的高速缓存。所以，线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值同步回主存。</p><p><strong>主内存：</strong>主内存被所有的线程共享，对于一个共享变量，主内存中存储的就是它“本尊”。</p><p><strong>工作内存：</strong>每个线程都有自己的工作内存，对于共享变量来说，工作内存中存储的是它的“副本”。</p><p>在线程执行时，首先会从主存中 read 变量值，再 load 到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p><p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;  <span class="comment">// 假设i初值为0</span></span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span>： load i from 主存    <span class="comment">// i = 0</span></span><br><span class="line">        i + <span class="number">1</span>             <span class="comment">// i = 1</span></span><br><span class="line">线程<span class="number">2</span>： load i from主存     <span class="comment">// 因为线程1还没将i的值写回主存，所以i还是0</span></span><br><span class="line">        i + <span class="number">1</span>            <span class="comment">//i = 1</span></span><br><span class="line">线程<span class="number">1</span>:  save i to 主存</span><br><span class="line">线程<span class="number">2</span>： save i to 主存</span><br></pre></td></tr></table></figure><p>如果两个线程按照上面的执行流程，那么 i 最后的值居然是 $1$。如果最后的写回生效的慢，再读取 i 的值，都可能是 $0$，这就是缓存不一致问题。</p><p>JMM 主要就是围绕着如何在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这 $3$ 个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而 volatile 跟可见性和有序性都有关。</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>Java 中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要么做完，要么就没有执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">2</span>; <span class="comment">// 读取操作，是原子的</span></span><br><span class="line">j = i; <span class="comment">// 先读取i的值，再赋值给j，不是原子的</span></span><br><span class="line">i++;   <span class="comment">// 读取i的值，定义常量1，i加1，写回内存，不是原子的</span></span><br><span class="line">i = i + <span class="number">1</span>; <span class="comment">// 等效于i++</span></span><br></pre></td></tr></table></figure><p>JMM 只实现了基本的原子性，像上面 i++ 那样的操作，必须借助于 synchronized 和 Lock 来保证整块代码的原子性。线程在释放锁之前，必然会把 i 的值刷回到主存的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>一个线程修改共享变量，能够被其它线程同时感知。</p><p>Java 利用 volatile 来提供可见性。 当一个变量被 volatile 修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。其实通过 synchronized 和 Lock 也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是 synchronized 和 Lock 的开销都更大。 </p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>JMM 是允许编译器和处理器对指令重排序的，但是规定了 as-if-serial 语义，即不管怎么重排序，程序的执行结果不能改变。</p><p>比如下面的程序段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1</span>;        <span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> s= pi * r * r;<span class="comment">//C</span></span><br></pre></td></tr></table></figure><p>上面的语句，可以按照 A-&gt;B-&gt;C 执行，也可以按照 B-&gt;A-&gt;C 的顺序执行，因为 A、B 是两句独立的语句，而 C 则依赖于 A、B，所以 A、B 可以重排序，但是 C 却不能排到 A、B 的前面。JMM 保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">bool flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程 $1$ 先执行 write，随后线程 $2$ 再执行multiply，最后 ret 的值一定是 $4$ 吗？</p><p><img src="2.png.jpg" alt=""></p><p>如图所示，write 方法里的 $1$ 和 $2$ 做了重排序，线程 $1$ 先对 flag 赋值为 true，随后执行到线程 $2$，ret 直接计算出结果，再到线程 $1$，这时候 a 才赋值为 $2$。这时候可以为 flag 加上 volatile 关键字，禁止重排序，可以确保程序的<strong>有序性</strong>，也可以上重量级的 synchronized 和 Lock 来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p><h1 id="volatile-关键字如何满足并发编程的三大特性？"><a href="#volatile-关键字如何满足并发编程的三大特性？" class="headerlink" title="volatile 关键字如何满足并发编程的三大特性？"></a>volatile 关键字如何满足并发编程的三大特性？</h1><p>volatile 之所以能有这样的特性，得益于 Java 当中的先行发生原则。</p><p><strong>先行发生原则</strong>（happens-before）：如果一个事件必须发生在另一个事件之前，结果必须反映，即使这些事件是乱序执行的。这里的事件指的是各种指令操作，比如读写、初始化、锁。</p><p><code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code> 定义了如下 happens-before 规则：</p><ul><li><p>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</p></li><li><p>监视器锁规则：对一个线程的解锁，happens-before 于随后对这个线程的加锁。</p></li><li><p>volatile 变量规则： 对一个 volatile 域的写，happens-before 于后续对这个 volatile 域的读。</p></li><li><p>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C。</p></li><li><p>start() 规则： 如果线程 A 执行操作 ThreadB_start()(启动线程B) , 那么 A 线程的 ThreadB_start() happens-before 于 B 中的任意操作。</p></li><li><p>join()原则：如果 A 执行 ThreadB.join() 并且成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。</p></li><li><p>interrupt() 原则： 对线程 interrupt() 方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测是否有中断发生。</p></li><li><p>finalize() 原则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始。</p></li></ul><p>$(1)$ 规定线程每次修改变量副本后<strong>立刻同步到主内存</strong>中，用于保证其它线程可以看到自己对变量的修改。</p><p>$(2)$ 规定线程每次使用变量前，先从主内存中<strong>刷新最新的值</strong>到工作内存，用于保证能看见其它线程对变量修改的最新值。</p><p>$(3)$ 为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来<strong>防止指令重排序</strong>。</p><blockquote><p>总结 volatile 的两个特性</p></blockquote><ul><li>保证变量在线程之间的可见性，不能保证原子性。</li><li>阻止编译和运行时的指令重排，保证有序性。</li></ul><h1 id="volatile-底层实现机制"><a href="#volatile-底层实现机制" class="headerlink" title="volatile 底层实现机制"></a>volatile 底层实现机制</h1><p>生成汇编代码可以发现 volatile 关键字的代码多出一个 lock 前缀指令，它相当于一个内存屏障。</p><p>内存屏障提供了以下功能： </p><ul><li>重排序时不能把后面的指令重排序到内存屏障之前的位置 。</li><li>写入动作会引起别的 CPU 或者别的内核无效化其 Cache，相当于让新写入的值对别的线程可见。</li><li>使得本 CPU 的 Cache 写入内存。</li></ul><h1 id="volatile-和-synchronized-区别"><a href="#volatile-和-synchronized-区别" class="headerlink" title="volatile 和 synchronized 区别"></a>volatile 和 synchronized 区别</h1><ul><li>关键字 volatile 是线程同步的轻量级实现，所以 volatile 性能肯定比 synchronized 要好，并且只能修改变量，而 synchronized 可以修饰方法，以及代码块。</li><li>多线程访问 volatile 不会发生阻塞，而 synchronized 会出现阻塞</li><li>volatile 能保证数据的可见性，但不能保证原子性；而 synchronized 可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步</li><li>关键字 volatile 解决的下变量在多线程之间的可见性；而 synchronized 解决的是多线程之间资源同步问题</li></ul><h1 id="volatile-的应用"><a href="#volatile-的应用" class="headerlink" title="volatile 的应用"></a>volatile 的应用</h1><p><strong>(1)</strong> 状态量标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> bool flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种对变量的读写操作，标记为 volatile 可以保证修改对线程立刻可见。比 synchronized,Lock 有一定的效率提升。</p><p><strong>(2)</strong> 单例模式，双重检查锁定(DCL)</p><ul><li><p>经典的懒汉式单例实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程的情况下，多个线程有可能会同时进入 <code>if (singleton == null)</code> ，执行了多次 <code>singleton = new Singleton()</code>，从而破坏单例。</p></li><li><p>允许指令重排序的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在检测到 <code>singleton==null</code> 后，会在同步块中再次判断，可以保证同一时间只有一个线程可以初始化单例。但仍然存在问题，原因就是 Java 中 <code>singleton = new Singleton()</code> 语句并不是一个原子指令，而是由三步组成：</p><ol><li>为对象分配内存</li><li>初始化对象</li><li>将对象的内存地址赋给引用</li></ol><p>但是经过<strong>指令重排序</strong>后，会变成：</p><ol><li>为对象分配内存</li><li>将对象的内存地址赋给引用（会使得 <code>singleton != null</code>）</li><li>初始化对象</li></ol><p>所以存在一种情况，当线程 A 已经将内存地址赋给引用时，但实例对象并没有完全初始化，同时线程 B 判断 singleton 已经不为 null，就会导致 B 线程<strong>访问到未初始化的变量</strong>从而产生错误。</p></li><li><p>避免初始化指令重排序的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码对 singleton 变量添加了 volatile 修饰，可以阻止局部指令重排序。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-内存模型-JMM&quot;&gt;&lt;a href=&quot;#Java-内存模型-JMM&quot; class=&quot;headerlink&quot; title=&quot;Java 内存模型 (JMM)&quot;&gt;&lt;/a&gt;Java 内存模型 (JMM)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;1.png.jpg&quot; a</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池&amp;Executor框架</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%E6%A1%86%E6%9E%B6/</id>
    <published>2021-08-08T08:55:31.000Z</published>
    <updated>2021-08-31T10:24:39.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Executor-框架基础"><a href="#Executor-框架基础" class="headerlink" title="Executor 框架基础"></a>Executor 框架基础</h1><blockquote><p>为什么需要线程池？</p></blockquote><p>在 Java中，使用线程来执行异步任务时，线程的创建和销毁需要一定的开销，如果我们为每一个任务创建一个新的线程来执行的话，那么这些线程的创建与销毁将消耗大量的计算资源，这样的方式可能会使处于高负荷状态的应用最终崩溃。</p><p>我们将在线程池中创建若干条线程，当有任务需要执行时就从该线程池中获取一条线程来执行任务，如果一时间任务过多，超出线程池的线程数量，那么后面的线程任务就进入一个等待队列进行等待，直到线程池有线程处于空闲时才从等待队列获取要执行的任务进行处理，这样就大大减少了线程创建和销毁的开销。</p><h2 id="两级调度模型"><a href="#两级调度模型" class="headerlink" title="两级调度模型"></a>两级调度模型</h2><p>在 Java 线程启动时会创建一个本地操作系统线程，当该 Java 线程终止时，这个操作系统线程也会被回收。而每一个 Java 线程都会被一对一映射为本地操作系统的线程，操作系统会调度所有的线程并将它们分配给可用的 CPU。</p><p>在上层，Java 多线程程序把应用分为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这种两级调度模型如下图所示：</p><p><img src="20160314222941341.png" alt=""></p><p>应用程序通过 Executor 框架控制上层的调度，而下层的调度由操作系统内核控制。</p><h2 id="Executor-框架的结构"><a href="#Executor-框架的结构" class="headerlink" title="Executor 框架的结构"></a>Executor 框架的结构</h2><p>Executor 框架的结构主要包括三部分：</p><ul><li>任务：包括被执行任务需要实现的接口：Runnable 接口或 Callable 接口。</li><li>任务的执行：包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 EexcutorService 接口。Executor 的两个关键类实现了 ExecutorService 接口（ThreadPoolExecutor 和ScheduledThreadPoolExecutor）。</li><li>异步计算的结果：包括接口 Future 和实现 Future 接口的 FutureTask 类。</li></ul><p><img src="20160314223043311.png" alt=""></p><p>Extecutor 是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来。<br>ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。<br>ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<br>Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果。<br>Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或者 ScheduledThreadPoolExecutor 执行。区别就是 Runnable 无法返回执行结果，而 Callable 可以返回执行结果。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor 是线程的真正实现，通常使用工厂类 Executors 来创建，但它的构造方法提供了一系列参数来配置线程池.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>corePoolSize</strong>：线程池的核心线程数，默认核心线程会一直在线程池中存活，即使它们处理闲置状态。</p><p><strong>maximumPoolSize</strong>：线程池所能容纳的最大线程数量，当活动线程数到达该数值后，后续的新任务将被阻塞。</p><p><strong>keepAliveTime</strong>：非核心线程闲置时的超时时长，超过时长非核心线程就会被回收。当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 true 时，keepAliveTime 同样会作用于核心线程。</p><p><strong>unit</strong>：用于指定 keepAliveTime 参数的时间单位。常用的有 TimeUnit.MILLISECONDS(毫秒)，TimeUnit.SECONDS(秒)以及 TimeUnit.MINUTES(分钟)等。</p><p><strong>workQueue</strong>：线程池中的任务队列，通过线程池的 execute 方法提交的 Runnable 对象会存储在这个队列中。</p><p><strong>threadFactory</strong>：线程工厂，为线程池提供创建新线程的功能。ThreadFactory 是一个接口，它只有一个方法：<code>Thread newThread(Runnable r)</code>。</p><p><strong>defaultHandler</strong>：RejectExecutionHandler，这个参数表示当 ThreadPoolExecutor 已经关闭或者已经饱和时，execute 方法将会调用 Handler 的 rejectExecution 方法来通知调用者，默认情况下是抛出一个RejectExecutionException 异常。</p><p>ThreadPoolExecutor 执行任务时的大致规则：</p><ol><li>如果线程池的数量还未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li><li>如果线程池中的线程数量已经达到或者超出核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li><li>如果在步骤 2 中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li><li>如果在步骤 3 中线程数量已经达到线程池规定的最大值，那么就会拒绝执行此任务， ThreadPoolExecutor 会调用 RejectExecutionHandler 的 rejectExecution方法来通知调用者。</li></ol><h1 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h1><h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><p>FixedThreadPool 模式会使用一个优先固定数目的线程来处理若干数目的任务。</p><p>创建 FixedThreadPool 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p> FixedThreadPool 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>corePoolSize 和 maximumPoolSize 参数都被设置为 nThreads，即核心线程数和最大线程数是一样的。</p><p>keepAliveTime 设置为 $0$L，就说明非核心线程会立即被终止。</p><p>FixedThreadPool 的 execute() 方法的运行流程：</p><p><img src="20160314223220078.png" alt=""></p><ol><li>如果当前运行线程数少 corePoolSize，则创建一个新的线程来执行任务。</li><li>如果当前线程池的运行线程数等于 corePoolSize，那么后面提交的任务将加入 LinkedBlockingQueue。</li><li>线程在执行完图中的 $1$ 后，会在循环中反复从 LinkedBlockingQueue 获取任务来执行。</li><li>FixedThreadPool 使用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列容量为Integer.MAX_VALUE），所以运行中的 FixedThreadPool 不会拒绝任务，那么也不会调用 RejectExecutionHandler 的 rejectExecution 方法抛出异常。</li></ol><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">3</span>;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;  <span class="comment">//线程号 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">my</span><span class="params">()</span> </span>&#123;&#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">my</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#Thread&quot;</span> + id + <span class="string">&quot;(&quot;</span> +   </span><br><span class="line">            (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">&quot;my!&quot;</span>) + <span class="string">&quot;) &quot;</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            System.out.println(status());   </span><br><span class="line">            Thread.yield();   </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;      </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//三个线程来执行五个任务   </span></span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;  </span><br><span class="line">        exec.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#Thread0(<span class="number">2</span>) </span><br><span class="line">#Thread1(<span class="number">2</span>) </span><br><span class="line">#Thread1(<span class="number">1</span>) </span><br><span class="line">#Thread1(my!) </span><br><span class="line">#Thread2(<span class="number">2</span>) </span><br><span class="line">#Thread3(<span class="number">2</span>) </span><br><span class="line">#Thread2(<span class="number">1</span>) </span><br><span class="line">#Thread2(my!) </span><br><span class="line">#Thread3(<span class="number">1</span>) </span><br><span class="line">#Thread0(<span class="number">1</span>) </span><br><span class="line">#Thread3(my!) </span><br><span class="line">#Thread4(<span class="number">2</span>) </span><br><span class="line">#Thread0(my!) </span><br><span class="line">#Thread4(<span class="number">1</span>) </span><br><span class="line">#Thread4(my!) </span><br></pre></td></tr></table></figure><h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><p>CachedThreadPool 首先会按照需要创建足够多的线程来执行任务。随着程序执行的过程，有的线程执行完任务可以被重新循环使用时，才不再创建新的线程。</p><p>创建 CachedThreadPool 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool=Executors.newCachedThreadPool(); </span><br></pre></td></tr></table></figure><p>CachedThreadPool 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool 的 corePoolSize 被设置为 $0$，而 maximumPoolSize 被设置 Integer.MAX_VALUE，即 maximumPoolSize 是无界的，而 keepAliveTime 被设置为 60L，单位为秒。也就是空闲线程等待时间最长为 $60$ 秒，超过该时间将会被终止。CachedThreadPool 使用的是没有容量的 SynchronousQueue 作为线程池的工作队列，但其 maximumPoolSize 是无界的，也就是意味着如果主线程提交任务的速度高于 maximumPoolSize 中线程处理任务的速度时 CachedThreadPool 将会不断的创建新的线程，在极端情况下， CachedThreadPool 会因为创建过多线程而耗尽 CPU 和内存资源。<br>CachedThreadPool 的 execute() 方法的运行流程：</p><p><img src="20160314223430065.png" alt=""></p><ol><li>首先执行 SynchronousQueue.offer(Runnable task)，添加一个任务。如果当前 CachedThreadPool 中有空闲线程正在执行 SynchronousQueue.poll，那么主线程执行 offer 操作与空闲线程执行 poll 操作配对成功，主线程把任务交给空闲线程执行，execute() 方法执行完成，否则进入第 2 步。</li><li>当 CachedThreadPool 初始线程数为空时，或者当前没有空闲线程，CachedThreadPool 会创建一个新的线程来执行任务， execute() 方法执行完成。</li><li>在步骤 2 中创建的新线程将任务执行完成后，会执行 SynchronousQueue.poll，这个 poll 操作会让空闲线程最多在 SynchronousQueue 中等待 $60$ 秒，如果 $60$ 秒内主线程提交了一个新任务，那么这个空闲线程将会执行主线程提交的新任务，否则，这个空闲线程将被终止。因此长时间保持空闲的 CachedThreadPool 是不会使用任何资源的。</li></ol><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;   </span><br><span class="line">        exec.shutdown();       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h2><p>SingleThreadExecutor 模式只会创建一个线程。如果多个任务被提交给 SingleThreadExecutor，那么这些任务会被保存在一个队列中，并且会按照任务提交的顺序，一个先执行完成再执行另外一个线程。这种特点可以用来处理共享资源的问题而不需要考虑同步问题。</p><p>创建 SingleThreadExecutor 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor(); </span><br></pre></td></tr></table></figure><p>SingleThreadExecutor 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从静态方法可以看出 SingleThreadExecutor 的 corePoolSize 和 maximumPoolSize 被设置为 $1$，其他参数则与 FixedThreadPool 相同。</p><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>FixedThreadPool：适合为了满足资源管理需求，而需要限制当前线程的数量的应用场景，它适用于负载比较重的服务器。</p><p>CachedThreadPool：大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。SingleThreadExecutor：适用于需要保证执行顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的场景。</p><h1 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h1><h2 id="ScheduledThreadPoolExecutor-运行机制"><a href="#ScheduledThreadPoolExecutor-运行机制" class="headerlink" title="ScheduledThreadPoolExecutor 运行机制"></a>ScheduledThreadPoolExecutor 运行机制</h2><p>ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor。它主要用来在给定的延迟之后执行任务，或者定期执行任务。ScheduledThreadPoolExecutor 的功能与 Timer 类似，但比 Timer 更强大，更灵活，Timer 对应的是单个后台线程，而 ScheduledThreadPoolExecutor 可以在构造函数中指定多个对应的后台线程数。</p><p>ScheduledThreadPoolExecutor 的运行机制：</p><p><img src="20160314223650662.png" alt=""></p><ol><li>当调用 ScheduledThreadPoolExecutor 的 <code>scheduleAtFixedRate()</code>方法或者 <code>scheduleWithFixedDelay()</code> 方法时，会向 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduleFutureTask。DelayQueue 是一个无界队列。</li><li>线程池中的线程从 DelayQueue 中获取 ScheduleFutureTask，然后执行任务。</li></ol><h2 id="ScheduledThreadPoolExecutor-的创建"><a href="#ScheduledThreadPoolExecutor-的创建" class="headerlink" title="ScheduledThreadPoolExecutor 的创建"></a>ScheduledThreadPoolExecutor 的创建</h2><p>Executors 可以创建两种类型的 ScheduledThreadPoolExecutor。</p><ul><li><p>ScheduledThreadPoolExecutor：可以执行多线程任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPoolExecutor=Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>SingleThreadScheduledExecutor：可以执行单条线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService singleThreadScheduledExecutor=Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure></li></ul><h2 id="ScheduledThreadPoolExecutor-案例"><a href="#ScheduledThreadPoolExecutor-案例" class="headerlink" title="ScheduledThreadPoolExecutor 案例"></a>ScheduledThreadPoolExecutor 案例</h2><p>首先创建一个 Runnable 对象，然后使用 ScheduledThreadPoolExecutor 的 Scheduled() 来执行延迟任务，输出执行时间。</p><p><strong>$(1)$ 延迟执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure><p><strong>command</strong>：一个实现 Runnable 接口的类。</p><p><strong>delay</strong>：延迟时间。</p><p><strong>unit</strong>： 用于指定 keepAliveTime 参数的时间单位。</p><p>这个方法会返回 ScheduledFuture 实例，用于获取线程状态信息和延迟时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Start. Time = &quot;</span>+getNowDate());</span><br><span class="line">     threadSleep();</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot; End. Time = &quot;</span>+getNowDate());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sleep 3秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadSleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNowDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line">  SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">  String ctime = formatter.format(currentTime); </span><br><span class="line">  <span class="keyword">return</span> ctime;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Current Time = &quot;</span>+getNowDate());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            my worker = <span class="keyword">new</span> my();</span><br><span class="line">            <span class="comment">//延迟10秒后执行</span></span><br><span class="line">            scheduledThreadPool.schedule(worker, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    scheduledThreadPool.shutdown();</span><br><span class="line">    <span class="keyword">while</span>(!scheduledThreadPool.isTerminated())&#123;</span><br><span class="line">        <span class="comment">//wait for all tasks to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNowDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line">  SimpleDateFormat formatter; </span><br><span class="line">    formatter = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">    String ctime = formatter.format(currentTime); </span><br><span class="line">  <span class="keyword">return</span> ctime;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Current Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">10</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">21</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">22</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">23</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">24</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">25</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">26</span></span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><p>线程任务确实在 $10$ 秒延迟后才开始执行，这就是 schedule() 方法的使用。</p><p><strong>$(2)$ 周期性执行</strong></p><ul><li><p>scheduleAtFixedRate 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit)</span><br></pre></td></tr></table></figure><p>scheduleAtFixedRate 方法的作用是预定在初始的延迟结束后，周期性地执行给定的任务，周期长度为 period，其中 initialDelay 为初始延迟。</p></li><li><p>scheduleWithFixedDelay 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> delay,TimeUnit unit);</span><br></pre></td></tr></table></figure><p>scheduleWithFixedDelay 方法的作用是预定在初始的延迟结束后周期性地执行给定任务，在一次调用完成和下一次调用开始之间有长度为 delay 的延迟， 其中 initialDelay 为初始延迟。</p></li></ul><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> ScheduledThreadPoolExecutor se = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ScheduledTask();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedPeriodSchedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设定可以循环执行的runnable,初始延迟为0，这里设置的任务的间隔为5秒</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">se.scheduleAtFixedRate(<span class="keyword">new</span> FixedSchedule(), <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fixedPeriodSchedule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSchedule</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  当前时间：&quot;</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-1  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-1  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Executor-框架基础&quot;&gt;&lt;a href=&quot;#Executor-框架基础&quot; class=&quot;headerlink&quot; title=&quot;Executor 框架基础&quot;&gt;&lt;/a&gt;Executor 框架基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为什么需要线程池？&lt;/p&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程安全</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2021-08-08T08:51:52.000Z</published>
    <updated>2021-08-28T04:48:05.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全等级"><a href="#线程安全等级" class="headerlink" title="线程安全等级"></a>线程安全等级</h1><p>根据线程的安全程度由强到弱，可以分为 $5$ 个等级。</p><ul><li><p>不可变</p><p>在 Java 中，不可变对象一定是线程安全的，比如 final 关键字修饰的数据不可修改，比如 String、Long、Integer。</p></li><li><p>绝对的线程安全</p><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。如 Random 、ConcurrentHashMap、Concurrent 集合、atomic。</p></li><li><p>相对的线程安全</p><p>通常来说线程是安全的，但对于一些特定顺序的连续调用就可能需要在调用端使用额外的同步手段来保证调用的正确性。大部分线程都属于这种类型，如 vector。</p></li><li><p>线程兼容</p><p>对象本身不提供线程安全机制，但是通过外部同步，可以在并发环境使用， 如 ArrayList、HashMap。</p><p>在使用这些对象的时候，都要考虑是否会发生线程安全问题。</p></li><li><p>线程对立</p><p>无论是否采用同步措施，都无法在并发中使用。</p></li></ul><h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><p><img src="20180315101631748.jpg" alt=""></p><h2 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h2><p>同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。</p><h3 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h3><p>互斥是实现同步的一种手段，比如临界区、互斥量和信号量。</p><p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字。synchronized 是独占锁，可重入，加锁和解锁的过程自动进行，不必担心最后是否释放锁，易于操作，但不够灵活。synchronized 不可响应中断，一个线程获取不到锁就一直等着。</p><p>ReentrantLock 也是通过互斥来实现同步。ReentrantLock 也是独占锁，也可重入，加锁和解锁的过程需要手动进行，且次数需一样，否则其他线程无法获得锁，不易操作，但非常灵活。ReentrantLock 可以响应中断，可以实现公平锁机制(在锁上等待时间最长的线程将获得锁的使用权)。</p><p>ReentrantLock 的简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; test(),<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; test(),<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A获取锁</span><br><span class="line">线程A释放锁</span><br><span class="line">线程B获取锁</span><br><span class="line">线程B释放锁</span><br></pre></td></tr></table></figure><p>互斥同步最主要的问题就是进行<strong>线程阻塞和唤醒</strong>所带来的性能问题，因此这种同步也成为阻塞同步。</p><p>互斥同步属于一种<strong>悲观的并发策略</strong>，无论共享数据是否真的会出现竞争，它都要进行加锁。</p><h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><p><strong>CAS</strong>：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，是一种<strong>乐观的并发策略</strong>。</p><p>CAS 是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换。</p><p>CAS机制当中使用了3个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。</p><p>举个例子：</p><p>在内存地址 $V$ 中，存储着值为 $10$ 的变量。此时线程 $1$ 想把变量的值 $+1$，对线程 $1$ 来说，旧的预期值 $A=10$ ，要修改的新值 $B=11$。在线程 $1$ 要提交更新之前，线程 $2$ 抢先一步，把内存地址 $V$ 中的变量值更新成 $11$。线程 $1$ 开始提交更新，发现 $A$ 不等于 $V$ 的实际值，提交失败。线程 $1$ 重新获取内存地址 $V$ 的当前值，并重新计算想要修改的新值。此时对线程 $1$ 来说，$A=11$，$B=12$，这个重新尝试的过程被称为自旋。这次比较幸运，没有其他线程改变地址 $V$ 的值。线程 $1$ 进行 Compare，发现 $A$ 和地址 $V$ 的实际值是相等的。线程 $1$ 进行 SWAP，把地址 $V$ 的值替换为 $B$，也就是 $12$。</p><p><strong>Atomic</strong> 包下的原子类是基于 CAS 实现的。原子操作类，指的是 java.util.concurrent.atomic 包下，一系列以 Atomic 开头的包装类。例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>。它们分别用于<code>Boolean</code>，<code>Integer</code>，<code>Long</code>类型的原子性操作。</p><p>下面是一个无阻塞多线程争抢资源的模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyType my = <span class="keyword">new</span> MyType();</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  flag:&quot;</span>+flag.get());</span><br><span class="line">        <span class="keyword">if</span> (flag.compareAndSet(<span class="keyword">true</span>,<span class="keyword">false</span>))&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始操作并使flag为&quot;</span>+flag.get());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            flag.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重试机制:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  flag:&quot;</span>+flag.get());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">0</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">0</span>开始操作并使flag为<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">1</span>开始操作并使flag为<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p><code>compareAndSet(true,false)</code> 方法要拆成 compare(true) 方法和 Set(false) 方法理解，是 compare(true) 等于 true 后，就马上设置共享内存为 false。</p><p>CAS 的缺点：</p><ol><li>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给 CPU 带来很大的压力。</li><li>CAS 机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 $3$ 个变量共同进行原子性的更新，就不得不使用 Synchronized 了。</li><li>无法解决 ABA 问题。ABA 就是一个值由 A 变为 B，再由 B 变为 A，使用 CAS 操作无法感知到该种情况下出现的变化，带来的后果很严重，比如银行内部员工，从系统挪走一百万，之后还了回来，系统却感知不到。</li></ol><p>解决 ABA 可以使每一次修改都带上时间戳，以记录版本号的形式使得 CAS 感知到这种狸猫换太子的操作。Java 提供了 AtomicStampedReference 类来解决，该类除了指定旧值与期盼值，还要指定旧的版本号与期盼的版本号。该类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>如果一个方法不涉及共享数据，那它自然不需要任何同步操作去保证正确性，因此有一些代码天生就是线程安全的。</p><h3 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h3><p>可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>如果一段代码中所需的数据必须与其他代码共享，那就看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的<strong>可见范围</strong>限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。</p><p>如“生产者-消费者”模式、Web交互模型中的“一个请求对应一个服务器线程“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程安全等级&quot;&gt;&lt;a href=&quot;#线程安全等级&quot; class=&quot;headerlink&quot; title=&quot;线程安全等级&quot;&gt;&lt;/a&gt;线程安全等级&lt;/h1&gt;&lt;p&gt;根据线程的安全程度由强到弱，可以分为 $5$ 个等级。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不可变&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-08T08:51:27.000Z</published>
    <updated>2021-08-28T04:47:37.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程，线程，多线程"><a href="#进程，线程，多线程" class="headerlink" title="进程，线程，多线程"></a>进程，线程，多线程</h1><ul><li>进程是资源分配的最小单位，有自己独立的地址空间，一个进程可以创建多个线程。</li><li>线程是程序执行和CPU调度的最小单位，线程共享本进程的地址空间，分为用户级线程和内核级线程。</li><li>一个进程如果只有一个线程，称为单线程程序；如果有多个线程，称为多线程程序。</li></ul><h1 id="多线程的创建与启动"><a href="#多线程的创建与启动" class="headerlink" title="多线程的创建与启动"></a>多线程的创建与启动</h1><p>创建多线程有两种方法，一种是继承Thread类重写run方法，另一种是实现Runnable接口重写run方法。</p><ul><li><p>继承Thread类重写run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByEx</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I&#x27;m a thread that extends Thread!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I&#x27;m a thread that implements Runnable !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//继承Thread启动的方法</span></span><br><span class="line">ThreadByEx t1=<span class="keyword">new</span> ThreadByEx();</span><br><span class="line">t1.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Runnable启动线程的方法</span></span><br><span class="line">ThreadByRunnable r = <span class="keyword">new</span> ThreadByRunnable();</span><br><span class="line">Thread t2 =<span class="keyword">new</span> Thread(r);</span><br><span class="line">t2.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>start()</code> 方法后并不是是立即的执行多线程的代码，而是使该线程变为可运行态，什么时候运行多线程代码是由操作系统决定的。</p></li></ul><h1 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h1><p>线程的 <code>thread.interrupt()</code> 方法向线程发送中断请求，将会设置该线程的中断状态位，即设置为 <code>true</code>，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为 <code>true</code>）。它并不像 <code>stop</code> 方法那样会中断一个正在运行的线程。(在 Java 早期版本中有一个 <code>stop</code> 方法，其他线程可以调用它终止线程，但是这个方法现在已经被弃用了，因为会造成一些线程不安全的问题)</p><p>判断线程是否被中断：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread.currentThread().isInterrupted()方法不会清除中断标示位，而Thread.interrupted()方法调用后会将中断标示位清除，即重新设置为false来判断。</span></span><br></pre></td></tr></table></figure><p>如果一个线程处于阻塞状态，即线程在检查中断标示时发现中断标示为 <code>true</code>，则会在阻塞方法（<code>sleep</code>、<code>join</code>、<code>wait</code>、1.5 中的 <code>condition.await</code> 及可中断的通道上的 I/O 操作方法）调用处抛出<code>InterruptedException</code> 异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为<code>false</code>。  </p><p>中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断。某些线程非常重要，以至于它们应该不理会中断，而是在处理完抛出的异常之后继续执行。但是更普遍的情况是，一个线程将把中断看作一个终止请求，这种线程的 <code>run()</code> 方法遵循如下形式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">//线程在wait或sleep期间被中断了</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//线程结束前做一些清理工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>try</code> 在 <code>while</code> 循环里时，应该在 <code>catch</code> 块里重新设置一下中断标示，因为抛出 <code>InterruptedException</code> 异常后，中断标示位会自动清除，此时应该这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            sleep(delay); <span class="comment">//Thread.sleep()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();<span class="comment">//重新设置中断标示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层中断异常的处理</strong>，最好是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>Thread.interrupt()</code> 中断非阻塞状态线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example1 thread = <span class="keyword">new</span> Example1();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        <span class="comment">// 发出中断请求</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔一秒检测是否设置了中断标示</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis(); <span class="comment">// 获取系统时钟</span></span><br><span class="line">            <span class="comment">// 使用while循环模拟 sleep</span></span><br><span class="line">            <span class="keyword">while</span> ((System.currentTimeMillis() - time &lt; <span class="number">1000</span>) ) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Starting thread...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Asking thread to stop...</span><br><span class="line">Thread exiting under request...</span><br><span class="line">Stopping application...</span><br></pre></td></tr></table></figure><p><strong>使用信号量中断非阻塞状态的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;<span class="comment">// 线程中断信号量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example2 thread = <span class="keyword">new</span> Example2();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); </span><br><span class="line">        <span class="comment">//sleep()方法阻塞当前进程，如果使用在main线程执行代码中，则阻塞的是main线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置中断信号量</span></span><br><span class="line">        thread.stop = <span class="keyword">true</span>;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔一秒检测一下中断信号量</span></span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 使用while循环模拟 sleep 方法，这里不要使用 sleep，否则在阻塞时会抛</span></span><br><span class="line"><span class="comment">             * InterruptedException异常而退出循环，这样while检测stop条件就不会执行.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> ((System.currentTimeMillis() - time &lt; <span class="number">1000</span>)) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>thread.interrupt()</code> 中断阻塞状态线程</strong></p><p><code>Thread.interrupt()</code> 的作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</p><p>具体来说，当对一个线程，调用 <code>interrupt()</code> 时，</p><ul><li>如果线程处于被阻塞状态（例如处于 sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个 InterruptedException 异常。</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example3 thread = <span class="keyword">new</span> Example3();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        thread.interrupt();<span class="comment">// 等中断信号量设置后再调用</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果线程阻塞，将不会去检查中断信号量stop变量，所以thread.interrupt()</span></span><br><span class="line"><span class="comment">                 * 会使阻塞线程从阻塞的地方抛出异常，让阻塞线程从阻塞状态逃离出来，并</span></span><br><span class="line"><span class="comment">                 * 在异常块进行相应的处理</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">// 线程阻塞，如果线程收到中断操作信号将抛出异常</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread interrupted...&quot;</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果线程在调用 Object.wait()方法，或者该类的 join() 、sleep()方法</span></span><br><span class="line"><span class="comment">                 * 过程中受阻，则其中断状态将被清除</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.isInterrupted());<span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">//中不中断由自己决定，如果需要真中断线程，则需要重新设置中断位，如果</span></span><br><span class="line">                <span class="comment">//不需要，则不用调用</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.isInterrupted());<span class="comment">// true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>interrupt()</code> 方法是不能中断死锁线程的，因为锁定的位置根本无法抛出异常。</p><p><strong>中断I/O操作</strong></p><p>尽管 <code>interrupt()</code> 被调用，线程也不会退出被阻塞状态，比如 ServerSocket的 <code>accept</code> 方法根本不抛出异常。所以需要调用阻塞该线程的套接字的 <code>close()</code> 方法，如果线程被 I/O 操作阻塞，当调用该套接字的 close 方法时，该线程在调用 accept 地方法将接收到一个SocketException (IOException 的子异常）异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> ServerSocket socket;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example4 thread = <span class="keyword">new</span> Example4();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        Thread.currentThread().interrupt();<span class="comment">// 调用interrupt方法</span></span><br><span class="line">        thread.socket.close();<span class="comment">// 再调用close方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not create the socket...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting for connection...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.accept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;accept() failed or interrupted...&quot;</span>);</span><br><span class="line">                Thread.currentThread().interrupt();<span class="comment">//重新设置中断标示位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>守护线程的唯一作用是为其他线程提供服务。计时线程就是一个典型的例子，它定时地发送“计时器滴答”信号告诉其他线程去执行某项任务。当只剩下守护线程时，虚拟机就退出了。另外 JVM 的垃圾回收、内存管理等线程都是守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.test;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@decrition</span> 守护线程代码示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demon</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread deamon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(),<span class="string">&quot;DaemonRunner&quot;</span>);</span><br><span class="line">deamon.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程</span></span><br><span class="line">deamon.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//在命令行打印异常信息在程序中出错的位置及原因</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;finally的代码在java虚拟机退出时不一定会执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 虚拟机退出时 Daemon线程中的 <code>finally</code> 代码块并不一定会执行，因此在构建 Daemon 线程时，不能依靠 <code>finally</code> 代码块中的内容来确保执行关闭或清理资源的逻辑。</p><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p>在 Java 线程中，通过一个整型的成员变量 <code>Priority</code> 来控制线程优先级 ，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以用 <code>setPriority</code> 方法提高或降低任何一个线程优先级。可以将优先级设置在 <code>MIN_PRIORITY</code>（在 Thread 类定义为 1）与 <code>MAX_PRIORITY</code>（在 Thread 类定义为 10）之间的任何值。线程的默认优先级为 <code>NORM_PRIORITY</code>（在 Thread 类定义为 5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序。</p><h1 id="线程的转换关系"><a href="#线程的转换关系" class="headerlink" title="线程的转换关系"></a>线程的转换关系</h1><ul><li><p>新建状态</p><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p></li><li><p>就绪状态</p><p>当线程对象调用了 <strong>start()</strong> 方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。</p></li><li><p>运行状态</p><p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>阻塞状态</p><p>如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态</p><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p></li></ul><p><img src="20160313163538263.png" alt=""></p><p>图中的方法解析：</p><ul><li>Thread.sleep(long)：使当前线程进入阻塞状态，在指定时间内不会执行。 </li><li>Object.wait()：调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁。</li><li>Object.notifyAll()：从对象等待池中唤醒所有等待线程。</li><li>Object.notify()：通知一个在对象上等待的线程，使其从wait()返回，而返回的前提是该线程获取到了对象的锁。wait() 和 notify() 必须在 synchronized 函数或 synchronized 中进行调用。</li><li>Thread.yield()： 暂停当前正在执行的线程对象。</li><li>Thread.Join()：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</li></ul><p><strong>通过 wait()/notify() 实现等待/通知机制的示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A等待获取lock锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A获取了lock锁&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A将要运行lock.wait()方法进行等待&quot;</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A等待结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B等待获取lock锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B获取了lock锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B将要运行lock.notify()方法进行通知&quot;</span>);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程A等待获取lock锁</span><br><span class="line">线程A获取了lock锁</span><br><span class="line">线程B等待获取lock锁</span><br><span class="line">线程A将要运行lock.wait()方法进行等待</span><br><span class="line">线程B获取了lock锁</span><br><span class="line">线程B将要运行lock.notify()方法进行通知</span><br><span class="line">线程A等待结束</span><br></pre></td></tr></table></figure><h1 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h1><p>创建线程的方式有两种，一种是实现 Runnable 接口，另一种是继承 Thread，但是这两种方式都有个缺点，那就是在任务执行完成之后无法获取返回结果。从 JAVA SE 5.0 开始引入 Callable 和 Future，通过它们构建的线程，在任务执行完成后就可以获取执行结果。</p><p>线程创建的第三种方式就是实现 Callable 接口。</p><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable<V>接口</h2><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">      <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>该接口声明了一个 call() 方法，这个方法有返回值 V，也可以抛出异常。</p><p>无论是 Runnable 接口的实现类还是 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行，ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 都实现了  ExcutorService 接口，因此 Callable 需要和 Executor 框架中的 ExcutorService 结合使用。</p><p>ExecutorService 提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且指定了调用Future的get方法时返回的result对象</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p>除了自己实现 Callable 对象外，还可以使用工厂类 Executors 把一个 Runnable 对象包装成 Callable 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future<V>接口</h2><p>Future<V>接口是用来获取异步计算结果的，其实就是对 Runnable 或者 Callable 对象任务执行的结果进行获取 get()，取消 cancel()，判断是否完成 isDone() 等操作。</p><p>Future 接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法解析</p><ul><li><strong>V get()</strong> ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</li><li><strong>V get</strong>(Long timeout , TimeUnit unit) ：同上，但是有时间限制，如果阻塞时间超过设定的 timeout 时间，该方法将抛出异常。</li><li><strong>boolean isDone()</strong> ：如果任务执行结束，无论是正常结束或中途取消还是发生异常，都返回 true。</li><li><strong>boolean isCanceller()</strong> ：如果任务完成前被取消，则返回 true。</li><li><strong>boolean cancel</strong>(boolean mayInterruptRunning) ：如果任务还没开始，执行 cancel(…) 方法将返回 false；如果任务已经启动，执行 cancel(true) 方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回 true；当任务已经启动，执行 cancel(false) 方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回 false；当任务已经完成，执行cancel(…)方法将返回 false。</li></ul><h2 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h2><p>Future 只是一个接口，无法直接创建对象，因此需要其实现类 FutureTask。</p><p>FutureTask 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure><p>FutureTask 类实现了 RunnableFuture 接口，那么 RunnableFuture 接口的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 的两种构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 可以直接提交给 Executor 执行，也可以调用线程直接执行 <code>FutureTask.run()</code>。</p><p>FutureTask 的方法执行示意图：</p><p><img src="20160315150014001.png" alt=""></p><p>当 FutureTask 处于未启动或已启动状态时，如果此时执行 FutureTask.get() 方法将导致调用线程阻塞；当 FutureTask 处于已完成状态时，执行 FutureTask.get() 方法将导致调用线程立即返回结果或者抛出异常。</p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><ul><li><p>使用 Callable+Future 获取执行结果</p><p>Callable 实现类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable线程开始计算&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">sum=sum+i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable线程计算结束&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>submit</strong> 提交 Callable 任务，调用的是 execute(Runnable command) 方法，execute 执行 FutureTask 对象中的 run 方法，在 run 方法中调用 callable 中的 call 方法。总结一下，首先创建一个实现 Future 和 Runnable 的 FutureTask 对象并且把 Callable 对象通过构造函数注入到对象中，然后把 FutureTask 对象传入 execute 方法中，之后直接返回FutureTask对象。execute 方法执行完会把执行结果放入 FutureTask 对象，我们从对象中获得返回值。</p><p>Callable 执行测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建Callable对象任务</span></span><br><span class="line">my calTask=<span class="keyword">new</span> my();</span><br><span class="line"><span class="comment">//提交任务并获取执行结果</span></span><br><span class="line">Future&lt;Integer&gt; future =es.submit(calTask);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">es.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程在执行其他任务&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(future.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;future.get()--&gt;&quot;</span>+future.get());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;future.get()未获取到结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable线程开始计算</span><br><span class="line">主线程在执行其他任务</span><br><span class="line">Callable线程计算结束</span><br><span class="line">futureTask.get()--&gt;12497500</span><br><span class="line">主线程执行完成</span><br></pre></td></tr></table></figure></li><li><p>使用 Callable+FutureTask 获取执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建Callable对象任务</span></span><br><span class="line">my calTask=<span class="keyword">new</span> my();</span><br><span class="line"><span class="comment">//创建FutureTask</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(calTask);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">es.submit(futureTask);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">es.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程在执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;futureTask.get()--&gt;&quot;</span>+futureTask.get());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;futureTask.get()未获取到结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程，线程，多线程&quot;&gt;&lt;a href=&quot;#进程，线程，多线程&quot; class=&quot;headerlink&quot; title=&quot;进程，线程，多线程&quot;&gt;&lt;/a&gt;进程，线程，多线程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;进程是资源分配的最小单位，有自己独立的地址空间，一个进程可以创建多个线程</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E5%AE%B9%E5%99%A8/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2021-08-08T08:50:56.000Z</published>
    <updated>2021-08-28T04:47:56.965Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>容器主要包括 Collection 和 Map 两种。</p><p>Collection：存放独立元素的序列。</p><p>Map：存放key-value型的元素对。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Collection 接口包含 List、Set 以及 Queue 子接口。</p><p><img src="20190801230729141.png" alt=""></p><p><strong>Collection 和 Collections 有什么区别？</strong></p><p>Collection 是一个接口，它是 Set、List 等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>存储的元素是无序的，不可重复的。</p><ul><li><p>HashSet：基于哈希实现，支持快速查找，但它不保证元素的迭代顺序。</p></li><li><p>TreeSet：基于红黑树实现，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logN)；</p></li><li><p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。</p></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>存储的元素是有序的，可重复的。</p><ul><li><p>ArrayList：基于动态数组实现，随机访问的效率较高；</p></li><li><p>Vector：和 ArrayList 类似，每次扩容为 $2$ 倍空间，性能不如 ArrayList，但它用了 Synchronized 来实现线程同步。</p></li><li><p>LinkedList：基于双向循环链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。此外，LinkedList 还可以用作栈、队列和双端队列。</p></li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul><li><p>LinkedList：可以用它来支持双向队列；</p></li><li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先级队列。</p></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="20190801232854703.png" alt=""></p><ul><li><p>HashMap：基于哈希实现；</p></li><li><p>HashTable：和 HashMap 类似，但它是线程安全的，现在已被淘汰。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p></li><li><p>LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p></li><li><p>TreeMap：基于红黑树实现。</p></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p><img src="Iterator-1.jpg" alt=""></p><p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p><p>Iterator 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的用法：</p><ol><li>使用方法 iterator() 要求容器返回一个 Iterator。第一次调用 Iterator 的 next() 方法时返回序列的第一个元素。</li><li>使用 next() 获得序列中的下一个元素。　</li><li>使用 hasNext() 检查序列中是否还有元素。　　</li><li>使用 remove() 将迭代器新返回的元素删除。　</li></ol><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>使用 <code>Arrays.asList()</code> 方法可以很方便地将数据转换为集合，但是转换后的集合不能使用修改的相关操作（add，remove，clear）等。</p><p><code>Arrays.asList()</code> 是泛型方法，传入的对象必须是对象数组。因此不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a); <span class="comment">//直接创建了一个ArrayList</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList(E[] array) &#123;</span><br><span class="line">     a = Objects.requireNonNull(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只是简单判断一下数组是否为null，如果不为null，就将array的地址赋值给a</span></span><br></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 将数组转换为集合后，底层其实还是数组。因此如果更改子列表的值，原数组也会发生变化。当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身，此时 List 的唯一元素就是这个数组。将 int 改成 Integer 就可以正常遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><h1 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>实现了 RandomAccess 接口，因此支持随机访问。</p><p>基于数组实现，ArrayList 具有动态扩容特性。</p><p>数组的默认大小为 $10$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>删除元素时需要调用 <code>System.arraycopy()</code> 对元素进行复制，因此删除操作成本很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加元素时使用 <code>ensureCapacity()</code> 方法来保证容量足够，如果不够时，需要使用 <code>grow()</code> 方法进行扩容，使得新容量为旧容量的 $1.5$ 倍（oldCapacity + (oldCapacity &gt;&gt; 1))。扩容操作需要把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>modCount</code> 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行<strong>序列化</strong>(把对象转化为可传输的字节序列过程)或者<strong>迭代</strong>等操作时，需要比较操作前后 modCount 是否改变，如果改变则需要抛出 ConcurrentModificationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashMap-原理"><a href="#HashMap-原理" class="headerlink" title="HashMap 原理"></a>HashMap 原理</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>使用拉链法来解决冲突，内部包含了一个 Entry 类型的数组 table，数组中的每个位置被当成一个桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><p>其中，Entry 就是存储数据的键值对，它包含了四个字段。从 next 字段我们可以看出 Entry 是一个链表，即每个桶会存放一个链表。</p><p><img src="8fe838e3-ef77-4f63-bf45-417b6bc5c6bb.png" alt=""></p><p>JDK 1.8 使用 Node 类型存储一个键值对，它继承自 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拉链法原理"><a href="#拉链法原理" class="headerlink" title="拉链法原理"></a>拉链法原理</h2><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，计算 K1 的 hashCode 为 $115$，使用除留余数法得到所在的桶下标 $115\%16=3$。</li><li>插入 &lt;K2,V2&gt; 键值对，计算 K2 的 hashCode 为 $118$，使用除留余数法得到所在的桶下标 $118\%16=6$。</li><li>插入 &lt;K3,V3&gt; 键值对，计算 K3 的 hashCode 为 $118$，使用除留余数法得到所在的桶下标 $118\%16=6$，插在 &lt;K2,V2&gt; 后面。</li></ul><p><img src="07903a31-0fb3-45fc-86f5-26f0b28fa4e7.png" alt=""></p><p>查找需要分成两步进行：</p><ul><li><p>计算键值对所在的桶；</p></li><li><p>在链表上顺序查找。</p></li></ul><p>时间复杂度显然和链表的长度成正比。</p><p>从 JDK 1.8 开始，<strong>一个桶存储的链表长度大于 $8$ 时会将链表转换为红黑树</strong>。</p><blockquote><p><strong>计算桶下标</strong></p></blockquote><p>$(1)$ hashCode 通过调用 Key 的 <code>hashCode()</code> 方法得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$(2)$ 高位运算</p><p>将 hashCode 的高 $16$ 位和低 $16$ 位进行异或操作，使得数组比较小时也能保证高低位都参与到哈希计算中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$(3)$ 除留余数法</p><p>令 $x = 1&lt;&lt;4$，即 $x$ 为 $2$ 的 $4$ 次方，它具有以下性质：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure><p>令一个数 $y$ 与 $x-1$ 做与运算，可以去除 $y$ 位级表示的第 $4$ 位及以上数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>结果和 $y$ 对 $x$ 取模是一样的：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">y   : 10110010</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><p>位运算的代价比求模运算小的多，因此在进行这种计算时能用位运算的话能带来更高的性能。</p><p>拉链法需要使用除留余数法来得到桶下标，需要进行以下计算：hash%capacity，如果能保证 capacity 为 $2$ 的幂次方，那么就可以将这个操作转换为位运算。</p><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>设 HashMap 的 table 长度为 $M$，需要存储的键值对数量为 $N$，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 $N/M$，因此平均查找次数的数量级为 $O(N/M)$。为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>相关参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">capacity</td><td style="text-align:left">table 的容量大小，默认为 16，需要注意的是 capacity 必须保证为 2 的次方。</td></tr><tr><td style="text-align:center">size</td><td style="text-align:left">table 的实际使用量。</td></tr><tr><td style="text-align:center">threshold</td><td style="text-align:left">size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</td></tr><tr><td style="text-align:center">load_factor</td><td style="text-align:left">table 能够使用的比例，threshold = capacity * load_factor。</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>当需要扩容时，令 capacity 为原来的 $2$ 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容使用 <code>resize()​</code> 实现，但它需要把旧 table 的所有键值对插入新的 table 中，因此这一步是很费时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 允许有一个 Node 的 Key 为 null，该 Node 一定会放在第 $0$ 个桶的位置，因为这个 Key 无法计算 hashCode()，所以只能规定一个桶让它存放。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>==JDK 1.7 版本==</p><p>数据结构：ReentrantLock+Segment+HashEntry</p><p>ConcurrentHashMap(并发哈希表) 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁，每个分段锁维护着几个桶，多个线程可以同时访问不同分段锁上的桶。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问，在同一时间点只能有一个线程能访问容器。</p><p>存储结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承自 ReentrantLock(可重入锁)，每个 Segment 维护着多个 HashEntry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的并发级别为 $16$，也就是说默认创建 $16$ 个 Segment。</p><p>查询：二次哈希，第一次定位到 Segment，第二次定位到元素所在链表的头部。</p><p><img src="image005.jpg" alt=""></p><p>==JDK 1.8 版本==</p><p>数据结构：synchronized+CAS+Node+红黑树。</p><p>查找、替换、赋值操作都使用 CAS。</p><p>使用了内置锁 synchronized 代替 Segment，Segment 属于重入锁 ReentrantLock。主要是出于以下考虑：</p><ul><li>synchronized 的锁粒度更低，JDK1.7版本锁的粒度是基于 Segment 的，包含多个 HashEntry，而 JDK1.8 锁的粒度就是 HashEntry (首节点)；</li><li>基于 JVM 的 synchronized 优化空间更大，使用内嵌的关键字比使用 API 更加自然；</li><li>在大量的数据操作下，基于 API 的 ReentrantLock 会开销更多的内存。</li></ul><h1 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h1><h2 id="排序，查找，替换操作"><a href="#排序，查找，替换操作" class="headerlink" title="排序，查找，替换操作"></a>排序，查找，替换操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//返回target在list中第一次出现的索引，找不到则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h2 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h2><p>Collections 提供了多个 <code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。HashSet，TreeSet，ArrayList，LinkedList，HashMap，TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定collection支持的同步(线程安全的)collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步(线程安全的)List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步(线程安全的)Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定set支持的同步(线程安全的)set。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最好不要用这些方法，效率非常低，需要线程安全的集合类型时考虑使用 JUC 包下的并发集合。</p><h1 id="fail-fast-amp-fail-safe"><a href="#fail-fast-amp-fail-safe" class="headerlink" title="fail-fast &amp; fail-safe"></a>fail-fast &amp; fail-safe</h1><p>$(1)$ 快速失败(fail-fast)</p><p>快速失败(fail-fast) 是 Java 集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 <code>ConcurrentModificationException</code> 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</p><p>每当迭代器使用 <code>hashNext()</code>/<code>next()</code>遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否为 <code>expectedModCount</code> 值，是的话就返回遍历；否则抛出异常，终止遍历。如果我们在集合被遍历期间对其进行修改的话，就会改变 <code>modCount</code> 的值，进而导致 <code>modCount != expectedModCount</code> ，进而抛出 <code>ConcurrentModificationException</code> 异常。</p><p>注：通过 Iterator 的方法修改集合的话会修改到 <code>expectedModCount</code> 的值，所以不会抛出异常。</p><p>$(2)$ 安全失败(fail-safe)</p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 <code>ConcurrentModificationException</code> 异常。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Array-和-ArrayList-的区别？"><a href="#Array-和-ArrayList-的区别？" class="headerlink" title="Array 和 ArrayList 的区别？"></a>Array 和 ArrayList 的区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 指定固定大小，而 ArrayList 大小是自动扩展的。</li></ul><h2 id="ArrayList-和-LinkedList-的区别？"><a href="#ArrayList-和-LinkedList-的区别？" class="headerlink" title="ArrayList 和 LinkedList 的区别？"></a>ArrayList 和 LinkedList 的区别？</h2><p>ArrayList：底层是基于数组实现的。查找快，增删较慢；</p><p>LinkedList：底层是基于链表实现的。查找慢、增删快。</p><p><strong>ArrayList 的增删未必比 LinkedList 慢：</strong></p><ol><li>如果增删都是在末尾来操作（每次调用的都是 remove() 和 add()），此时 ArrayList 就不需要移动和复制数组。如果数据量有百万级，速度会比 LinkedList 要快。</li><li>如果删除操作的位置是在中间。由于 LinkedList 的消耗主要是在遍历上，ArrayList 的消耗主要是在移动和复制上（底层调用的是 arrayCopy() 方法，是 native 方法）。LinkedList 的遍历速度是慢于 ArrayList 的复制移动速度的。如果数据量有百万级，还是 ArrayList 要快。</li></ol><h2 id="ArrayList-实现-RandomAccess-接口有何作用？"><a href="#ArrayList-实现-RandomAccess-接口有何作用？" class="headerlink" title="ArrayList 实现 RandomAccess 接口有何作用？"></a>ArrayList 实现 RandomAccess 接口有何作用？</h2><p>RandomAccess 接口只是一个标志接口，只要 List 集合实现这个接口，就能支持快速随机访问。</p><p>实现 RandomAccess 接口的 List 集合采用一般的 for 循环遍历，而未实现这接口则采用迭代器，即 ArrayList 一般采用 for 循环遍历，而 LinkedList 一般采用迭代器遍历。</p><p>ArrayList 用 for 循环遍历比 iterator 迭代器遍历快，LinkedList 用 iterator 迭代器遍历比 for 循环遍历快。</p><h2 id="HashMap-的-get-方法能否判断某个元素是否在-map-中？"><a href="#HashMap-的-get-方法能否判断某个元素是否在-map-中？" class="headerlink" title="HashMap 的 get 方法能否判断某个元素是否在 map 中？"></a>HashMap 的 get 方法能否判断某个元素是否在 map 中？</h2><p>HashMap 的 get 函数的返回值不能判断一个 key 是否包含在 map 中，因为 get 返回 null 有可能不包含该 key，也有可能该 key 对应的 value 为 null。因为 HashMap 中允许 key 为 null，也允许 value 为 null。</p><h2 id="HashMap-与-HashTable-的区别"><a href="#HashMap-与-HashTable-的区别" class="headerlink" title="HashMap 与 HashTable 的区别"></a>HashMap 与 HashTable 的区别</h2><ol><li>HashTable 不允许 key 和 value 为 null；</li><li>HashTable 是线程安全的。但是 HashTable 线程安全的策略实现代价太大，get/put 所有相关操作都是 synchronized 的，这相当于给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</li><li>HashMap 不是线程安全的，但可以通过 Collections.synchronizedMap(hashMap)，使其实现同步。</li></ol><h2 id="HashTable-和-ConcurrentHashMap-的区别"><a href="#HashTable-和-ConcurrentHashMap-的区别" class="headerlink" title="HashTable 和 ConcurrentHashMap 的区别"></a>HashTable 和 ConcurrentHashMap 的区别</h2><p>HashTable 和 ConcurrentHashMap 相比，效率低。 Hashtable 之所以效率低主要是使用了 synchronized 关键字对 put 等操作进行加锁，而 synchronized 关键字加锁是对整张 Hash 表的，即每次锁住整张表让线程独占，致使效率低下，而 ConcurrentHashMap 在对象中保存了一个 Segment 数组，即将整个 Hash 表划分为多个分段；而每个 Segment 元素，即每个分段则类似于一个Hashtable；这样在执行 put 操作时首先根据 hash 算法定位到元素属于哪个 Segment，然后对该 Segment 加锁即可。</p><h2 id="HashSet-的实现原理"><a href="#HashSet-的实现原理" class="headerlink" title="HashSet 的实现原理"></a>HashSet 的实现原理</h2><p>HashSet 的实现依赖 HashMap，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复。因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，value 则是 PRESENT 变量，这个变量只作为放入 map 时的一个占位符而存在，当存储的值已经存在时返回 false。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;容器主要包括 Collection 和 Map 两种。&lt;/p&gt;
&lt;p&gt;Collection：存放独立元素的序列。&lt;/p&gt;
&lt;p&gt;Map：存放key-value型的元素对。&lt;/p&gt;
&lt;h1 id=&quot;Collection&quot;&gt;&lt;a href=&quot;#Coll</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于分布式HBase的数据分析</title>
    <link href="http://10185102110.github.io/2021/07/15/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FHBase%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://10185102110.github.io/2021/07/15/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FHBase%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</id>
    <published>2021-07-15T13:05:50.000Z</published>
    <updated>2021-08-28T04:54:46.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 14.04</p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><ul><li>三台阿里云 CentOS 轻量级服务器</li><li>Xshell 终端模拟软件</li><li>WinSCP 文件操作软件</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul><li>Ubuntu下Java, Hadoop与HBase的安装及伪分布式的部署；</li><li>使用Java API对HBase进行基本操作 ；</li><li>基于Hadoop实现MapReduce；</li><li>使用 TensorFlow 框架，对摩拜单车数据集的经纬度进行分析，并可视化。</li></ul><h2 id="HBase-简介"><a href="#HBase-简介" class="headerlink" title="HBase 简介"></a>HBase 简介</h2><p>HBase是一个构建在HDFS上的分布式列存储系统； </p><p>HBase是基于Google BigTable模型开发的，典型 的key/value系统；</p><p>HBase是Apache Hadoop生态系统中的重要一员，主要用于海量结构化数据存储； </p><p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文 “Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System） 所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。</p><p>HBase是Apache 的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据 库。另一个不同的是HBase基于列的而不是基于行的模式。</p><h3 id="分布式Hbase协调工作说明"><a href="#分布式Hbase协调工作说明" class="headerlink" title="分布式Hbase协调工作说明"></a>分布式Hbase协调工作说明</h3><h4 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h4><p>1.保证任何时候，集群中只有一个master </p><p>2.存贮所有Region的寻址入口 </p><p>3.实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master </p><p>4.存储Hbase的schema，包括有哪些table，每个table有哪些column family</p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>1.为Region server分配region </p><p>2.负责region server的负载均衡 </p><p>3.发现失效的region server并重新分配其上的region </p><p>4.GFS上的垃圾回收 </p><p>5.处理schema更新请求</p><h4 id="Region-server"><a href="#Region-server" class="headerlink" title="Region server"></a>Region server</h4><p>1.Region server 维护Master分配给它的region，处理对这些region的IO请求。 </p><p>2.Region server 负责切分在运行过程中变得过大的region。 可以看到，client访问hbase上数据的过程并不需要master参与（寻址访问zookeeper和region server，数据读写访问region server）, master仅仅维护着table和region的元数据信息，负载很低。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol><li><p>安装 Java</p><p>安装 JRE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install default-jre</span><br></pre></td></tr></table></figure><p>安装 OpenJDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install default-jdk</span><br></pre></td></tr></table></figure><p>安装 OracleJDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line">sudo apt-get install oracle-java8-set-default</span><br></pre></td></tr></table></figure></li><li><p>安装 SSH</p><p>在 Hadoop 运行过程中，主从机之间是通过SSH进行通信的，所以需要对所有主机进行SSH的安装和配置 工作。</p><p>安装ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install openssh-server</span><br></pre></td></tr></table></figure><p>使用下面的命令来查看SSH是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure><p><strong>配置免密登录 SSH</strong></p><p>在master主机上进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -keygen -t rsa</span><br></pre></td></tr></table></figure><p>将公钥（<code>~/.ssh/id_rsa.pub</code>中的内容）复制到文件 <code>authorized_keys</code> 中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>将 master 上的 <code>~/.ssh/authorized_keys</code> 通过 scp 命令复制到从机 slave1,slave2 中去。</p><p>但发现通过ssh命令仍不能实现三台主机之间的免密登录，查阅资料我们知道：ssh对目录权限有要求， 代码中要设置新生成的config文件75，其中~目录权限值为750，~/.ssh的是700，~/.ssh/*是600，因此 我们需要给它赋值600，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>安装 Zookeeper</p><p>选择一个版本的 Zookeeper 进行下载安装，用 winSCP 将文件传到服务器根目录下，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp zookeeper-3.5.6-bin.tar.gz hadoop@47.101.139.207:~/</span><br></pre></td></tr></table></figure><p>进入服务器根目录下，将zookeeper-3.5.6-bin.tar.gz解压至 /usr/local/cluster中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf ~/zookeeper-3.5.6-bin-tar.gz -C /usr/local/cluter/</span><br></pre></td></tr></table></figure><p>这里解压之后形成的文件夹名为zookeeper-3.5.6，为了方便后续操作，我们将之改名为zookeeper 设置环境变量，在 <code>~/.bashrc</code> 中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#zookeeper</span><br><span class="line">export ZOOKEEPER=/usr/local/cluster/zookeeper</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER/bin</span><br></pre></td></tr></table></figure><p>使环境变量生效，并为 zookeeper 配置数据和日志文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>当三台主机全部配置完成之后，尝试启动zookeeper：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/cluster/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="1"></p><p>查看 zookeeper 启动状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/cluster/zookeeper/bin/zkServer.sh status</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="2"></p><p>发现 error contacting 经过研究发现，在zoo.cfg配置文件中加上如下一行代码，即可解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quorumListenOnALLIPS=true</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>完成配置</p></li><li><p>安装 Hadoop 和 HBase</p><p>基本过程与安装 zookeeper 相似，在此省略。</p><p>在hadoop的配置过程中由于java的问题，要注意我们JAVA_HOME的环境变量路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#java</span><br><span class="line"> export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</span><br><span class="line"> export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p>接下来进行伪分布式的配置。Hadoop可以在单节点上以伪分布式的方式运行。Hadoop进程以分离的Java进程来运行。需要对hadoop/etc/hadoop中的两个配置文件进行修改。</p><p><img src="5.png" alt="5"></p><p><img src="6.png" alt="6"></p><p>修改完成后对NameNode进行格式化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>启动 hadoop：</p><p><img src="4.png" alt="4"></p><p>用 jps 判断是否启动成功</p><p><img src="7.png" alt="7"></p><p>可以看到，出现 NameNode, DataNode 和 SecondaryNameNode 三个进程，说明启动成功。</p><p>在 50069 端口可以查看节点信息</p><p><img src="8.png" alt="8"></p><p>通过16010端口查看 HBase 运行情况</p><p><img src="9.png" alt="9"></p></li></ol><h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>使用Hbase Shell导入数据：</p><p><img src="10.png" alt="10"></p><p>在 HBase 内, 数据按照 <code>&lt;行键&gt;&lt;列族1: 列1-1, 列1-2&gt;&lt;列族2: 列2-1, 列2-2&gt;</code> 这样的类型进行存储的。且, 其一, 其中行键的排列顺序是按照字典顺序排序的, 这点对于搜索非常重要。其二, 同一行键的相同列族中列的值, 是可能变化的, 并且按照时间戳进行排序的(当然, 有些数据在合并的时候, 会被删除) 。其中, 相应的模块知识, 如下所示:</p><ul><li><p>Row Key </p><p><code>Row Key</code> , 行键. 是用来检索记录的主键. 访问 <code>HBase Table</code> 中的行, 主要有三种方式. 单个row key 进行访问 / 通过 row key 正则匹配 / 全表扫描 . Row Key 的值可以是任意字符串(最大长度为64KB, 实际使用经常为10-100byte) .其中, 行键的排列顺序是按照字典顺序排序的, 这点对于搜索非常重要. (PS: 字典顺序: <code>1 10 12 6 7 9</code> 中, <code>11</code> 排在 <code>9</code> 之前.) </p></li><li><p>Columns Family </p><p><code>Columns Famil</code>y 列族. HBase 内的每个列, 都属于一个列族. 列族是 Schema 一部分(即表设计), 而 列不是(列可以在插入数据时, 动态添加). 列族是需要在使用之前进行提前定义的. 列名都以列族为前缀, 如<code>course:namecourse:age</code>. </p></li><li><p>Cell </p><p><code>Cell</code> , 数据单元. 有唯一确定的单元. Cell 内的数据是没有类型的, 全部都是字节码进行存储的. </p></li><li><p>Time Stamp </p><p>每个 Cell 存储一个数据的多个版本. 版本号, 通过时间戳进行索引(时间精确到毫秒). 时间戳类型为 64位整数类型. 时间戳按照时间类型倒叙排序. </p><p>回收版本机制: <code>&lt;保存数据的最后n个版本&gt; / &lt;保存最近一段时间的版本(如最近七天)&gt;</code></p></li></ul><p>操作流程</p><ol><li><p>将服务器本地文件(.csv)上传到hdfs的根目录下,然后导入数据到hbase</p></li><li><p>进入hbase shell 创建表 bicycle,列族为info</p></li><li><p>执行文件导入（Hadoop用户中执行）</p><p>格式：hbase [类] [分隔符] [行键，列族] [表] [导入文件] （默认分隔符为空格）</p></li><li><p>导入完成后，可以使用 scan  来查看是否导入成功</p></li></ol><p><img src="11.png" alt="11"></p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>对数据清洗之后得到若干组经纬度坐标，对坐标进行聚类，采用以下四种算法：</p><ol><li><p>K-Means (K均值) 聚类</p><p>步骤： </p><p>(1) 选择一些类/组，并随机初始化它们各自的中心点。中心点是与每个数据点向量长度相同的位置（需 要提前预知类的数量，即中心点的数量)。 </p><p>(2) 计算每个数据点到中心点的距离，数据点距离哪个中心点最近就划分到哪一类中。 </p><p>(3) 计算每一类中中心点作为新的中心点。 </p><p>(4) 重复以上步骤，直到每一类中心在每次迭代后变化不大为止。也可以多次随机初始化中心点，然后 选择运行结果最好的一个。</p><p>优点： </p><p>(1) 速度快 </p><p>(2) 计算简便</p><p>缺点： </p><p>(1) 需要提前知道数据有多少类 </p><p>(2) 摩拜单车数据量庞大，并不知道一共可以分成多少类，存在一定误差，但在中小规模数据下可以适 用。</p></li><li><p>均值漂移聚类</p><p>步骤： </p><p>(1) 确定滑动窗口半径r，以随机选取的中心点C半径为r的圆形滑动窗口开始滑动。均值漂移类似一种爬 山算法，在每一次迭代中向密度更高的区域移动，直到收敛。 </p><p>(2) 每一次滑动到新的区域，计算滑动窗口内的均值来作为中心点，滑动窗口内的点的数量为窗口内的 密度。在每一次移动中，窗口会想密度更高的区域移动。 </p><p>(3) 移动窗口，计算窗口内的中心点以及窗口内的密度，知道没有方向在窗口内可以容纳更多的点，即 一直移动到圆内密度不再增加为止。 </p><p>(4) 步骤一到三会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数 据点所在的滑动窗口进行聚类。</p><p>优点： </p><p>(1) 不需要设定一共有多少组 </p><p>(3) 受均值影响小 </p><p>缺点： </p><p>r 的选择可能并不重要，在本次实验中并没有好的预期效果。</p></li><li><p>基于密度的聚类方法 (DBSCAN)</p><p>步骤： </p><p>(1) 首先确定半径 r 和 minPoints。从一个没有被访问过的任意数据点开始，以这个点为中心，r 为半径 的圆内包含的点的数量是否大于或等于 minPoints，如果大于或等于 minPoints 则改点被标记为 central point ,反之则会被标记为 noise point。 </p><p>(2) 重复 (1) 的步骤，如果一个 noise point 存在于某个 central point 为半径的圆内，则这个点被标记为 边缘点，反之仍为 noise point。重复步骤 ，直到所有的点都被访问过。</p><p>优点： </p><p>不需要设定一共有多少组。</p><p>缺点： </p><p>需要频繁改动距离 r 和 minPoints，来获得较好的预期效果。</p></li><li><p>用高斯混合模型（GMM）的最大期望（EM）聚类</p><p>步骤： </p><p>(1) 选择簇的数量 (与K-Means类似) 并随机初始化每个簇的高斯分布参数 (均值和方差) 。也可以先观察 数据给出一个相对精确的均值和方差。 </p><p>(2) 给定每个簇的高斯分布，计算每个数据点属于每个簇的概率。一个点越靠近高斯分布的中心就越可 能属于该簇。 </p><p>(3) 基于这些概率我们计算高斯分布参数使得数据点的概率最大化，可以使用数据点概率的加权来计算 这些新的参数，权重就是数据点属于该簇的概率。 重复迭代 (2) 和 (3) 直到在迭代中的变化不大。</p><p>优点：</p><p>(1) 使用均值和标准差，簇可以呈现出椭圆形而不是仅仅限制于圆形 </p><p>(2) 使用概率，所有一个数据点可以属于多个簇 </p><p>缺点： </p><p>目的为确认单车的密度分布，并不太适用此算法。</p></li></ol><p>代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> cholesky</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle  <span class="comment"># 用于打乱数据</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zc_read_csv</span>():</span></span><br><span class="line">    zc_dataframe = pd.read_csv(<span class="string">&quot;C:/Users/HP/Desktop/mobike/mobike/1/123.csv&quot;</span>, sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    x = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> zc_index <span class="keyword">in</span> zc_dataframe.index:</span><br><span class="line">        zc_row = zc_dataframe.loc[zc_index]</span><br><span class="line">        x.append([zc_row[<span class="number">6</span>],zc_row[<span class="number">7</span>]])</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">x = zc_read_csv()</span><br><span class="line">y = tf.convert_to_tensor(x,name=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">z = tf.to_double(y, name=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    srcdata = sess.run(z)</span><br><span class="line"><span class="built_in">print</span>(srcdata)</span><br><span class="line"><span class="comment"># 画出当前的所有点</span></span><br><span class="line">plt.plot(srcdata[:, <span class="number">0</span>], srcdata[:, <span class="number">1</span>], <span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义K-means算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义K-means算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">vectors, k_num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 TensorFlow 实现K-Means 算法</span></span><br><span class="line"><span class="string">    :param vectors: 是一个 n * k 的Numpy数组，n代表k维向量的数量，也就是模拟产生的数据点的Tensor</span></span><br><span class="line"><span class="string">    :param k_num: 表示需要分类的个数,是一个整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将 k 转换为整数</span></span><br><span class="line">    k_num = <span class="built_in">int</span>(k_num)</span><br><span class="line">    <span class="comment"># 异常处理，防止后续数组下标越界,防止出现分类个数大于实际的点的个数</span></span><br><span class="line">    <span class="keyword">assert</span> k_num &lt; <span class="built_in">len</span>(vectors)</span><br><span class="line">    <span class="comment"># 找出每个向量的维度,平面点的维度为2(x,y)，空间点维度为3(x,y,z)</span></span><br><span class="line">    dim = <span class="built_in">len</span>(vectors[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 获取 vectors 长度大小的随机数据(本例中为1000)</span></span><br><span class="line">    vector_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(vectors)))</span><br><span class="line">    <span class="comment"># 打乱 vector_indices 中的所有数据，能够更好的泛化</span></span><br><span class="line">    shuffle(vector_indices)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图</span></span><br><span class="line">    <span class="comment"># 我们创建了一个默认的计算流的图用于整个算法中，这样就保证了当函数被多次调用时，始终使用的     # 是默认的图</span></span><br><span class="line">    graph = tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> graph.as_default():</span><br><span class="line">        <span class="comment"># 创建会话</span></span><br><span class="line">        tf.compat.v1.disable_eager_execution()</span><br><span class="line">        <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">            <span class="comment"># 构建基本的计算的元素</span></span><br><span class="line">            <span class="comment"># 首先我们需要保证每个中心点都会存在一个Variable矩阵</span></span><br><span class="line">            <span class="comment"># 从现有的点集合中抽取出前 k_num 个数据作为默认的中心点,并且定义为 tf 的变量,</span></span><br><span class="line">            <span class="comment"># 用于后续的中心点的运算</span></span><br><span class="line">            centroids = [tf.Variable((vectors[vector_indices[i]]))<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_num)]</span><br><span class="line">            <span class="comment"># 创建一个placeholder用于存放各个分类的中心点</span></span><br><span class="line">            centroid_value = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 给 k_num 个中心点向量进行赋值,cent_assigns 用于保存中心点的位置信息</span></span><br><span class="line">            cent_assigns = []</span><br><span class="line">            <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids:</span><br><span class="line">                cent_assigns.append(tf.assign(centroid, centroid_value))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># assignments 用于保存 sampleNo 个点的经过计算分类后位置</span></span><br><span class="line">            assignments = [tf.Variable(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors))]</span><br><span class="line">            <span class="comment"># 存储每个单独的点到 k_num 个分类的最短距离</span></span><br><span class="line">            assignment_value = tf.placeholder(dtype=tf.int32)</span><br><span class="line">            <span class="comment"># cluster_assigns 存储的是每个点到 k_num 个中心点中的最小的一个距离</span></span><br><span class="line">            cluster_assigns = []</span><br><span class="line">            <span class="comment"># 初始化 cluster_assigns</span></span><br><span class="line">            <span class="keyword">for</span> assignment <span class="keyword">in</span> assignments:</span><br><span class="line">                cluster_assigns.append(tf.assign(assignment, assignment_value))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 下面创建用于计算平均值的操作节点</span></span><br><span class="line">            <span class="comment"># 输入的placeholder</span></span><br><span class="line">            mean_input = tf.placeholder(dtype=tf.float64, shape=[<span class="literal">None</span>, dim])</span><br><span class="line">            <span class="comment"># 节点/OP接受输入，并且计算0维度的平均值，如输入的向量列表</span></span><br><span class="line">            mean_op = tf.reduce_mean(mean_input, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用于计算欧几里得距离的节点 distance = ((x1 - x2)^2 + (y1 - y2)^2)^(1/2)</span></span><br><span class="line">            v1 = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line">            v2 = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line">            </span><br><span class="line">            euclid_dist = tf.sqrt(tf.reduce_sum(tf.<span class="built_in">pow</span>(tf.subtract(v1, v2), <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这个OP会决定应该将向量归属到哪个节点</span></span><br><span class="line">            <span class="comment"># 基于向量到中心点的欧几里得距离</span></span><br><span class="line">            <span class="comment"># Placeholder for input</span></span><br><span class="line">            centroid_distances = tf.placeholder(dtype=tf.float64, shape=[k_num])</span><br><span class="line">            <span class="comment"># cluster_assignment 计算 k_num 个中心点的最短欧几里得距离</span></span><br><span class="line">            cluster_assignment = tf.argmin(centroid_distances, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 初始化所有的状态值</span></span><br><span class="line">            init_op = tf.global_variables_initializer()</span><br><span class="line">            <span class="comment"># 初始化所有的变量</span></span><br><span class="line">            sess.run(init_op)</span><br><span class="line">            <span class="comment"># 创建tensor图,并保存在当前的log目录下</span></span><br><span class="line">            tf.summary.FileWriter(<span class="string">&quot;./log&quot;</span>, sess.graph)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 集群遍历</span></span><br><span class="line">            <span class="comment"># 接下来在K-Means聚类迭代中使用最大期望算法。为了简单起见，只让它执行固</span></span><br><span class="line">            <span class="comment"># 定的训练的次数为20次，而不设置一个终止条件</span></span><br><span class="line">            noofiterations = <span class="number">20</span></span><br><span class="line">            <span class="keyword">for</span> iteration_n <span class="keyword">in</span> <span class="built_in">range</span>(noofiterations):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 期望步骤</span></span><br><span class="line">                <span class="comment"># 基于上次迭代后算出的中心点的位置</span></span><br><span class="line">                <span class="comment"># 1.首先遍历所有的向量,len(vectors)在此案例中值为 sampleNo = 1000</span></span><br><span class="line">                <span class="comment"># 计算每个点到 k_num 个分类中心点的最短距离,并存储在 cluster_assigns 中</span></span><br><span class="line">                <span class="keyword">for</span> vector_n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors)):</span><br><span class="line">                    <span class="comment"># 获取第 vector_n 个向量,取值范围在[0,999]</span></span><br><span class="line">                    vect = vectors[vector_n]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 当前点与 k_num 个分类的中心点欧几里得距离</span></span><br><span class="line">                    distances = [sess.run(euclid_dist, feed_dict=&#123;</span><br><span class="line">                        v1: vect, v2: sess.run(centroid)&#125;) <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 获取当前点到 k_num 个分类中心点的最短距离,目的是为了后续选择最近距离的中心点</span></span><br><span class="line">                    assignment = sess.run(cluster_assignment, feed_dict=&#123;</span><br><span class="line">                        centroid_distances: distances&#125;)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 接下来为每个向量分配合适的值</span></span><br><span class="line">                    sess.run(cluster_assigns[vector_n], feed_dict=&#123;</span><br><span class="line">                        assignment_value: assignment&#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 2.将所有点进行分类</span></span><br><span class="line">                <span class="comment"># 基于上述的期望步骤，计算每个新的中心点的距离从而使集群内的平方和最小</span></span><br><span class="line">                <span class="keyword">for</span> cluster_n <span class="keyword">in</span> <span class="built_in">range</span>(k_num):</span><br><span class="line">                    <span class="comment"># 收集 k_num 个分类中,对应每个分类的数据</span></span><br><span class="line">                    assigned_vects = [vectors[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors))</span><br><span class="line">                                      <span class="keyword">if</span> sess.run(assignments[i]) == cluster_n]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 采用平均值的计算方式重新计算每个分类集群新的中心点</span></span><br><span class="line">                    new_location = sess.run(mean_op, feed_dict=&#123;</span><br><span class="line">                        mean_input: array(assigned_vects)&#125;)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 为 k_num 个分类分配新的中心点</span></span><br><span class="line">                    sess.run(cent_assigns[cluster_n], feed_dict=&#123;</span><br><span class="line">                        centroid_value: new_location&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回 k_num 个中心节点</span></span><br><span class="line">            centroids = sess.run(centroids)</span><br><span class="line">            <span class="comment"># 返回 k_num 个分组</span></span><br><span class="line">            assignments = sess.run(assignments)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> centroids, assignments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义聚类的个数,并使用kmeans算法去计算</span></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">center, result = kmeans(srcdata, k)</span><br><span class="line"><span class="built_in">print</span>(np.shape(result))</span><br><span class="line"><span class="comment"># 打印 k 个中心点</span></span><br><span class="line"><span class="built_in">print</span>(center)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整理结果,并使用 seaborn 画图</span></span><br><span class="line">res = &#123;<span class="string">&quot;x&quot;</span>: [], <span class="string">&quot;y&quot;</span>: [], <span class="string">&quot;kmeans_res&quot;</span>: []&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">    res[<span class="string">&quot;x&quot;</span>].append(srcdata[i][<span class="number">0</span>])</span><br><span class="line">    res[<span class="string">&quot;y&quot;</span>].append(srcdata[i][<span class="number">1</span>])</span><br><span class="line">    res[<span class="string">&quot;kmeans_res&quot;</span>].append(result[i])</span><br><span class="line"></span><br><span class="line">pd_res = pd.DataFrame(res)</span><br><span class="line">sns.lmplot(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, data=pd_res, fit_reg=<span class="literal">False</span>, height=<span class="number">5</span>, hue=<span class="string">&quot;kmeans_res&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>对聚类出的经纬度数据聚类后，为了方便检测聚类结果，我们直接采用 python 的 matplotlib 库以经 纬度为坐标画出聚类结果，但发现这种方式对于聚类结果的显示并不是很直观，无法发现聚类结果和实 际地形的关联。于是想到使用高德地图的 API，希望可以将聚类结果直接在实际的地图上投影，在参阅 了高德地图官方 API 实例之后，发现其提供的海量点，点聚合可以实现我们的需求。申请成为高德地图 开放平台的个人开发者，得到 key，然后利用其中的 API 进行可视化。如下图所示：</p><p><img src="12.png" alt="12"></p><p><img src="13.png" alt="13"></p><p><img src="14.png" alt="14"></p><p><img src="15.png" alt="15"></p><p><img src="16.png" alt="16"></p><p>可视化后可以发现上海区域地图上呈现若干密集点，通过调整地图的大小，可以调整密集点的大小， 根据需求可以知道不同区域摩拜单车的密集度。这些密集度说明哪些区域会使用更多的摩拜单车，为了 符合人们用车需求应当调整不同区域摩拜单车的数量，才能更好地满足人们的需求。</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0, user-scalable=no, width=device-width&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>点聚合<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">25rem</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">7rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: .<span class="number">7rem</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> <span class="selector-class">.btn</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;map&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>聚合点效果切换<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;默认样式&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add0&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(0)&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;自定义图标&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add1&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(1)&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;完全自定义&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add2&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(2)&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./china.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://webapi.amap.com/maps?v=1.4.15&amp;key=2b373ec81fe728db4bf6b57baea1138d&amp;plugin=AMap.MarkerClusterer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cluster, markers = [];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">&quot;container&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">resizeEnable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">center</span>: [<span class="number">105</span>, <span class="number">34</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">zoom</span>: <span class="number">4</span></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        markers.push(<span class="keyword">new</span> AMap.Marker(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">position</span>: points[i][<span class="string">&#x27;lnglat&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="attr">content</span>: <span class="string">&#x27;&lt;div style=&quot;background-color: hsla(180, 100%, 50%, 0.7); height: 24px; width: 24px; border: 1px solid hsl(180, 100%, 40%); border-radius: 12px; box-shadow: hsl(180, 100%, 50%) 0px 0px 1px;&quot;&gt;&lt;/div&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">15</span>, -<span class="number">15</span>)</span></span><br><span class="line"><span class="javascript">        &#125;))</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> count = markers.length;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _renderClusterMarker = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> factor = <span class="built_in">Math</span>.pow(context.count / count, <span class="number">1</span> / <span class="number">18</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> Hue = <span class="number">180</span> - factor * <span class="number">180</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bgColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,50%,0.7)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> fontColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,20%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> borderColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,40%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> shadowColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,50%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.backgroundColor = bgColor;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> size = <span class="built_in">Math</span>.round(<span class="number">30</span> + <span class="built_in">Math</span>.pow(context.count / count, <span class="number">1</span> / <span class="number">5</span>) * <span class="number">20</span>);</span></span><br><span class="line"><span class="javascript">        div.style.width = div.style.height = size + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.border = <span class="string">&#x27;solid 1px &#x27;</span> + borderColor;</span></span><br><span class="line"><span class="javascript">        div.style.borderRadius = size / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.boxShadow = <span class="string">&#x27;0 0 1px &#x27;</span> + shadowColor;</span></span><br><span class="line"><span class="javascript">        div.innerHTML = context.count;</span></span><br><span class="line"><span class="javascript">        div.style.lineHeight = size + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.color = fontColor;</span></span><br><span class="line"><span class="javascript">        div.style.fontSize = <span class="string">&#x27;14px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.textAlign = <span class="string">&#x27;center&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        context.marker.setOffset(<span class="keyword">new</span> AMap.Pixel(-size / <span class="number">2</span>, -size / <span class="number">2</span>));</span></span><br><span class="line"><span class="javascript">        context.marker.setContent(div)</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    addCluster(<span class="number">2</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">addCluster</span>(<span class="params">tag</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (cluster) &#123;</span></span><br><span class="line"><span class="javascript">            cluster.setMap(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (tag == <span class="number">2</span>) &#123;<span class="comment">//完全自定义</span></span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">gridSize</span>: <span class="number">80</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">renderClusterMarker</span>: _renderClusterMarker</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag == <span class="number">1</span>) &#123;<span class="comment">//自定义图标</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> sts = [&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/blue.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">32</span>, <span class="number">32</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">16</span>, -<span class="number">16</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/green.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">32</span>, <span class="number">32</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">16</span>, -<span class="number">16</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/orange.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">36</span>, <span class="number">36</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">18</span>, -<span class="number">18</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/red.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">48</span>, <span class="number">48</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">24</span>, -<span class="number">24</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/darkRed.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">48</span>, <span class="number">48</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">24</span>, -<span class="number">24</span>)</span></span><br><span class="line"><span class="javascript">            &#125;];</span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">styles</span>: sts,</span></span><br><span class="line"><span class="javascript">                <span class="attr">gridSize</span>: <span class="number">80</span></span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//默认样式</span></span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;<span class="attr">gridSize</span>: <span class="number">80</span>&#125;);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码地址：</p><p><a href="https://github.com/10185102110/HBase">https://github.com/10185102110/HBase</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h2&gt;&lt;p&gt;Ubuntu 14.04&lt;/p&gt;
&lt;h2 id=&quot;实验设备&quot;&gt;&lt;a href=&quot;#实验设备&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Server" scheme="http://10185102110.github.io/tags/Server/"/>
    
  </entry>
  
</feed>
