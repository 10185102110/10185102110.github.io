<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生孰来</title>
  
  
  <link href="http://10185102110.github.io/atom.xml" rel="self"/>
  
  <link href="http://10185102110.github.io/"/>
  <updated>2021-08-08T10:03:29.303Z</updated>
  <id>http://10185102110.github.io/</id>
  
  <author>
    <name>Ave Bai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://10185102110.github.io/2021/08/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://10185102110.github.io/2021/08/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-08-08T08:56:52.000Z</published>
    <updated>2021-08-08T10:03:29.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><h1 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给每个对象添加一个计数器，当有地方引用该对象时计数器加 $1$，当引用失效时计数器减 $1$。用对象计数器是否为 $0$ 来判断对象是否可被回收。</p><p>缺点：<strong>无法解决循环引用的问题</strong>。</p><p>例如创建一个字符串，<code>String m = new String(&quot;jack&quot;);</code>，这时候 “jack” 有一个引用，就是 m。然后将 m 设置为 null，这时候 “jack” 的引用次数为 $0$ ，在引用计数算法中，意味着这块内容需要被回收了。</p><p>引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。但 JVM 的垃圾回收就是 Stop-The-World(暂停整个程序) 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object instance;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">&quot;objA&quot;</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">&quot;objB&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最后这 $2$ 个对象已经不会再被访问了，但由于它们相互引用对方，导致它们的引用计数永远都不会为 $0$，通过引用计数算法无法通知 GC 收集器回收它们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>以 GC ROOT 的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收。</p><p><img src="D:\blog\source\_posts\JVM垃圾回收机制\2269232-97bf646f648d6ff7.webp" alt="2269232-97bf646f648d6ff7"></p><p>可达性算法解决了引用计数所无法解决的循环依赖问题，只要对象无法与 GC Root 建立直接或间接的连接，系统就会将其判定为可回收对象。</p><p>Java 内存区域中可以作为 GC ROOT 的对象：</p><ul><li><p>虚拟机栈中引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 s 即为 GC Root，当 s 置空时，“example1” 对象也断掉了与 GC Root 的引用链，将被回收。</p></li><li><p>方法区中类静态属性引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MyType m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s.m = <span class="keyword">new</span> MyType(<span class="string">&quot;example2&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 s 即为 GC Root，s 置为 null，经过GC后，s 所指向的 “example1” 对象由于无法与 GC Root 建立关系被回收。而 m 作为类的静态属性，也属于 GC Root，“example2” 对象依然与 GC root 建立着连接，所以 “example2” 对象不会被回收。</p></li><li><p>方法区中常量引用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MyType m = MyType(<span class="string">&quot;final&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyType</span><span class="params">(String name)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyType s = <span class="keyword">new</span> MyType(<span class="string">&quot;example1&quot;</span>);</span><br><span class="line">s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m 即为方法区中的常量引用，也是 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。</p></li><li><p>本地方法栈中引用的对象</p><p>任何 native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，只是简单地动态连接并直接调用指定的本地方法。</p></li></ul><blockquote><p>引用类型</p></blockquote><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 中有四种强度不同的引用类型。引用由强到若分为：强引用、软引用、弱引用、虚引用。</p><ul><li><p><strong>强引用：</strong>使用 new 一个新对象的方式来创建强引用。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p><strong>软引用：</strong>一些还有用但并非必须的对象。软引用关联着的对象，在系统要发生内存溢出之前，会把这些对象进行垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用：</strong>也是描述一些非必须对象，强度比软引用更弱，只要发生垃圾回收，它就一定会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br></pre></td></tr></table></figure></li><li><p><strong>虚引用：</strong>是最弱的一种引用。设置虚引用的唯一目的是能在这个对象被回收时会收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p><img src="D:\blog\source\_posts\JVM垃圾回收机制\2269232-5b023b00f7bf8f1b.webp" alt="2269232-5b023b00f7bf8f1b"></p><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>缺点：<strong>内存碎片</strong>。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p><img src="D:\blog\source\_posts\JVM垃圾回收机制\2269232-46c30f2ffb8c18af.webp" alt="2269232-46c30f2ffb8c18af"></p><p>复制算法（Copying）能解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。</p><p>缺点：内存利用率只有 $50\%$。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p><img src="D:\blog\source\_posts\JVM垃圾回收机制\2269232-d7cb73cb0e50c060.webp" alt="2269232-d7cb73cb0e50c060"></p><p>标记-整理算法标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>标记整理算法解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。</p><p>缺点：对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上较差。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代收集算法融合上述3种基础的算法思想，根据对象存活周期的不同将内存划分为几块。</p><ul><li><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</p><p>JVM 新生代采用这种算法，但并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>Eden 和 Survivor 大小比例默认为 $8:1$，保证了内存的利用率达到 $90\%$。</p></li><li><p>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>标记-清理算法</strong>或者<strong>标记-整理算法</strong>来进行回收。</p></li></ul><h1 id="内存区域与回收策略"><a href="#内存区域与回收策略" class="headerlink" title="内存区域与回收策略"></a>内存区域与回收策略</h1><h2 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h2><p>大多数情况下，对象会在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC。通过 Minor GC 之后，Eden 区中绝大部分对象会被回收，而那些存活对象，将会送到 Survivor 的 From 区（若 From 区空间不够，则直接进入 Old 区） 。</p><p><strong>Minor GC：</strong></p><p>当年轻代满时就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。通过<strong>复制算法</strong> ,回收垃圾。</p><p><strong>Major GC：</strong></p><p>Major GC 又称为 <strong>Full GC</strong>。当年老代空间不够用的时候，虚拟机会使用“<strong>标记-清除</strong>”或者“<strong>标记-整理</strong>”算法清理出连续的内存空间，分配对象使用。</p><p>调用 System.gc() 时，系统建议执行 Full GC，但是不必然执行。</p><h2 id="Survivor区"><a href="#Survivor区" class="headerlink" title="Survivor区"></a>Survivor区</h2><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲。Survivor 分为 $2$ 个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区中存活的对象放到 Survivor 的 From 区，而在 From 区中，仍存活的对象会根据他们的年龄值来决定去向。（From Survivor 和 To Survivor 的逻辑关系会发生颠倒：From 变 To ， To 变 From，目的是保证有连续的空间存放对方，避免碎片化的发生）</p><blockquote><p>Survivor 区存在的意义</p></blockquote><p>如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor的预筛选保证，只有经历 $16$ 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓大对象是指，需要大量连续内存空间的Java对象，典型的大对象就是很长的字符串以及数组。经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来安置它们。</p><p>虚拟机提供了一个 <code>XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中（正常情况下对象会不断的在Survivor的From与To区之间移动），并且对象年龄设为 $1$。对象在 Survivor 区中每经历一次 Minor GC，年龄就增加 $1$ 岁，当它的年龄增加到一定程度（默认 $15$ 岁），就会晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>XX:MaxPretenuringThreshold</code> 设置。</p><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>为了能更好地适应不同程度的内存状况，虚拟机并不是永远地要求对象的年龄必须达到 <code>MaxPretenuringThreshold</code> 才能晋升老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到 <code>MaxPretenuringThreshold</code>中要求的年龄。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-08-08T08:56:22.000Z</published>
    <updated>2021-08-08T09:58:40.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><h2 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存结构，主要就是分析 JVM 运行时数据存储区域。</p><p>JVM 的运行时数据区主要包括：<strong>堆、栈、方法区、程序计数器</strong>等。</p><p>而 JVM 的优化问题主要在<strong>线程共享的数据区</strong>中：<strong>堆、方法区</strong>。</p><p><img src="D:\blog\source\_posts\JVM内存结构\2019040912492050.png" alt="2019040912492050"></p><h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，<strong>一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行</strong>。</p><p>为了确保线程切换后（<strong>上下文切换</strong>）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。也就是说程序计数器是<strong>线程私有的内存</strong>。</p><p>如果线程执行 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，计数器值为 Undefined。</p><p>程序计数器<strong>不会发生内存溢出</strong>（OutOfMemoryError 即 OOM）问题。</p><h3 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h3><p>JVM 中的栈包括 <strong>Java 虚拟机栈</strong> 和 <strong>本地方法栈</strong>，两者的区别就是，Java 虚拟机栈为 JVM 执行 Java 方法服务，本地方法栈则为 JVM 使用到的 Native 方法服务。Java 虚拟机栈，以下简称栈。</p><blockquote><p>Native 方法是什么？</p></blockquote><p>JDK 中有很多方法是使用 <strong>Native</strong> 修饰的。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）。Native 方法可以理解为是与操作系统直接交互的。比如通知垃圾收集器进行垃圾回收的代码 System.gc()，就是使用 native 修饰的。</p><blockquote><p>栈是什么？​</p></blockquote><p>定义：限定仅在表头进行插入和删除操作的线性表。即压栈（入栈）和弹栈（出栈）都是对栈顶元素进行操作的。所以栈是后进先出的。</p><p>栈是<strong>线程私有的</strong>，他的生命周期与线程相同。每个线程都会分配一个栈的空间，即每个线程拥有独立的栈空间。</p><blockquote><p>栈中存储的是什么？</p></blockquote><p><strong>栈帧</strong>是栈的元素。每个方法在执行时都会创建一个栈帧。栈帧中存储了<strong>局部变量表、操作数栈、动态连接和方法出口</strong>等信息。每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。</p><p><img src="D:\blog\source\_posts\JVM内存结构\20190409182042686.png" alt="20190409182042686"></p><h4 id="1-2-1-局部变量表"><a href="#1-2-1-局部变量表" class="headerlink" title="1.2.1 局部变量表"></a>1.2.1 局部变量表</h4><p>局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（String、数组、对象等），但是<strong>不存储对象的内容</strong>。局部变量表所需的内存空间<strong>在编译期间完成分配</strong>，在方法运行期间不会改变局部变量表的大小。</p><p>局部变量的容量以<strong>变量槽（Slot）</strong>为最小单位，每个变量槽最大存储32位的数据类型。对于 $64$ 位的数据类型（long、double），JVM 会为其分配两个连续的变量槽来存储。</p><p>JVM 通过索引定位的方式使用局部变量表，索引的范围从 $0$ 开始至局部变量表中最大的容量槽数量。普通方法与 static 方法在第 $0$ 个槽位的存储有所不同，非 static 方法的第 $0$ 个槽位存储方法所属对象实例的引用。</p><blockquote><p>Slot 复用？</p></blockquote><p>为了尽可能的节省栈帧空间，局部变量表中的 <strong>Slot 是可以复用</strong>的。方法中定义的局部变量，其作用域不一定会覆盖整个方法。当方法运行时，如果已经超出了某个变量的作用域，即变量失效了，那这个变量对应的 Slot 就可以交给其他变量使用，也就是所谓的 Slot 复用。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">66</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当虚拟机运行 test 方法，就会创建一个栈帧，并压入到当前线程的栈中。当运行到 <code>int a = 66</code> 时，在当前栈帧的局部变量中创建一个 Slot 存储变量 a，当运行到 <code>int b = 55</code> 时，此时已经超出变量 a 的作用域（变量 a 的作用域在{}所包含的代码块中），此时 a 就失效了，变量 a 占用的 Slot 可以交给 b 来使用，这就是 Slot 复用。</p><p>Slot 复用虽然节省了栈帧空间，但是会直接影响到系统的垃圾收集行为。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上段代码很简单，先向内存中填充了 64M 的数据，然后通知虚拟机进行垃圾回收。为了更清晰的查看垃圾回收的过程，在虚拟机的运行参数中加上 <code>-verbose:gc</code>，这个参数的作用就是打印 GC 信息。</p><p><img src="D:\blog\source\_posts\JVM内存结构\afas.png" alt="afas"></p><p>打印的GC信息如下：</p><p><img src="D:\blog\source\_posts\JVM内存结构\reh.png" alt="reh"></p><p>箭头前后的数据分别表示垃圾收集 GC 前后所有存活对象使用的内存容量，说明有70M-68M=2M 的对象容量被回收，而虚拟机没有回收这 64M 内存。为什么没有被回收？当执行 System.gc() 方法时，变量 placeholder 还在作用域范围之内，虚拟机是不会回收的，它还是“有效”的。</p><p>对上面的代码稍作修改，使其作用域“失效”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是虚拟机还是没有回收 placeholder 变量占用的 64M 内存，再对代码稍作修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 System.gc() 方法之前，加入 <code>int a = 0</code>，再执行方法，查看垃圾回收情况。</p><p><img src="D:\blog\source\_posts\JVM内存结构\qfgh.png" alt="qfgh"></p><p>发现 placeholder 变量占用的 64M 内存空间被回收了。</p><p>第一次修改中，限定了 placeholder 的作用域，但之后并没有任何对局部变量表的读写操作，placeholder 变量在局部变量表中占用的 Slot 没有被其它变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。所以 placeholder 变量没有被回收。</p><p>第二次修改后，运行到 int a = 0 时，已经超过了 placeholder 变量的作用域，此时 placeholder 在局部变量表中占用的 Slot 可以交给其他变量使用。而变量a正好复用了 placeholder 占用的 Slot，至此局部变量表中的 Slot 已经没有 placeholder 的引用了，虚拟机就回收了 placeholder 占用的 64M 内存空间。</p><h4 id="1-2-2-操作数栈"><a href="#1-2-2-操作数栈" class="headerlink" title="1.2.2 操作数栈"></a>1.2.2 操作数栈</h4><p>操作数栈的<strong>元素可以是任意的Java数据类型</strong>。方法刚开始执行时，操作数栈是空的，在方法执行过程中，通过字节码指令对操作数栈进行压栈和出栈的操作。</p><p>通常进行<strong>算数运算</strong>的时候是通过操作数栈来进行的，又或者是在调用其他方法的时候通过操作数栈进行<strong>参数传递</strong>。操作数栈可以理解为栈帧中用于计算的临时数据存储区。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStack</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        add(<span class="number">100</span>, <span class="number">98</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add 方法刚开始执行时，操作数栈是空的。首先把局部变量 $0$ 压栈，即 $100$ 入操作数栈。然后执行把局部变量 $1$ 压栈，即 $98$ 入操作数栈。接着执行弹出两个变量（$100$ 和 $98$ 出操作数栈），对 $100$ 和 $98$ 进行求和，然后将结果 $198$ 压栈。然后弹出结果（出栈）。<br>局部变量表和操作数栈的变化情况如下图：</p><p><img src="D:\blog\source\_posts\JVM内存结构\20190409205401344.jpg" alt="20190409205401344"></p><blockquote><p>栈中可能出现哪些异常？</p></blockquote><ul><li>StackOverflowError：如果采用固定大小的 Java 虚拟机栈，线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，则抛出栈溢出错误。</li><li>OutOfMemoryError：如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，则抛出内存不足。</li></ul><blockquote><p>如何设置栈参数？</p></blockquote><p>使用参数 <strong>-Xss</strong> 设置线程的最大栈空间。由于栈是<strong>线程私有</strong>的，线程数越多，占用栈空间越大。</p><p>栈的大小直接决定函数调用的最大可达深度，这也是慎用递归调用的原因。递归调用时，每次调用方法都会创建栈帧并压栈。当调用一定次数之后，所需栈的大小已经超过了虚拟机运行配置的最大栈参数，就会抛出 StackOverflowError 异常。</p><h3 id="1-3-Java堆"><a href="#1-3-Java堆" class="headerlink" title="1.3 Java堆"></a>1.3 Java堆</h3><p>堆是Java虚拟机所管理的内存中最大的一块存储区域。堆内存被所有<strong>线程共享</strong>。主要存放使用 <strong>new</strong> 关键字创建的对象。所有<strong>对象实例以及数组</strong>都要在堆上分配。垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间。</p><p>Java 堆分为<strong>年轻代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation）；年轻代又分为伊甸园（Eden）和幸存区（Survivor区）；幸存区又分为 From Survivor 空间和 To Survivor 空间。</p><p>老年代存储<strong>长期存活的对象和大对象</strong>。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发 <strong>Full GC</strong>。</p><p><strong>Full GC </strong>是清理整个堆空间，包括年轻代和老年代。如果Full GC之后，堆中仍然无法存储对象，就会抛出<strong>OutOfMemoryError </strong>异常。</p><p>Java 堆设置常用参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-Xms</td><td>堆内存初始大小</td></tr><tr><td>-Xmx（MaxHeapSize）</td><td>堆内存最大允许大小，一般不要大于物理内存的80%</td></tr><tr><td>-XX:NewSize（-Xns）</td><td>年轻代内存初始大小</td></tr><tr><td>-XX:MaxNewSize（-Xmn）</td><td>年轻代内存最大允许大小，也可以缩写</td></tr><tr><td>-XX:NewRatio</td><td>新生代和老年代的比值，值为4 表示新生代:老年代=1:4</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>年轻代中Eden区与Survivor区的容量比例值，默认为8</td></tr><tr><td>XX:+HeapDumpOnOutOfMemoryError</td><td>内存溢出时，导出堆信息到文件</td></tr><tr><td>-XX:MaxTenuringThreshold=7</td><td>表示如果在幸存区移动多少次没有被垃圾回收，进入老年代</td></tr></tbody></table></div><h3 id="1-4-方法区"><a href="#1-4-方法区" class="headerlink" title="1.4 方法区"></a>1.4 方法区</h3><p>方法区同 Java 堆一样是被所有<strong>线程共享</strong>的区间，用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。关闭 JVM 会释放方法区的内存。</p><p>JDK1.8 使用元空间 <strong>MetaSpace</strong> 替代方法区，元空间并不在 JVM 中，而是使用本地内存。元空间两个参数：</p><ul><li>MetaSpaceSize：初始化元空间大小，控制发生 GC 的阈值</li><li>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</li></ul><p>常量池是方法区的一部分，存储编译器生成的各种字面量和符号引用。</p><p>字面量就是Java中常量的意思，包括字符串，final修饰的常量和基本数据类型的值。</p><p>符号引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符。</p><blockquote><p>常量池有什么用 ？</p></blockquote><p>常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><ul><li><strong>Integer 常量池</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestIntegerCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="number">66</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> integer(<span class="number">66</span>);</span><br><span class="line">        Integer i3 = <span class="number">66</span>;</span><br><span class="line">        Integer i4 = <span class="number">66</span>;</span><br><span class="line">        Integer i5 = <span class="number">150</span>;</span><br><span class="line">        Integer i6 = <span class="number">150</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i5 == i6);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i1 和 i2 使用 new 关键字，每 new 一次都会在堆上创建一个对象，所以 <code>i1 == i2</code> 为 false。</p><p><code>Integer i3 = 66</code> 实际上有一步<strong>装箱</strong>的操作，即将 int 型的 66 装箱成 Integer，通过 Integer 的 valueOf 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Integer 的 valueOf 方法判断变量是否在 <strong>IntegerCache</strong> 的最小值（$-128$）和最大值（$127$）之间，如果在，则返回常量池中的内容，否则 new 一个 Integer 对象。而 IntegerCache 是 Integer的静态内部类，作用就是将 $[-128,127]$ 之间的数”缓存”在 IntegerCache 类的 cache 数组中(这个 Integer 数组包含 $-128$ 到 $127$ 之间的所有值)，valueOf 方法就是调用常量池的 cache 数组，将 i3、i4 变量的引用指向常量池中，没有真正的创建对象。</p><p>而 <code>i5 == i6</code> 为 false，就是因为 $150$ 不在 Integer 常量池的最大最小值之间 $[-128,127]$，从而 new 了一个对象。</p><p>IntegerCache 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;<span class="comment">//最小值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;<span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];<span class="comment">//缓存数组</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//私有化构造方法，不让别人创建它。单例模式的思想</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//类加载的时候，执行静态代码块。作用是将-128到127之间的数缓冲在cache[]数组中</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];<span class="comment">//初始化cache数组，根据最大最小值确定</span></span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)<span class="comment">//遍历将数据放入cache数组中</span></span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一段<strong>拆箱</strong>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Integer i1 = <span class="keyword">new</span> Integer(<span class="number">4</span>);</span><br><span class="line">       Integer i2 = <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">       Integer i3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">       System.out.print(i3 == i1+i2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于 i1 和 i2 是 Integer 对象，是不能使用+运算符的。首先 i1 和 i2 进行自动拆箱操作，拆箱成int后再进行数值加法运算。i3 也是拆箱后再与之比较数值是否相等的。所以 <code>i3 == i1+i2</code> 其实是比较的 int 型数值是否相等，所以为 true。</p><ul><li>String 常量池</li></ul><p>String 是由 final 修饰的类，是不可以被继承的。通常有两种方式来创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则直接将 str 引用指向常量池中的“abcd”。</span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure><p>对于 String 类，equals 方法用于比较字符串内容是否相同；== 号用于比较内存地址是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       String str2 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在栈上存放变量引用 str1，然后通过符号引用去常量池中找是否有 abcd，没有，则将 abcd 存储在常量池中，然后将 str1 指向常量池的 abcd。创建 str2 对象时，在常量池中发现已经有 abcd 了，就将 str2 引用直接指向 abcd 。所以 <code>str1 == str2</code>，指向同一个内存地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>str1 和 str2 使用 new 创建对象，两个引用指向堆中两个不同的对象，所以为 false。</p><blockquote><p>关于字符串 + 号连接问题</p></blockquote><p>对于字符串<strong>常量</strong>的 + 号连接，在程序编译期，JVM就会将其优化为 + 号连接后的值。所以在编译期其字符串常量的值就确定了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a1&quot;</span>;   </span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;   </span><br><span class="line">System.out.println((a == b)); <span class="comment">//result = true</span></span><br></pre></td></tr></table></figure><p>对于字符串<strong>引用</strong>的 + 号连接问题，由于字符串引用在编译期是无法确定下来的，在程序的运行期动态分配并创建新的地址存储对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">   String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">   String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">   System.out.print(str2 == str3);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过 jad 反编译工具反编译代码后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s2 = (<span class="keyword">new</span> StringBuilder()).append(s).append(<span class="string">&quot;b&quot;</span>).toString();</span><br><span class="line">        System.out.print(s1 = s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 new 了一个 StringBuilder 对象，然后使用 append 方法优化了 + 操作符。new 在堆上创建对象，而 <code>String s1=“ab”</code> 则是在常量池中创建对象，两个应用所指向的内存地址是不同的，所以 <code>s1 == s2</code> 结果为 false。</p><p><strong>在 for 循环中操作字符串的优化</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用+号连接字符串，每循环一次，就会新建StringBuilder对象，append后就“抛弃”了它。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果在循环外创建StringBuilder对象，在循环中使用append方法追加字符串，可以节省 n-1 次创建和销毁对象的时间。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>使用 final 修饰的字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        System.out.print(str2 == str3);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final 修饰的变量是一个常量，编译期就能确定其值，所以 <code>str1 + &quot;b&quot;</code> 就等同于 “a” + “b”，结果是 true。</p><p><strong>String 对象的 intern 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3.intern() == s);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>s3 调用 intern 方法，返回的是s3的内容 “ab” 在常量池中的地址值。所以 <code>s3.intern() == s</code> 结果为 true。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h1&gt;&lt;h2 id=&quot;1-运行时数据区&quot;&gt;&lt;a href=&quot;#1-运行时数据区&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JMM&amp;volatile关键字</title>
    <link href="http://10185102110.github.io/2021/08/08/JMM-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://10185102110.github.io/2021/08/08/JMM-volatile%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-08-08T08:55:59.000Z</published>
    <updated>2021-08-08T09:58:20.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JMM-与-volatile-关键字"><a href="#JMM-与-volatile-关键字" class="headerlink" title="JMM 与 volatile 关键字"></a>JMM 与 volatile 关键字</h1><h2 id="1-Java-内存模型-JMM"><a href="#1-Java-内存模型-JMM" class="headerlink" title="1. Java 内存模型 (JMM)"></a>1. Java 内存模型 (JMM)</h2><p><img src="D:\blog\source\_posts\JMM-volatile关键字\1.png.jpg" alt="1.png"></p><p>JMM 规定所有变量都存在主存中，每个线程又有自己的工作内存，可以理解成 CPU 上的高速缓存。所以，线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值同步回主存。</p><p><strong>主内存：</strong>主内存被所有的线程共享，对于一个共享变量，主内存中存储的就是它“本尊”。</p><p><strong>工作内存：</strong>每个线程都有自己的工作内存，对于共享变量来说，工作内存中存储的是它的“副本”。</p><p>在线程执行时，首先会从主存中 read 变量值，再 load 到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p><p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;  <span class="comment">// 假设i初值为0</span></span><br><span class="line"></span><br><span class="line">线程<span class="number">1</span>： load i from 主存    <span class="comment">// i = 0</span></span><br><span class="line">        i + <span class="number">1</span>             <span class="comment">// i = 1</span></span><br><span class="line">线程<span class="number">2</span>： load i from主存     <span class="comment">// 因为线程1还没将i的值写回主存，所以i还是0</span></span><br><span class="line">        i + <span class="number">1</span>            <span class="comment">//i = 1</span></span><br><span class="line">线程<span class="number">1</span>:  save i to 主存</span><br><span class="line">线程<span class="number">2</span>： save i to 主存</span><br></pre></td></tr></table></figure><p>如果两个线程按照上面的执行流程，那么 i 最后的值居然是 $1$。如果最后的写回生效的慢，再读取 i 的值，都可能是 $0$，这就是缓存不一致问题。</p><p>JMM 主要就是围绕着如何在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这 $3$ 个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而 volatile 跟可见性和有序性都有关。</p><h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>Java 中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要么做完，要么就没有执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">2</span>; <span class="comment">// 读取操作，是原子的</span></span><br><span class="line">j = i; <span class="comment">// 先读取i的值，再赋值给j，不是原子的</span></span><br><span class="line">i++;   <span class="comment">// 读取i的值，定义常量1，i加1，写回内存，不是原子的</span></span><br><span class="line">i = i + <span class="number">1</span>; <span class="comment">// 等效于i++</span></span><br></pre></td></tr></table></figure><p>JMM 只实现了基本的原子性，像上面 i++ 那样的操作，必须借助于 synchronized 和 Lock 来保证整块代码的原子性。线程在释放锁之前，必然会把 i 的值刷回到主存的。</p><h3 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2 可见性"></a>1.2 可见性</h3><p>一个线程修改共享变量，能够被其它线程同时感知。</p><p>Java 利用 volatile 来提供可见性。 当一个变量被 volatile 修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。其实通过 synchronized 和 Lock 也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是 synchronized 和 Lock 的开销都更大。 </p><h3 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3 有序性"></a>1.3 有序性</h3><p>JMM 是允许编译器和处理器对指令重排序的，但是规定了 as-if-serial 语义，即不管怎么重排序，程序的执行结果不能改变。</p><p>比如下面的程序段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;    <span class="comment">//A</span></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1</span>;        <span class="comment">//B</span></span><br><span class="line"><span class="keyword">double</span> s= pi * r * r;<span class="comment">//C</span></span><br></pre></td></tr></table></figure><p>上面的语句，可以按照 A-&gt;B-&gt;C 执行，也可以按照 B-&gt;A-&gt;C 的顺序执行，因为 A、B 是两句独立的语句，而 C 则依赖于 A、B，所以 A、B 可以重排序，但是 C 却不能排到 A、B 的前面。JMM 保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">bool flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程 $1$ 先执行 write，随后线程 $2$ 再执行multiply，最后 ret 的值一定是 $4$ 吗？</p><p><img src="D:\blog\source\_posts\JMM-volatile关键字\2.png.jpg" alt="2.png"></p><p>如图所示，write 方法里的 $1$ 和 $2$ 做了重排序，线程 $1$ 先对 flag 赋值为 true，随后执行到线程 $2$，ret 直接计算出结果，再到线程 $1$，这时候 a 才赋值为 $2$。这时候可以为 flag 加上 volatile 关键字，禁止重排序，可以确保程序的<strong>有序性</strong>，也可以上重量级的 synchronized 和 Lock 来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p><h2 id="2-volatile-关键字如何满足并发编程的三大特性？"><a href="#2-volatile-关键字如何满足并发编程的三大特性？" class="headerlink" title="2. volatile 关键字如何满足并发编程的三大特性？"></a>2. volatile 关键字如何满足并发编程的三大特性？</h2><p>volatile 之所以能有这样的特性，得益于 Java 当中的先行发生原则。</p><p><strong>先行发生原则</strong>（happens-before）：如果一个事件必须发生在另一个事件之前，结果必须反映，即使这些事件是乱序执行的。这里的事件指的是各种指令操作，比如读写、初始化、锁。</p><p><code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code> 定义了如下 happens-before 规则：</p><ul><li><p>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</p></li><li><p>监视器锁规则：对一个线程的解锁，happens-before 于随后对这个线程的加锁。</p></li><li><p>volatile 变量规则： 对一个 volatile 域的写，happens-before 于后续对这个 volatile 域的读。</p></li><li><p>传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C。</p></li><li><p>start() 规则： 如果线程 A 执行操作 ThreadB_start()(启动线程B) , 那么 A 线程的 ThreadB_start() happens-before 于 B 中的任意操作。</p></li><li><p>join()原则：如果 A 执行 ThreadB.join() 并且成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。</p></li><li><p>interrupt() 原则： 对线程 interrupt() 方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测是否有中断发生。</p></li><li><p>finalize() 原则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始。</p></li></ul><p>$(1)$ 规定线程每次修改变量副本后<strong>立刻同步到主内存</strong>中，用于保证其它线程可以看到自己对变量的修改。</p><p>$(2)$ 规定线程每次使用变量前，先从主内存中<strong>刷新最新的值</strong>到工作内存，用于保证能看见其它线程对变量修改的最新值。</p><p>$(3)$ 为了实现可见性内存语义，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来<strong>防止指令重排序</strong>。</p><blockquote><p>总结 volatile 的两个特性</p></blockquote><ul><li>保证变量在线程之间的可见性，不能保证原子性。</li><li>阻止编译和运行时的指令重排，保证有序性。</li></ul><h2 id="3-volatile-底层实现机制"><a href="#3-volatile-底层实现机制" class="headerlink" title="3. volatile 底层实现机制"></a>3. volatile 底层实现机制</h2><p>生成汇编代码可以发现 volatile 关键字的代码多出一个 lock 前缀指令，它相当于一个内存屏障。</p><p>内存屏障提供了以下功能： </p><ul><li>重排序时不能把后面的指令重排序到内存屏障之前的位置 。</li><li>写入动作会引起别的 CPU 或者别的内核无效化其 Cache，相当于让新写入的值对别的线程可见。</li><li>使得本 CPU 的 Cache 写入内存。</li></ul><h2 id="4-volatile-和-synchronized-区别"><a href="#4-volatile-和-synchronized-区别" class="headerlink" title="4.volatile 和 synchronized 区别"></a>4.volatile 和 synchronized 区别</h2><ul><li>synchronized 关键字解决的是<strong>执行控制</strong>的问题，它会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被 synchronized 关键字保护的代码块无法被其它线程访问，也就无法并发执行。更重要的是，synchronized 还会创建一个内存屏障，内存屏障指令保证了所有 CPU 操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都 happens-before 于随后获得这个锁的线程的操作。</li></ul><ul><li>volatile 关键字解决的是<strong>内存可见性</strong>的问题，会使得所有对 volatile 变量的读写都会直接刷到主存，即保证了变量的可见性。使用 volatile 关键字仅能实现对原始变量(如 boolen、 short 、int 、long 等)操作的原子性，但 volatile 不能保证复合操作的原子性，比如<code>i++</code>。</li><li>volatile 本质是在告诉 jvm 当前变量在工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li></ul><h2 id="5-volatile-的应用"><a href="#5-volatile-的应用" class="headerlink" title="5. volatile 的应用"></a>5. volatile 的应用</h2><p><strong>(1)</strong> 状态量标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> bool flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;              <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;        <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">//3</span></span><br><span class="line">        <span class="keyword">int</span> ret = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种对变量的读写操作，标记为 volatile 可以保证修改对线程立刻可见。比 synchronized,Lock 有一定的效率提升。</p><p><strong>(2)</strong> 单例模式，双重检查锁定(DCL)</p><ul><li><p>经典的懒汉式单例实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程的情况下，多个线程有可能会同时进入 <code>if (singleton == null)</code> ，执行了多次 <code>singleton = new Singleton()</code>，从而破坏单例。</p></li><li><p>允许指令重排序的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码在检测到 <code>singleton==null</code> 后，会在同步块中再次判断，可以保证同一时间只有一个线程可以初始化单例。但仍然存在问题，原因就是 Java 中 <code>singleton = new Singleton()</code> 语句并不是一个原子指令，而是由三步组成：</p><ol><li>为对象分配内存</li><li>初始化对象</li><li>将对象的内存地址赋给引用</li></ol><p>但是经过<strong>指令重排序</strong>后，会变成：</p><ol><li>为对象分配内存</li><li>将对象的内存地址赋给引用（会使得 <code>singleton != null</code>）</li><li>初始化对象</li></ol><p>所以存在一种情况，当线程 A 已经将内存地址赋给引用时，但实例对象并没有完全初始化，同时线程 B 判断 singleton 已经不为 null，就会导致 B 线程<strong>访问到未初始化的变量</strong>从而产生错误。</p></li><li><p>避免初始化指令重排序的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码对 singleto 变量添加了 volatile 修饰，可以阻止局部指令重排序。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JMM-与-volatile-关键字&quot;&gt;&lt;a href=&quot;#JMM-与-volatile-关键字&quot; class=&quot;headerlink&quot; title=&quot;JMM 与 volatile 关键字&quot;&gt;&lt;/a&gt;JMM 与 volatile 关键字&lt;/h1&gt;&lt;h2 id=&quot;1</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池&amp;Executor框架</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0-Executor%E6%A1%86%E6%9E%B6/</id>
    <published>2021-08-08T08:55:31.000Z</published>
    <updated>2021-08-08T09:58:11.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程池-amp-Executor框架"><a href="#Java-线程池-amp-Executor框架" class="headerlink" title="Java 线程池 &amp; Executor框架"></a>Java 线程池 &amp; Executor框架</h1><h2 id="1-Executor-框架基础"><a href="#1-Executor-框架基础" class="headerlink" title="1. Executor 框架基础"></a>1. Executor 框架基础</h2><blockquote><p>为什么需要线程池？</p></blockquote><p>在 Java中，使用线程来执行异步任务时，线程的创建和销毁需要一定的开销，如果我们为每一个任务创建一个新的线程来执行的话，那么这些线程的创建与销毁将消耗大量的计算资源，这样的方式可能会使处于高负荷状态的应用最终崩溃。</p><p>我们将在线程池中创建若干条线程，当有任务需要执行时就从该线程池中获取一条线程来执行任务，如果一时间任务过多，超出线程池的线程数量，那么后面的线程任务就进入一个等待队列进行等待，直到线程池有线程处于空闲时才从等待队列获取要执行的任务进行处理，这样就大大减少了线程创建和销毁的开销。</p><h3 id="1-1-两级调度模型"><a href="#1-1-两级调度模型" class="headerlink" title="1.1 两级调度模型"></a>1.1 两级调度模型</h3><p>在 Java 线程启动时会创建一个本地操作系统线程，当该 Java 线程终止时，这个操作系统线程也会被回收。而每一个 Java 线程都会被一对一映射为本地操作系统的线程，操作系统会调度所有的线程并将它们分配给可用的 CPU。</p><p>在上层，Java 多线程程序把应用分为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这种两级调度模型如下图所示：</p><p><img src="D:\blog\source\_posts\Java线程池-Executor框架\20160314222941341.png" alt="20160314222941341"></p><p>应用程序通过 Executor 框架控制上层的调度，而下层的调度由操作系统内核控制。</p><h3 id="1-2-Executor-框架的结构"><a href="#1-2-Executor-框架的结构" class="headerlink" title="1.2 Executor 框架的结构"></a>1.2 Executor 框架的结构</h3><p>Executor 框架的结构主要包括三部分：</p><ul><li>任务：包括被执行任务需要实现的接口：Runnable 接口或 Callable 接口。</li><li>任务的执行：包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 EexcutorService 接口。Executor 的两个关键类实现了 ExecutorService 接口（ThreadPoolExecutor 和ScheduledThreadPoolExecutor）。</li><li>异步计算的结果：包括接口 Future 和实现 Future 接口的 FutureTask 类。</li></ul><p><img src="D:\blog\source\_posts\Java线程池-Executor框架\20160314223043311.png" alt="20160314223043311"></p><p>Extecutor 是一个接口，它是 Executor 框架的基础，它将任务的提交与任务的执行分离开来。<br>ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。<br>ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<br>Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果。<br>Runnable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或者 ScheduledThreadPoolExecutor 执行。区别就是 Runnable 无法返回执行结果，而 Callable 可以返回执行结果。</p><h3 id="1-3-ThreadPoolExecutor"><a href="#1-3-ThreadPoolExecutor" class="headerlink" title="1.3 ThreadPoolExecutor"></a>1.3 ThreadPoolExecutor</h3><p>ThreadPoolExecutor 是线程的真正实现，通常使用工厂类 Executors 来创建，但它的构造方法提供了一系列参数来配置线程池.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>corePoolSize</strong>：线程池的核心线程数，默认核心线程会一直在线程池中存活，即使它们处理闲置状态。</p><p><strong>maximumPoolSize</strong>：线程池所能容纳的最大线程数量，当活动线程数到达该数值后，后续的新任务将被阻塞。</p><p><strong>keepAliveTime</strong>：非核心线程闲置时的超时时长，超过时长非核心线程就会被回收。当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 true 时，keepAliveTime 同样会作用于核心线程。</p><p><strong>unit</strong>：用于指定 keepAliveTime 参数的时间单位。常用的有 TimeUnit.MILLISECONDS(毫秒)，TimeUnit.SECONDS(秒)以及 TimeUnit.MINUTES(分钟)等。</p><p><strong>workQueue</strong>：线程池中的任务队列，通过线程池的 execute 方法提交的 Runnable 对象会存储在这个队列中。</p><p><strong>threadFactory</strong>：线程工厂，为线程池提供创建新线程的功能。ThreadFactory 是一个接口，它只有一个方法：<code>Thread newThread(Runnable r)</code>。</p><p><strong>defaultHandler</strong>：RejectExecutionHandler，这个参数表示当 ThreadPoolExecutor 已经关闭或者已经饱和时，execute 方法将会调用 Handler 的 rejectExecution 方法来通知调用者，默认情况下是抛出一个RejectExecutionException 异常。</p><p>ThreadPoolExecutor 执行任务时的大致规则：</p><ol><li>如果线程池的数量还未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li><li>如果线程池中的线程数量已经达到或者超出核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li><li>如果在步骤 2 中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li><li>如果在步骤 3 中线程数量已经达到线程池规定的最大值，那么就会拒绝执行此任务， ThreadPoolExecutor 会调用 RejectExecutionHandler 的 rejectExecution方法来通知调用者。</li></ol><h2 id="2-常见线程池"><a href="#2-常见线程池" class="headerlink" title="2. 常见线程池"></a>2. 常见线程池</h2><h3 id="2-1-FixedThreadPool"><a href="#2-1-FixedThreadPool" class="headerlink" title="2.1 FixedThreadPool"></a>2.1 FixedThreadPool</h3><p>FixedThreadPool 模式会使用一个优先固定数目的线程来处理若干数目的任务。</p><p>创建 FixedThreadPool 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p> FixedThreadPool 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>corePoolSize 和 maximumPoolSize 参数都被设置为 nThreads，即核心线程数和最大线程数是一样的。</p><p>keepAliveTime 设置为 $0$L，就说明非核心线程会立即被终止。</p><p>FixedThreadPool 的 execute() 方法的运行流程：</p><p><img src="D:\blog\source\_posts\Java线程池-Executor框架\20160314223220078.png" alt="20160314223220078"></p><ol><li>如果当前运行线程数少 corePoolSize，则创建一个新的线程来执行任务。</li><li>如果当前线程池的运行线程数等于 corePoolSize，那么后面提交的任务将加入 LinkedBlockingQueue。</li><li>线程在执行完图中的 $1$ 后，会在循环中反复从 LinkedBlockingQueue 获取任务来执行。</li><li>FixedThreadPool 使用无界队列 LinkedBlockingQueue 作为线程池的工作队列（队列容量为Integer.MAX_VALUE），所以运行中的 FixedThreadPool 不会拒绝任务，那么也不会调用 RejectExecutionHandler 的 rejectExecution 方法抛出异常。</li></ol><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;   </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">3</span>;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;  <span class="comment">//线程号 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">my</span><span class="params">()</span> </span>&#123;&#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">my</span><span class="params">(<span class="keyword">int</span> countDown)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.countDown = countDown;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#Thread&quot;</span> + id + <span class="string">&quot;(&quot;</span> +   </span><br><span class="line">            (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">&quot;my!&quot;</span>) + <span class="string">&quot;) &quot;</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            System.out.println(status());   </span><br><span class="line">            Thread.yield();   </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;      </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//三个线程来执行五个任务   </span></span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">3</span>);      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;  </span><br><span class="line">        exec.shutdown();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#Thread0(<span class="number">2</span>) </span><br><span class="line">#Thread1(<span class="number">2</span>) </span><br><span class="line">#Thread1(<span class="number">1</span>) </span><br><span class="line">#Thread1(my!) </span><br><span class="line">#Thread2(<span class="number">2</span>) </span><br><span class="line">#Thread3(<span class="number">2</span>) </span><br><span class="line">#Thread2(<span class="number">1</span>) </span><br><span class="line">#Thread2(my!) </span><br><span class="line">#Thread3(<span class="number">1</span>) </span><br><span class="line">#Thread0(<span class="number">1</span>) </span><br><span class="line">#Thread3(my!) </span><br><span class="line">#Thread4(<span class="number">2</span>) </span><br><span class="line">#Thread0(my!) </span><br><span class="line">#Thread4(<span class="number">1</span>) </span><br><span class="line">#Thread4(my!) </span><br></pre></td></tr></table></figure><h3 id="2-2-CachedThreadPool"><a href="#2-2-CachedThreadPool" class="headerlink" title="2.2 CachedThreadPool"></a>2.2 CachedThreadPool</h3><p>CachedThreadPool 首先会按照需要创建足够多的线程来执行任务。随着程序执行的过程，有的线程执行完任务可以被重新循环使用时，才不再创建新的线程。</p><p>创建 CachedThreadPool 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService cachedThreadPool=Executors.newCachedThreadPool(); </span><br></pre></td></tr></table></figure><p>CachedThreadPool 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool 的 corePoolSize 被设置为 $0$，而 maximumPoolSize 被设置 Integer.MAX_VALUE，即 maximumPoolSize 是无界的，而 keepAliveTime 被设置为 60L，单位为秒。也就是空闲线程等待时间最长为 $60$ 秒，超过该时间将会被终止。CachedThreadPool 使用的是没有容量的 SynchronousQueue 作为线程池的工作队列，但其 maximumPoolSize 是无界的，也就是意味着如果主线程提交任务的速度高于 maximumPoolSize 中线程处理任务的速度时 CachedThreadPool 将会不断的创建新的线程，在极端情况下， CachedThreadPool 会因为创建过多线程而耗尽 CPU 和内存资源。<br>CachedThreadPool 的 execute() 方法的运行流程：</p><p><img src="D:\blog\source\_posts\Java线程池-Executor框架\20160314223430065.png" alt="20160314223430065"></p><ol><li>首先执行 SynchronousQueue.offer(Runnable task)，添加一个任务。如果当前 CachedThreadPool 中有空闲线程正在执行 SynchronousQueue.poll，那么主线程执行 offer 操作与空闲线程执行 poll 操作配对成功，主线程把任务交给空闲线程执行，execute() 方法执行完成，否则进入第 2 步。</li><li>当 CachedThreadPool 初始线程数为空时，或者当前没有空闲线程，CachedThreadPool 会创建一个新的线程来执行任务， execute() 方法执行完成。</li><li>在步骤 2 中创建的新线程将任务执行完成后，会执行 SynchronousQueue.poll，这个 poll 操作会让空闲线程最多在 SynchronousQueue 中等待 $60$ 秒，如果 $60$ 秒内主线程提交了一个新任务，那么这个空闲线程将会执行主线程提交的新任务，否则，这个空闲线程将被终止。因此长时间保持空闲的 CachedThreadPool 是不会使用任何资源的。</li></ol><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;   </span><br><span class="line">        exec.shutdown();       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="2-3-SingleThreadExecutor"><a href="#2-3-SingleThreadExecutor" class="headerlink" title="2.3 SingleThreadExecutor"></a>2.3 SingleThreadExecutor</h3><p>SingleThreadExecutor 模式只会创建一个线程。如果多个任务被提交给 SingleThreadExecutor，那么这些任务会被保存在一个队列中，并且会按照任务提交的顺序，一个先执行完成再执行另外一个线程。这种特点可以用来处理共享资源的问题而不需要考虑同步问题。</p><p>创建 SingleThreadExecutor 对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService singleThreadExecutor=Executors.newSingleThreadExecutor(); </span><br></pre></td></tr></table></figure><p>SingleThreadExecutor 创建方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从静态方法可以看出 SingleThreadExecutor 的 corePoolSize 和 maximumPoolSize 被设置为 $1$，其他参数则与 FixedThreadPool 相同。</p><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">        ExecutorService exec = Executors.newSingleThreadExecutor();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;   </span><br><span class="line">            exec.execute(<span class="keyword">new</span> my());   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="2-4-适用场景"><a href="#2-4-适用场景" class="headerlink" title="2.4 适用场景"></a>2.4 适用场景</h3><p>FixedThreadPool：适合为了满足资源管理需求，而需要限制当前线程的数量的应用场景，它适用于负载比较重的服务器。</p><p>CachedThreadPool：大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者负载较轻的服务器。SingleThreadExecutor：适用于需要保证执行顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的场景。</p><h2 id="3-ScheduledThreadPoolExecutor"><a href="#3-ScheduledThreadPoolExecutor" class="headerlink" title="3. ScheduledThreadPoolExecutor"></a>3. ScheduledThreadPoolExecutor</h2><h3 id="3-1-ScheduledThreadPoolExecutor-运行机制"><a href="#3-1-ScheduledThreadPoolExecutor-运行机制" class="headerlink" title="3.1 ScheduledThreadPoolExecutor 运行机制"></a>3.1 ScheduledThreadPoolExecutor 运行机制</h3><p>ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor。它主要用来在给定的延迟之后执行任务，或者定期执行任务。ScheduledThreadPoolExecutor 的功能与 Timer 类似，但比 Timer 更强大，更灵活，Timer 对应的是单个后台线程，而 ScheduledThreadPoolExecutor 可以在构造函数中指定多个对应的后台线程数。</p><p>ScheduledThreadPoolExecutor 的运行机制：</p><p><img src="D:\blog\source\_posts\Java线程池-Executor框架\20160314223650662.png" alt="20160314223650662"></p><ol><li>当调用 ScheduledThreadPoolExecutor 的 <code>scheduleAtFixedRate()</code>方法或者 <code>scheduleWithFixedDelay()</code> 方法时，会向 DelayQueue 添加一个实现了 RunnableScheduledFuture 接口的 ScheduleFutureTask。DelayQueue 是一个无界队列。</li><li>线程池中的线程从 DelayQueue 中获取 ScheduleFutureTask，然后执行任务。</li></ol><h3 id="3-2-ScheduledThreadPoolExecutor-的创建"><a href="#3-2-ScheduledThreadPoolExecutor-的创建" class="headerlink" title="3.2 ScheduledThreadPoolExecutor 的创建"></a>3.2 ScheduledThreadPoolExecutor 的创建</h3><p>Executors 可以创建两种类型的 ScheduledThreadPoolExecutor。</p><ul><li><p>ScheduledThreadPoolExecutor：可以执行多线程任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPoolExecutor=Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p>SingleThreadScheduledExecutor：可以执行单条线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService singleThreadScheduledExecutor=Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3-ScheduledThreadPoolExecutor-案例"><a href="#3-3-ScheduledThreadPoolExecutor-案例" class="headerlink" title="3.3 ScheduledThreadPoolExecutor 案例"></a>3.3 ScheduledThreadPoolExecutor 案例</h3><p>首先创建一个 Runnable 对象，然后使用 ScheduledThreadPoolExecutor 的 Scheduled() 来执行延迟任务，输出执行时间。</p><p><strong>$(1)$ 延迟执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay, TimeUnit unit);</span><br></pre></td></tr></table></figure><p><strong>command</strong>：一个实现 Runnable 接口的类。</p><p><strong>delay</strong>：延迟时间。</p><p><strong>unit</strong>： 用于指定 keepAliveTime 参数的时间单位。</p><p>这个方法会返回 ScheduledFuture 实例，用于获取线程状态信息和延迟时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName()+<span class="string">&quot; Start. Time = &quot;</span>+getNowDate());</span><br><span class="line">     threadSleep();</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">&quot; End. Time = &quot;</span>+getNowDate());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sleep 3秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadSleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNowDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line">  SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">  String ctime = formatter.format(currentTime); </span><br><span class="line">  <span class="keyword">return</span> ctime;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Current Time = &quot;</span>+getNowDate());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            my worker = <span class="keyword">new</span> my();</span><br><span class="line">            <span class="comment">//延迟10秒后执行</span></span><br><span class="line">            scheduledThreadPool.schedule(worker, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    scheduledThreadPool.shutdown();</span><br><span class="line">    <span class="keyword">while</span>(!scheduledThreadPool.isTerminated())&#123;</span><br><span class="line">        <span class="comment">//wait for all tasks to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getNowDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line">  SimpleDateFormat formatter; </span><br><span class="line">    formatter = <span class="keyword">new</span> SimpleDateFormat (<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>); </span><br><span class="line">    String ctime = formatter.format(currentTime); </span><br><span class="line">  <span class="keyword">return</span> ctime;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Current Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">10</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">21</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">22</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">23</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">24</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">25</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = <span class="number">2021</span>-08-<span class="number">07</span> <span class="number">18</span>:<span class="number">11</span>:<span class="number">26</span></span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><p>线程任务确实在 $10$ 秒延迟后才开始执行，这就是 schedule() 方法的使用。</p><p><strong>$(2)$ 周期性执行</strong></p><ul><li><p>scheduleAtFixedRate 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit)</span><br></pre></td></tr></table></figure><p>scheduleAtFixedRate 方法的作用是预定在初始的延迟结束后，周期性地执行给定的任务，周期长度为 period，其中 initialDelay 为初始延迟。</p></li><li><p>scheduleWithFixedDelay 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> delay,TimeUnit unit);</span><br></pre></td></tr></table></figure><p>scheduleWithFixedDelay 方法的作用是预定在初始的延迟结束后周期性地执行给定任务，在一次调用完成和下一次调用开始之间有长度为 delay 的延迟， 其中 initialDelay 为初始延迟。</p></li></ul><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> ScheduledThreadPoolExecutor se = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> ScheduledTask();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedPeriodSchedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设定可以循环执行的runnable,初始延迟为0，这里设置的任务的间隔为5秒</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">se.scheduleAtFixedRate(<span class="keyword">new</span> FixedSchedule(), <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fixedPeriodSchedule();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSchedule</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  当前时间：&quot;</span>+<span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-1  当前时间：Sat Aug 07 19:10:58 CST 2021</span><br><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-1  当前时间：Sat Aug 07 19:11:03 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-4  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-5  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-3  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br><span class="line">当前线程：pool-1-thread-2  当前时间：Sat Aug 07 19:11:08 CST 2021</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-线程池-amp-Executor框架&quot;&gt;&lt;a href=&quot;#Java-线程池-amp-Executor框架&quot; class=&quot;headerlink&quot; title=&quot;Java 线程池 &amp;amp; Executor框架&quot;&gt;&lt;/a&gt;Java 线程池 &amp;amp; </summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java线程安全</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</id>
    <published>2021-08-08T08:51:52.000Z</published>
    <updated>2021-08-08T09:58:02.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程安全"><a href="#Java-线程安全" class="headerlink" title="Java 线程安全"></a>Java 线程安全</h1><h2 id="1-线程安全等级"><a href="#1-线程安全等级" class="headerlink" title="1. 线程安全等级"></a>1. 线程安全等级</h2><p>根据线程的安全程度由强到弱，可以分为 $5$ 个等级。</p><ul><li><p>不可变</p><p>在 Java 中，不可变对象一定是线程安全的，比如 final 关键字修饰的数据不可修改，比如 String、Long、Integer。</p></li><li><p>绝对的线程安全</p><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。如 Random 、ConcurrentHashMap、Concurrent 集合、atomic。</p></li><li><p>相对的线程安全</p><p>通常来说线程是安全的，但对于一些特定顺序的连续调用就可能需要在调用端使用额外的同步手段来保证调用的正确性。大部分线程都属于这种类型，如 vector。</p></li><li><p>线程兼容</p><p>对象本身不提供线程安全机制，但是通过外部同步，可以在并发环境使用， 如 ArrayList、HashMap。</p><p>在使用这些对象的时候，都要考虑是否会发生线程安全问题。</p></li><li><p>线程对立</p><p>无论是否采用同步措施，都无法在并发中使用。</p></li></ul><h2 id="2-线程安全的实现方法"><a href="#2-线程安全的实现方法" class="headerlink" title="2. 线程安全的实现方法"></a>2. 线程安全的实现方法</h2><p><img src="D:\blog\source\_posts\Java线程安全\20180315101631748.jpg" alt="20180315101631748"></p><h3 id="1-同步方案"><a href="#1-同步方案" class="headerlink" title="(1) 同步方案"></a>(1) 同步方案</h3><p>同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用。</p><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>互斥是实现同步的一种手段，比如临界区、互斥量和信号量。</p><p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字。synchronized 是独占锁，可重入，加锁和解锁的过程自动进行，不必担心最后是否释放锁，易于操作，但不够灵活。synchronized 不可响应中断，一个线程获取不到锁就一直等着。</p><p>ReentrantLock 也是通过互斥来实现同步。ReentrantLock 也是独占锁，也可重入，加锁和解锁的过程需要手动进行，且次数需一样，否则其他线程无法获得锁，不易操作，但非常灵活。ReentrantLock 可以响应中断，可以实现公平锁机制(在锁上等待时间最长的线程将获得锁的使用权)。</p><p>ReentrantLock 的简单使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; test(),<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; test(),<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A获取锁</span><br><span class="line">线程A释放锁</span><br><span class="line">线程B获取锁</span><br><span class="line">线程B释放锁</span><br></pre></td></tr></table></figure><p>互斥同步最主要的问题就是进行<strong>线程阻塞和唤醒</strong>所带来的性能问题，因此这种同步也成为阻塞同步。</p><p>互斥同步属于一种<strong>悲观的并发策略</strong>，无论共享数据是否真的会出现竞争，它都要进行加锁。</p><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p><strong>CAS</strong>：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止，是一种<strong>乐观的并发策略</strong>。</p><p>CAS 是英文单词 Compare And Swap 的缩写，翻译过来就是比较并替换。</p><p>CAS机制当中使用了3个基本操作数：内存地址 V，旧的预期值 A，要修改的新值 B。更新一个变量的时候，只有当变量的预期值 A 和内存地址 V 当中的实际值相同时，才会将内存地址 V 对应的值修改为 B。</p><p>举个例子：</p><p>在内存地址 $V$ 中，存储着值为 $10$ 的变量。此时线程 $1$ 想把变量的值 $+1$，对线程 $1$ 来说，旧的预期值 $A=10$ ，要修改的新值 $B=11$。在线程 $1$ 要提交更新之前，线程 $2$ 抢先一步，把内存地址 $V$ 中的变量值更新成 $11$。线程 $1$ 开始提交更新，发现 $A$ 不等于 $V$ 的实际值，提交失败。线程 $1$ 重新获取内存地址 $V$ 的当前值，并重新计算想要修改的新值。此时对线程 $1$ 来说，$A=11$，$B=12$，这个重新尝试的过程被称为自旋。这次比较幸运，没有其他线程改变地址 $V$ 的值。线程 $1$ 进行 Compare，发现 $A$ 和地址 $V$ 的实际值是相等的。线程 $1$ 进行 SWAP，把地址 $V$ 的值替换为 $B$，也就是 $12$。</p><p><strong>Atomic</strong> 包下的原子类是基于 CAS 实现的。原子操作类，指的是 java.util.concurrent.atomic 包下，一系列以 Atomic 开头的包装类。例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>。它们分别用于<code>Boolean</code>，<code>Integer</code>，<code>Long</code>类型的原子性操作。</p><p>下面是一个无阻塞多线程争抢资源的模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyType</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyType my = <span class="keyword">new</span> MyType();</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  flag:&quot;</span>+flag.get());</span><br><span class="line">        <span class="keyword">if</span> (flag.compareAndSet(<span class="keyword">true</span>,<span class="keyword">false</span>))&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;开始操作并使flag为&quot;</span>+flag.get());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            flag.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重试机制:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  flag:&quot;</span>+flag.get());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">0</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">0</span>开始操作并使flag为<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">重试机制:Thread-<span class="number">1</span>  flag:<span class="keyword">false</span></span><br><span class="line">Thread-<span class="number">1</span>  flag:<span class="keyword">true</span></span><br><span class="line">Thread-<span class="number">1</span>开始操作并使flag为<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p><code>compareAndSet(true,false)</code> 方法要拆成 compare(true) 方法和 Set(false) 方法理解，是 compare(true) 等于 true 后，就马上设置共享内存为 false。</p><p>CAS 的缺点：</p><ol><li>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给 CPU 带来很大的压力。</li><li>CAS 机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证 $3$ 个变量共同进行原子性的更新，就不得不使用 Synchronized 了。</li><li>无法解决 ABA 问题。ABA 就是一个值由 A 变为 B，再由 B 变为 A，使用 CAS 操作无法感知到该种情况下出现的变化，带来的后果很严重，比如银行内部员工，从系统挪走一百万，之后还了回来，系统却感知不到。</li></ol><p>解决 ABA 可以使每一次修改都带上时间戳，以记录版本号的形式使得 CAS 感知到这种狸猫换太子的操作。Java 提供了 AtomicStampedReference 类来解决，该类除了指定旧值与期盼值，还要指定旧的版本号与期盼的版本号。该类的 compareAndSet 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h3 id="2-无同步方案"><a href="#2-无同步方案" class="headerlink" title="(2) 无同步方案"></a>(2) 无同步方案</h3><p>如果一个方法不涉及共享数据，那它自然不需要任何同步操作去保证正确性，因此有一些代码天生就是线程安全的。</p><h4 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h4><p>可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><h4 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h4><p>如果一段代码中所需的数据必须与其他代码共享，那就看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的<strong>可见范围</strong>限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。</p><p>如“生产者-消费者”模式、Web交互模型中的“一个请求对应一个服务器线程“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-线程安全&quot;&gt;&lt;a href=&quot;#Java-线程安全&quot; class=&quot;headerlink&quot; title=&quot;Java 线程安全&quot;&gt;&lt;/a&gt;Java 线程安全&lt;/h1&gt;&lt;h2 id=&quot;1-线程安全等级&quot;&gt;&lt;a href=&quot;#1-线程安全等级&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程基础</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-08T08:51:27.000Z</published>
    <updated>2021-08-08T09:57:52.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h1><h2 id="1-进程，线程，多线程"><a href="#1-进程，线程，多线程" class="headerlink" title="1. 进程，线程，多线程"></a>1. 进程，线程，多线程</h2><ul><li>进程是资源分配的最小单位，有自己独立的地址空间，一个进程可以创建多个线程。</li><li>线程是程序执行和CPU调度的最小单位，线程共享本进程的地址空间，分为用户级线程和内核级线程。</li><li>一个进程如果只有一个线程，称为单线程程序；如果有多个线程，称为多线程程序。</li></ul><h2 id="2-多线程的创建与启动"><a href="#2-多线程的创建与启动" class="headerlink" title="2. 多线程的创建与启动"></a>2. 多线程的创建与启动</h2><p>创建多线程有两种方法，一种是继承Thread类重写run方法，另一种是实现Runnable接口重写run方法。</p><ul><li><p>继承Thread类重写run方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByEx</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I&#x27;m a thread that extends Thread!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadByRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;I&#x27;m a thread that implements Runnable !&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//继承Thread启动的方法</span></span><br><span class="line">ThreadByEx t1=<span class="keyword">new</span> ThreadByEx();</span><br><span class="line">t1.start();<span class="comment">//启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现Runnable启动线程的方法</span></span><br><span class="line">ThreadByRunnable r = <span class="keyword">new</span> ThreadByRunnable();</span><br><span class="line">Thread t2 =<span class="keyword">new</span> Thread(r);</span><br><span class="line">t2.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>start()</code> 方法后并不是是立即的执行多线程的代码，而是使该线程变为可运行态，什么时候运行多线程代码是由操作系统决定的。</p></li></ul><h2 id="3-中断线程"><a href="#3-中断线程" class="headerlink" title="3. 中断线程"></a>3. 中断线程</h2><p>线程的 <code>thread.interrupt()</code> 方法向线程发送中断请求，将会设置该线程的中断状态位，即设置为 <code>true</code>，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为 <code>true</code>）。它并不像 <code>stop</code> 方法那样会中断一个正在运行的线程。(在 Java 早期版本中有一个 <code>stop</code> 方法，其他线程可以调用它终止线程，但是这个方法现在已经被弃用了，因为会造成一些线程不安全的问题)</p><p>判断线程是否被中断：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted() &amp;&amp; more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">    <span class="keyword">do</span> more work</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread.currentThread().isInterrupted()方法不会清除中断标示位，而Thread.interrupted()方法调用后会将中断标示位清除，即重新设置为false来判断。</span></span><br></pre></td></tr></table></figure><p>如果一个线程处于阻塞状态，即线程在检查中断标示时发现中断标示为 <code>true</code>，则会在阻塞方法（<code>sleep</code>、<code>join</code>、<code>wait</code>、1.5 中的 <code>condition.await</code> 及可中断的通道上的 I/O 操作方法）调用处抛出<code>InterruptedException</code> 异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为<code>false</code>。  </p><p>中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断。某些线程非常重要，以至于它们应该不理会中断，而是在处理完抛出的异常之后继续执行。但是更普遍的情况是，一个线程将把中断看作一个终止请求，这种线程的 <code>run()</code> 方法遵循如下形式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> more work </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="comment">//线程在wait或sleep期间被中断了</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//线程结束前做一些清理工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>try</code> 在 <code>while</code> 循环里时，应该在 <code>catch</code> 块里重新设置一下中断标示，因为抛出 <code>InterruptedException</code> 异常后，中断标示位会自动清除，此时应该这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            sleep(delay); <span class="comment">//Thread.sleep()</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();<span class="comment">//重新设置中断标示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>底层中断异常的处理</strong>，最好是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySubTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    sleep(delay);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>Thread.interrupt()</code> 中断非阻塞状态线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example1 thread = <span class="keyword">new</span> Example1();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        <span class="comment">// 发出中断请求</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔一秒检测是否设置了中断标示</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis(); <span class="comment">// 获取系统时钟</span></span><br><span class="line">            <span class="comment">// 使用while循环模拟 sleep</span></span><br><span class="line">            <span class="keyword">while</span> ((System.currentTimeMillis() - time &lt; <span class="number">1000</span>) ) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Starting thread...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Thread is running...</span><br><span class="line">Asking thread to stop...</span><br><span class="line">Thread exiting under request...</span><br><span class="line">Stopping application...</span><br></pre></td></tr></table></figure><p><strong>使用信号量中断非阻塞状态的线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;<span class="comment">// 线程中断信号量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example2 thread = <span class="keyword">new</span> Example2();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>); </span><br><span class="line">        <span class="comment">//sleep()方法阻塞当前进程，如果使用在main线程执行代码中，则阻塞的是main线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置中断信号量</span></span><br><span class="line">        thread.stop = <span class="keyword">true</span>;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每隔一秒检测一下中断信号量</span></span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 使用while循环模拟 sleep 方法，这里不要使用 sleep，否则在阻塞时会抛</span></span><br><span class="line"><span class="comment">             * InterruptedException异常而退出循环，这样while检测stop条件就不会执行.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">while</span> ((System.currentTimeMillis() - time &lt; <span class="number">1000</span>)) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>thread.interrupt()</code> 中断阻塞状态线程</strong></p><p><code>Thread.interrupt()</code> 的作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。</p><p>具体来说，当对一个线程，调用 <code>interrupt()</code> 时，</p><ul><li>如果线程处于被阻塞状态（例如处于 sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个 InterruptedException 异常。</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example3 thread = <span class="keyword">new</span> Example3();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        thread.interrupt();<span class="comment">// 等中断信号量设置后再调用</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果线程阻塞，将不会去检查中断信号量stop变量，所以thread.interrupt()</span></span><br><span class="line"><span class="comment">                 * 会使阻塞线程从阻塞的地方抛出异常，让阻塞线程从阻塞状态逃离出来，并</span></span><br><span class="line"><span class="comment">                 * 在异常块进行相应的处理</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">// 线程阻塞，如果线程收到中断操作信号将抛出异常</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread interrupted...&quot;</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果线程在调用 Object.wait()方法，或者该类的 join() 、sleep()方法</span></span><br><span class="line"><span class="comment">                 * 过程中受阻，则其中断状态将被清除</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.out.println(<span class="keyword">this</span>.isInterrupted());<span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">//中不中断由自己决定，如果需要真中断线程，则需要重新设置中断位，如果</span></span><br><span class="line">                <span class="comment">//不需要，则不用调用</span></span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.isInterrupted());<span class="comment">// true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>interrupt()</code> 方法是不能中断死锁线程的，因为锁定的位置根本无法抛出异常。</p><p><strong>中断I/O操作</strong></p><p>尽管 <code>interrupt()</code> 被调用，线程也不会退出被阻塞状态，比如 ServerSocket的 <code>accept</code> 方法根本不抛出异常。所以需要调用阻塞该线程的套接字的 <code>close()</code> 方法，如果线程被 I/O 操作阻塞，当调用该套接字的 close 方法时，该线程在调用 accept 地方法将接收到一个SocketException (IOException 的子异常）异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> ServerSocket socket;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Example4 thread = <span class="keyword">new</span> Example4();</span><br><span class="line">        System.out.println(<span class="string">&quot;Starting thread...&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Asking thread to stop...&quot;</span>);</span><br><span class="line">        Thread.currentThread().interrupt();<span class="comment">// 调用interrupt方法</span></span><br><span class="line">        thread.socket.close();<span class="comment">// 再调用close方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stopping application...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not create the socket...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Waiting for connection...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.accept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;accept() failed or interrupted...&quot;</span>);</span><br><span class="line">                Thread.currentThread().interrupt();<span class="comment">//重新设置中断标示位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread exiting under request...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-守护线程"><a href="#4-守护线程" class="headerlink" title="4. 守护线程"></a>4. 守护线程</h2><p>守护线程的唯一作用是为其他线程提供服务。计时线程就是一个典型的例子，它定时地发送“计时器滴答”信号告诉其他线程去执行某项任务。当只剩下守护线程时，虚拟机就退出了。另外 JVM 的垃圾回收、内存管理等线程都是守护线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zejian.test;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@decrition</span> 守护线程代码示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demon</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread deamon = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DaemonRunner(),<span class="string">&quot;DaemonRunner&quot;</span>);</span><br><span class="line">deamon.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置为守护线程</span></span><br><span class="line">deamon.start();<span class="comment">//启动线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//在命令行打印异常信息在程序中出错的位置及原因</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;finally的代码在java虚拟机退出时不一定会执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 虚拟机退出时 Daemon线程中的 <code>finally</code> 代码块并不一定会执行，因此在构建 Daemon 线程时，不能依靠 <code>finally</code> 代码块中的内容来确保执行关闭或清理资源的逻辑。</p><h2 id="5-线程优先级"><a href="#5-线程优先级" class="headerlink" title="5. 线程优先级"></a>5. 线程优先级</h2><p>在 Java 线程中，通过一个整型的成员变量 <code>Priority</code> 来控制线程优先级 ，每一个线程有一个优先级，默认情况下，一个线程继承它父类的优先级。可以用 <code>setPriority</code> 方法提高或降低任何一个线程优先级。可以将优先级设置在 <code>MIN_PRIORITY</code>（在 Thread 类定义为 1）与 <code>MAX_PRIORITY</code>（在 Thread 类定义为 10）之间的任何值。线程的默认优先级为 <code>NORM_PRIORITY</code>（在 Thread 类定义为 5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序。</p><h2 id="6-线程的转换关系"><a href="#6-线程的转换关系" class="headerlink" title="6. 线程的转换关系"></a>6. 线程的转换关系</h2><ul><li><p>新建状态</p><p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p></li><li><p>就绪状态</p><p>当线程对象调用了 <strong>start()</strong> 方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待 JVM 里线程调度器的调度。</p></li><li><p>运行状态</p><p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p></li><li><p>阻塞状态</p><p>如果一个线程执行了 sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ul><li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li><li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li></ul></li><li><p>死亡状态</p><p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p></li></ul><p><img src="D:\blog\source\_posts\Java多线程基础\20160313163538263.png" alt="20160313163538263"></p><p>图中的方法解析：</p><ul><li>Thread.sleep(long)：使当前线程进入阻塞状态，在指定时间内不会执行。 </li><li>Object.wait()：调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁。</li><li>Object.notifyAll()：从对象等待池中唤醒所有等待线程。</li><li>Object.notify()：通知一个在对象上等待的线程，使其从wait()返回，而返回的前提是该线程获取到了对象的锁。wait() 和 notify() 必须在 synchronized 函数或 synchronized 中进行调用。</li><li>Thread.yield()： 暂停当前正在执行的线程对象。</li><li>Thread.Join()：把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</li></ul><p><strong>通过 wait()/notify() 实现等待/通知机制的示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A等待获取lock锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A获取了lock锁&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A将要运行lock.wait()方法进行等待&quot;</span>);</span><br><span class="line">                        lock.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程A等待结束&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B等待获取lock锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B获取了lock锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B将要运行lock.notify()方法进行通知&quot;</span>);</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程A等待获取lock锁</span><br><span class="line">线程A获取了lock锁</span><br><span class="line">线程B等待获取lock锁</span><br><span class="line">线程A将要运行lock.wait()方法进行等待</span><br><span class="line">线程B获取了lock锁</span><br><span class="line">线程B将要运行lock.notify()方法进行通知</span><br><span class="line">线程A等待结束</span><br></pre></td></tr></table></figure><h2 id="7-Callable、Future和FutureTask"><a href="#7-Callable、Future和FutureTask" class="headerlink" title="7. Callable、Future和FutureTask"></a>7. Callable、Future和FutureTask</h2><p>创建线程的方式有两种，一种是实现 Runnable 接口，另一种是继承 Thread，但是这两种方式都有个缺点，那就是在任务执行完成之后无法获取返回结果。从 JAVA SE 5.0 开始引入 Callable 和 Future，通过它们构建的线程，在任务执行完成后就可以获取执行结果。</p><p>线程创建的第三种方式就是实现 Callable 接口。</p><h3 id="1-Callable接口"><a href="#1-Callable接口" class="headerlink" title="$(1)$ Callable接口"></a>$(1)$ Callable<V>接口</h3><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">      <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>该接口声明了一个 call() 方法，这个方法有返回值 V，也可以抛出异常。</p><p>无论是 Runnable 接口的实现类还是 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行，ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 都实现了  ExcutorService 接口，因此 Callable 需要和 Executor 框架中的 ExcutorService 结合使用。</p><p>ExecutorService 提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且指定了调用Future的get方法时返回的result对象</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p>除了自己实现 Callable 对象外，还可以使用工厂类 Executors 把一个 Runnable 对象包装成 Callable 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><h3 id="2-Future接口"><a href="#2-Future接口" class="headerlink" title="$(2)$ Future接口"></a>$(2)$ Future<V>接口</h3><p>Future<V>接口是用来获取异步计算结果的，其实就是对 Runnable 或者 Callable 对象任务执行的结果进行获取 get()，取消 cancel()，判断是否完成 isDone() 等操作。</p><p>Future 接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法解析</p><ul><li><strong>V get()</strong> ：获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</li><li><strong>V get</strong>(Long timeout , TimeUnit unit) ：同上，但是有时间限制，如果阻塞时间超过设定的 timeout 时间，该方法将抛出异常。</li><li><strong>boolean isDone()</strong> ：如果任务执行结束，无论是正常结束或中途取消还是发生异常，都返回 true。</li><li><strong>boolean isCanceller()</strong> ：如果任务完成前被取消，则返回 true。</li><li><strong>boolean cancel</strong>(boolean mayInterruptRunning) ：如果任务还没开始，执行 cancel(…) 方法将返回 false；如果任务已经启动，执行 cancel(true) 方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回 true；当任务已经启动，执行 cancel(false) 方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回 false；当任务已经完成，执行cancel(…)方法将返回 false。</li></ul><h3 id="3-FutureTask类"><a href="#3-FutureTask类" class="headerlink" title="$(3)$ FutureTask类"></a>$(3)$ FutureTask类</h3><p>Future 只是一个接口，无法直接创建对象，因此需要其实现类 FutureTask。</p><p>FutureTask 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br></pre></td></tr></table></figure><p>FutureTask 类实现了 RunnableFuture 接口，那么 RunnableFuture 接口的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 的两种构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 可以直接提交给 Executor 执行，也可以调用线程直接执行 <code>FutureTask.run()</code>。</p><p>FutureTask 的方法执行示意图：</p><p><img src="D:\blog\source\_posts\Java多线程基础\20160315150014001.png" alt="20160315150014001"></p><p>当 FutureTask 处于未启动或已启动状态时，如果此时执行 FutureTask.get() 方法将导致调用线程阻塞；当 FutureTask 处于已完成状态时，执行 FutureTask.get() 方法将导致调用线程立即返回结果或者抛出异常。</p><h3 id="4-应用案例"><a href="#4-应用案例" class="headerlink" title="$(4)$ 应用案例"></a>$(4)$ 应用案例</h3><ul><li><p>使用 Callable+Future 获取执行结果</p><p>Callable 实现类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable线程开始计算&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">5000</span>;i++)&#123;</span><br><span class="line">sum=sum+i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Callable线程计算结束&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>submit</strong> 提交 Callable 任务，调用的是 execute(Runnable command) 方法，execute 执行 FutureTask 对象中的 run 方法，在 run 方法中调用 callable 中的 call 方法。总结一下，首先创建一个实现 Future 和 Runnable 的 FutureTask 对象并且把 Callable 对象通过构造函数注入到对象中，然后把 FutureTask 对象传入 execute 方法中，之后直接返回FutureTask对象。execute 方法执行完会把执行结果放入 FutureTask 对象，我们从对象中获得返回值。</p><p>Callable 执行测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建Callable对象任务</span></span><br><span class="line">my calTask=<span class="keyword">new</span> my();</span><br><span class="line"><span class="comment">//提交任务并获取执行结果</span></span><br><span class="line">Future&lt;Integer&gt; future =es.submit(calTask);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">es.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程在执行其他任务&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(future.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;future.get()--&gt;&quot;</span>+future.get());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;future.get()未获取到结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Callable线程开始计算</span><br><span class="line">主线程在执行其他任务</span><br><span class="line">Callable线程计算结束</span><br><span class="line">futureTask.get()--&gt;12497500</span><br><span class="line">主线程执行完成</span><br></pre></td></tr></table></figure></li><li><p>使用 Callable+FutureTask 获取执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">ExecutorService es = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//创建Callable对象任务</span></span><br><span class="line">my calTask=<span class="keyword">new</span> my();</span><br><span class="line"><span class="comment">//创建FutureTask</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(calTask);</span><br><span class="line"><span class="comment">//执行任务</span></span><br><span class="line">es.submit(futureTask);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">es.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程在执行其他任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;futureTask.get()--&gt;&quot;</span>+futureTask.get());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//输出获取到的结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;futureTask.get()未获取到结果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程执行完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果同上。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java多线程&quot;&gt;&lt;a href=&quot;#Java多线程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程&quot;&gt;&lt;/a&gt;Java多线程&lt;/h1&gt;&lt;h2 id=&quot;1-进程，线程，多线程&quot;&gt;&lt;a href=&quot;#1-进程，线程，多线程&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="http://10185102110.github.io/2021/08/08/Java%E5%AE%B9%E5%99%A8/"/>
    <id>http://10185102110.github.io/2021/08/08/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2021-08-08T08:50:56.000Z</published>
    <updated>2021-08-08T09:01:00.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h1><p>容器主要包括 Collection 和 Map 两种。</p><p>Collection：存放独立元素的序列。</p><p>Map：存放key-value型的元素对。</p><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h2><p>Collection 接口包含 List、Set 以及 Queue 子接口。</p><p><img src="D:\blog\source\_posts\Java容器\20190801230729141.png" alt="20190801230729141"></p><p><strong>Collection 和 Collections 有什么区别？</strong></p><p>Collection 是一个接口，它是 Set、List 等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p><h3 id="1-1-Set"><a href="#1-1-Set" class="headerlink" title="1.1 Set"></a>1.1 Set</h3><p>存储的元素是无序的，不可重复的。</p><ul><li><p>HashSet：基于哈希实现，支持快速查找，但它不保证元素的迭代顺序。</p></li><li><p>TreeSet：基于红黑树实现，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logN)；</p></li><li><p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。</p></li></ul><h3 id="1-2-List"><a href="#1-2-List" class="headerlink" title="1.2 List"></a>1.2 List</h3><p>存储的元素是有序的，可重复的。</p><ul><li><p>ArrayList：基于动态数组实现，随机访问的效率较高；</p></li><li><p>Vector：和 ArrayList 类似，每次扩容为 $2$ 倍空间，性能不如 ArrayList，但它用了 Synchronized 来实现线程同步。</p></li><li><p>LinkedList：基于双向循环链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。此外，LinkedList 还可以用作栈、队列和双端队列。</p></li></ul><p><strong>Array 和 ArrayList 有何区别？</strong></p><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 指定固定大小，而 ArrayList 大小是自动扩展的。</li></ul><h3 id="1-3-Queue"><a href="#1-3-Queue" class="headerlink" title="1.3 Queue"></a>1.3 Queue</h3><ul><li><p>LinkedList：可以用它来支持双向队列；</p></li><li><p>PriorityQueue：基于堆结构实现，可以用它来实现优先级队列。</p></li></ul><h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h2><p><img src="D:\blog\source\_posts\Java容器\20190801232854703.png" alt="20190801232854703"></p><ul><li><p>HashMap：基于哈希实现；</p></li><li><p>HashTable：和 HashMap 类似，但它是线程安全的，现在已被淘汰。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p></li><li><p>LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p></li><li><p>TreeMap：基于红黑树实现。</p></li></ul><h2 id="3-设计模式"><a href="#3-设计模式" class="headerlink" title="3. 设计模式"></a>3. 设计模式</h2><h3 id="3-1-迭代器模式"><a href="#3-1-迭代器模式" class="headerlink" title="3.1 迭代器模式"></a>3.1 迭代器模式</h3><p><img src="D:\blog\source\_posts\Java容器\Iterator-1.jpg" alt="Iterator-1"></p><p>Collection 实现了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p><p>Iterator 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-适配器模式"><a href="#3-2-适配器模式" class="headerlink" title="3.2 适配器模式"></a>3.2 适配器模式</h3><p>使用 <code>Arrays.asList()</code> 方法可以很方便地将数据转换为集合，但是转换后的集合不能使用修改的相关操作（add，remove，clear）等。</p><p><code>Arrays.asList()</code> 是泛型方法，传入的对象必须是对象数组。因此不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a); <span class="comment">//直接创建了一个ArrayList</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList(E[] array) &#123;</span><br><span class="line">     a = Objects.requireNonNull(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只是简单判断一下数组是否为null，如果不为null，就将array的地址赋值给a</span></span><br></pre></td></tr></table></figure><p><code>Arrays.asList()</code> 将数组转换为集合后，底层其实还是数组。因此如果更改子列表的值，原数组也会发生变化。当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身，此时 List 的唯一元素就是这个数组。将 int 改成 Integer 就可以正常遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><h2 id="3-ArrayList-原理"><a href="#3-ArrayList-原理" class="headerlink" title="3. ArrayList 原理"></a>3. ArrayList 原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>实现了 RandomAccess 接口，因此支持随机访问。</p><p>基于数组实现，ArrayList 具有动态扩容特性。</p><p>数组的默认大小为 $10$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>删除元素时需要调用 <code>System.arraycopy()</code> 对元素进行复制，因此删除操作成本很高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加元素时使用 <code>ensureCapacity()</code> 方法来保证容量足够，如果不够时，需要使用 <code>grow()</code> 方法进行扩容，使得新容量为旧容量的 $1.5$ 倍（oldCapacity + (oldCapacity &gt;&gt; 1))。扩容操作需要把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>modCount</code> 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行<strong>序列化</strong>(把对象转化为可传输的字节序列过程)或者<strong>迭代</strong>等操作时，需要比较操作前后 modCount 是否改变，如果改变则需要抛出 ConcurrentModificationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-HashMap-原理"><a href="#4-HashMap-原理" class="headerlink" title="4. HashMap 原理"></a>4. HashMap 原理</h2><h3 id="4-1-存储结构"><a href="#4-1-存储结构" class="headerlink" title="4.1 存储结构"></a>4.1 存储结构</h3><p>使用拉链法来解决冲突，内部包含了一个 Entry 类型的数组 table，数组中的每个位置被当成一个桶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><p>其中，Entry 就是存储数据的键值对，它包含了四个字段。从 next 字段我们可以看出 Entry 是一个链表，即每个桶会存放一个链表。</p><p><img src="D:\blog\source\_posts\Java容器\8fe838e3-ef77-4f63-bf45-417b6bc5c6bb.png" alt="8fe838e3-ef77-4f63-bf45-417b6bc5c6bb"></p><p>JDK 1.8 使用 Node 类型存储一个键值对，它继承自 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-拉链法原理"><a href="#4-2-拉链法原理" class="headerlink" title="4.2 拉链法原理"></a>4.2 拉链法原理</h3><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，计算 K1 的 hashCode 为 $115$，使用除留余数法得到所在的桶下标 $115\%16=3$。</li><li>插入 &lt;K2,V2&gt; 键值对，计算 K2 的 hashCode 为 $118$，使用除留余数法得到所在的桶下标 $118\%16=6$。</li><li>插入 &lt;K3,V3&gt; 键值对，计算 K3 的 hashCode 为 $118$，使用除留余数法得到所在的桶下标 $118\%16=6$，插在 &lt;K2,V2&gt; 后面。</li></ul><p><img src="D:\blog\source\_posts\Java容器\07903a31-0fb3-45fc-86f5-26f0b28fa4e7.png" alt="07903a31-0fb3-45fc-86f5-26f0b28fa4e7"></p><p>查找需要分成两步进行：</p><ul><li><p>计算键值对所在的桶；</p></li><li><p>在链表上顺序查找。</p></li></ul><p>时间复杂度显然和链表的长度成正比。</p><p>从 JDK 1.8 开始，<strong>一个桶存储的链表长度大于 $8$ 时会将链表转换为红黑树</strong>。</p><blockquote><p><strong>计算桶下标</strong></p></blockquote><p>$(1)$ hashCode 通过调用 Key 的 <code>hashCode()</code> 方法得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$(2)$ 高位运算</p><p>将 hashCode 的高 $16$ 位和低 $16$ 位进行异或操作，使得数组比较小时也能保证高低位都参与到哈希计算中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$(3)$ 除留余数法</p><p>令 $x = 1&lt;&lt;4$，即 $x$ 为 $2$ 的 $4$ 次方，它具有以下性质：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">x-1 : 00001111</span><br></pre></td></tr></table></figure><p>令一个数 $y$ 与 $x-1$ 做与运算，可以去除 $y$ 位级表示的第 $4$ 位及以上数：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y       : 10110010</span><br><span class="line">x-1     : 00001111</span><br><span class="line">y&amp;(x-1) : 00000010</span><br></pre></td></tr></table></figure><p>结果和 $y$ 对 $x$ 取模是一样的：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   : 00010000</span><br><span class="line">y   : 10110010</span><br><span class="line">y%x : 00000010</span><br></pre></td></tr></table></figure><p>位运算的代价比求模运算小的多，因此在进行这种计算时能用位运算的话能带来更高的性能。</p><p>拉链法需要使用除留余数法来得到桶下标，需要进行以下计算：hash%capacity，如果能保证 capacity 为 $2$ 的幂次方，那么就可以将这个操作转换为位运算。</p><h3 id="4-3-扩容机制"><a href="#4-3-扩容机制" class="headerlink" title="4.3 扩容机制"></a>4.3 扩容机制</h3><p>设 HashMap 的 table 长度为 $M$，需要存储的键值对数量为 $N$，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 $N/M$，因此平均查找次数的数量级为 $O(N/M)$。为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>相关参数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center">capacity</td><td style="text-align:left">table 的容量大小，默认为 16，需要注意的是 capacity 必须保证为 2 的次方。</td></tr><tr><td style="text-align:center">size</td><td style="text-align:left">table 的实际使用量。</td></tr><tr><td style="text-align:center">threshold</td><td style="text-align:left">size 的临界值，size 必须小于 threshold，如果大于等于，就必须进行扩容操作。</td></tr><tr><td style="text-align:center">load_factor</td><td style="text-align:left">table 能够使用的比例，threshold = capacity * load_factor。</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>当需要扩容时，令 capacity 为原来的 $2$ 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容使用 <code>resize()​</code> 实现，但它需要把旧 table 的所有键值对插入新的 table 中，因此这一步是很费时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap 允许有一个 Node 的 Key 为 null，该 Node 一定会放在第 $0$ 个桶的位置，因为这个 Key 无法计算 hashCode()，所以只能规定一个桶让它存放。</p><h3 id="4-4-ConcurrentHashMap"><a href="#4-4-ConcurrentHashMap" class="headerlink" title="4.4 ConcurrentHashMap"></a>4.4 ConcurrentHashMap</h3><p>==JDK 1.7 版本==</p><p>ConcurrentHashMap(并发哈希表) 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁，每个分段锁维护着几个桶，多个线程可以同时访问不同分段锁上的桶。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问，在同一时间点只能有一个线程能访问容器。</p><p>存储结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承自 ReentrantLock(可重入锁)，每个 Segment 维护着多个 HashEntry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SCAN_RETRIES =</span><br><span class="line">        Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span> ? <span class="number">64</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的并发级别为 $16$，也就是说默认创建 $16$ 个 Segment。</p><p><img src="D:\blog\source\_posts\Java容器\image005.jpg" alt="image005"></p><p>==JDK 1.8 版本==</p><p>使用了内置锁 synchronized 代替 Segment，Segment 属于重入锁 ReentrantLock。主要是出于以下考虑：</p><ul><li>synchronized 的锁粒度更低，JDK1.7版本锁的粒度是基于 Segment 的，包含多个 HashEntry，而 JDK1.8 锁的粒度就是 HashEntry (首节点)；</li><li>基于 JVM 的 synchronized 优化空间更大，使用内嵌的关键字比使用 API 更加自然；</li><li>在大量的数据操作下，基于 API 的 ReentrantLock 会开销更多的内存。</li></ul><h2 id="5-Collections-工具类"><a href="#5-Collections-工具类" class="headerlink" title="5. Collections 工具类"></a>5. Collections 工具类</h2><h3 id="5-1-排序，查找，替换操作"><a href="#5-1-排序，查找，替换操作" class="headerlink" title="5.1 排序，查找，替换操作"></a>5.1 排序，查找，替换操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//返回target在list中第一次出现的索引，找不到则返回-1。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><h3 id="5-2-同步控制"><a href="#5-2-同步控制" class="headerlink" title="5.2 同步控制"></a>5.2 同步控制</h3><p>Collections 提供了多个 <code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。HashSet，TreeSet，ArrayList，LinkedList，HashMap，TreeMap 都是线程不安全的。Collections 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定collection支持的同步(线程安全的)collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步(线程安全的)List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步(线程安全的)Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定set支持的同步(线程安全的)set。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最好不要用这些方法，效率非常低，需要线程安全的集合类型时考虑使用 JUC 包下的并发集合。</p><h2 id="6-fail-fast-amp-fail-safe"><a href="#6-fail-fast-amp-fail-safe" class="headerlink" title="6. fail-fast &amp; fail-safe"></a>6. fail-fast &amp; fail-safe</h2><p>$(1)$ 快速失败(fail-fast)</p><p>快速失败(fail-fast) 是 Java 集合的一种错误检测机制。在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 <code>ConcurrentModificationException</code> 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</p><p>每当迭代器使用 <code>hashNext()</code>/<code>next()</code>遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否为 <code>expectedModCount</code> 值，是的话就返回遍历；否则抛出异常，终止遍历。如果我们在集合被遍历期间对其进行修改的话，就会改变 <code>modCount</code> 的值，进而导致 <code>modCount != expectedModCount</code> ，进而抛出 <code>ConcurrentModificationException</code> 异常。</p><p>注：通过 Iterator 的方法修改集合的话会修改到 <code>expectedModCount</code> 的值，所以不会抛出异常。</p><p>$(2)$ 安全失败(fail-safe)</p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 <code>ConcurrentModificationException</code> 异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java容器&quot;&gt;&lt;a href=&quot;#Java容器&quot; class=&quot;headerlink&quot; title=&quot;Java容器&quot;&gt;&lt;/a&gt;Java容器&lt;/h1&gt;&lt;p&gt;容器主要包括 Collection 和 Map 两种。&lt;/p&gt;
&lt;p&gt;Collection：存放独立元素的序</summary>
      
    
    
    
    <category term="Java" scheme="http://10185102110.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://10185102110.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于分布式HBase的数据分析</title>
    <link href="http://10185102110.github.io/2021/07/15/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FHBase%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>http://10185102110.github.io/2021/07/15/%E5%9F%BA%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8FHBase%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</id>
    <published>2021-07-15T13:05:50.000Z</published>
    <updated>2021-07-15T14:02:57.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>Ubuntu 14.04</p><h2 id="实验设备"><a href="#实验设备" class="headerlink" title="实验设备"></a>实验设备</h2><ul><li>三台阿里云 CentOS 轻量级服务器</li><li>Xshell 终端模拟软件</li><li>WinSCP 文件操作软件</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ul><li>Ubuntu下Java, Hadoop与HBase的安装及伪分布式的部署；</li><li>使用Java API对HBase进行基本操作 ；</li><li>基于Hadoop实现MapReduce；</li><li>使用 TensorFlow 框架，对摩拜单车数据集的经纬度进行分析，并可视化。</li></ul><h2 id="HBase-简介"><a href="#HBase-简介" class="headerlink" title="HBase 简介"></a>HBase 简介</h2><p>HBase是一个构建在HDFS上的分布式列存储系统； </p><p>HBase是基于Google BigTable模型开发的，典型 的key/value系统；</p><p>HBase是Apache Hadoop生态系统中的重要一员，主要用于海量结构化数据存储； </p><p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文 “Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System） 所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。</p><p>HBase是Apache 的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据 库。另一个不同的是HBase基于列的而不是基于行的模式。</p><h3 id="分布式Hbase协调工作说明"><a href="#分布式Hbase协调工作说明" class="headerlink" title="分布式Hbase协调工作说明"></a>分布式Hbase协调工作说明</h3><h4 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h4><p>1.保证任何时候，集群中只有一个master </p><p>2.存贮所有Region的寻址入口 </p><p>3.实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master </p><p>4.存储Hbase的schema，包括有哪些table，每个table有哪些column family</p><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>1.为Region server分配region </p><p>2.负责region server的负载均衡 </p><p>3.发现失效的region server并重新分配其上的region </p><p>4.GFS上的垃圾回收 </p><p>5.处理schema更新请求</p><h4 id="Region-server"><a href="#Region-server" class="headerlink" title="Region server"></a>Region server</h4><p>1.Region server 维护Master分配给它的region，处理对这些region的IO请求。 </p><p>2.Region server 负责切分在运行过程中变得过大的region。 可以看到，client访问hbase上数据的过程并不需要master参与（寻址访问zookeeper和region server，数据读写访问region server）, master仅仅维护着table和region的元数据信息，负载很低。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ol><li><p>安装 Java</p><p>安装 JRE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install default-jre</span><br></pre></td></tr></table></figure><p>安装 OpenJDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install default-jdk</span><br></pre></td></tr></table></figure><p>安装 OracleJDK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line">sudo apt-get install oracle-java8-set-default</span><br></pre></td></tr></table></figure></li><li><p>安装 SSH</p><p>在 Hadoop 运行过程中，主从机之间是通过SSH进行通信的，所以需要对所有主机进行SSH的安装和配置 工作。</p><p>安装ssh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install openssh-server</span><br></pre></td></tr></table></figure><p>使用下面的命令来查看SSH是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep ssh</span><br></pre></td></tr></table></figure><p><strong>配置免密登录 SSH</strong></p><p>在master主机上进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -keygen -t rsa</span><br></pre></td></tr></table></figure><p>将公钥（<code>~/.ssh/id_rsa.pub</code>中的内容）复制到文件 <code>authorized_keys</code> 中去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>将 master 上的 <code>~/.ssh/authorized_keys</code> 通过 scp 命令复制到从机 slave1,slave2 中去。</p><p>但发现通过ssh命令仍不能实现三台主机之间的免密登录，查阅资料我们知道：ssh对目录权限有要求， 代码中要设置新生成的config文件75，其中~目录权限值为750，~/.ssh的是700，~/.ssh/*是600，因此 我们需要给它赋值600，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p>安装 Zookeeper</p><p>选择一个版本的 Zookeeper 进行下载安装，用 winSCP 将文件传到服务器根目录下，执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp zookeeper-3.5.6-bin.tar.gz hadoop@47.101.139.207:~/</span><br></pre></td></tr></table></figure><p>进入服务器根目录下，将zookeeper-3.5.6-bin.tar.gz解压至 /usr/local/cluster中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf ~/zookeeper-3.5.6-bin-tar.gz -C /usr/local/cluter/</span><br></pre></td></tr></table></figure><p>这里解压之后形成的文件夹名为zookeeper-3.5.6，为了方便后续操作，我们将之改名为zookeeper 设置环境变量，在 <code>~/.bashrc</code> 中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#zookeeper</span><br><span class="line">export ZOOKEEPER=/usr/local/cluster/zookeeper</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER/bin</span><br></pre></td></tr></table></figure><p>使环境变量生效，并为 zookeeper 配置数据和日志文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>当三台主机全部配置完成之后，尝试启动zookeeper：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/cluster/zookeeper/bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p><img src="1.png" alt="1"></p><p>查看 zookeeper 启动状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/cluster/zookeeper/bin/zkServer.sh status</span><br></pre></td></tr></table></figure><p><img src="2.png" alt="2"></p><p>发现 error contacting 经过研究发现，在zoo.cfg配置文件中加上如下一行代码，即可解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quorumListenOnALLIPS=true</span><br></pre></td></tr></table></figure><p><img src="3.png" alt="3"></p><p>完成配置</p></li><li><p>安装 Hadoop 和 HBase</p><p>基本过程与安装 zookeeper 相似，在此省略。</p><p>在hadoop的配置过程中由于java的问题，要注意我们JAVA_HOME的环境变量路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#java</span><br><span class="line"> export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk</span><br><span class="line"> export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"> export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p>接下来进行伪分布式的配置。Hadoop可以在单节点上以伪分布式的方式运行。Hadoop进程以分离的Java进程来运行。需要对hadoop/etc/hadoop中的两个配置文件进行修改。</p><p><img src="5.png" alt="5"></p><p><img src="6.png" alt="6"></p><p>修改完成后对NameNode进行格式化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>启动 hadoop：</p><p><img src="4.png" alt="4"></p><p>用 jps 判断是否启动成功</p><p><img src="7.png" alt="7"></p><p>可以看到，出现 NameNode, DataNode 和 SecondaryNameNode 三个进程，说明启动成功。</p><p>在 50069 端口可以查看节点信息</p><p><img src="8.png" alt="8"></p><p>通过16010端口查看 HBase 运行情况</p><p><img src="9.png" alt="9"></p></li></ol><h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>使用Hbase Shell导入数据：</p><p><img src="10.png" alt="10"></p><p>在 HBase 内, 数据按照 <code>&lt;行键&gt;&lt;列族1: 列1-1, 列1-2&gt;&lt;列族2: 列2-1, 列2-2&gt;</code> 这样的类型进行存储的。且, 其一, 其中行键的排列顺序是按照字典顺序排序的, 这点对于搜索非常重要。其二, 同一行键的相同列族中列的值, 是可能变化的, 并且按照时间戳进行排序的(当然, 有些数据在合并的时候, 会被删除) 。其中, 相应的模块知识, 如下所示:</p><ul><li><p>Row Key </p><p><code>Row Key</code> , 行键. 是用来检索记录的主键. 访问 <code>HBase Table</code> 中的行, 主要有三种方式. 单个row key 进行访问 / 通过 row key 正则匹配 / 全表扫描 . Row Key 的值可以是任意字符串(最大长度为64KB, 实际使用经常为10-100byte) .其中, 行键的排列顺序是按照字典顺序排序的, 这点对于搜索非常重要. (PS: 字典顺序: <code>1 10 12 6 7 9</code> 中, <code>11</code> 排在 <code>9</code> 之前.) </p></li><li><p>Columns Family </p><p><code>Columns Famil</code>y 列族. HBase 内的每个列, 都属于一个列族. 列族是 Schema 一部分(即表设计), 而 列不是(列可以在插入数据时, 动态添加). 列族是需要在使用之前进行提前定义的. 列名都以列族为前缀, 如<code>course:namecourse:age</code>. </p></li><li><p>Cell </p><p><code>Cell</code> , 数据单元. 有唯一确定的单元. Cell 内的数据是没有类型的, 全部都是字节码进行存储的. </p></li><li><p>Time Stamp </p><p>每个 Cell 存储一个数据的多个版本. 版本号, 通过时间戳进行索引(时间精确到毫秒). 时间戳类型为 64位整数类型. 时间戳按照时间类型倒叙排序. </p><p>回收版本机制: <code>&lt;保存数据的最后n个版本&gt; / &lt;保存最近一段时间的版本(如最近七天)&gt;</code></p></li></ul><p>操作流程</p><ol><li><p>将服务器本地文件(.csv)上传到hdfs的根目录下,然后导入数据到hbase</p></li><li><p>进入hbase shell 创建表 bicycle,列族为info</p></li><li><p>执行文件导入（Hadoop用户中执行）</p><p>格式：hbase [类] [分隔符] [行键，列族] [表] [导入文件] （默认分隔符为空格）</p></li><li><p>导入完成后，可以使用 scan  来查看是否导入成功</p></li></ol><p><img src="11.png" alt="11"></p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>对数据清洗之后得到若干组经纬度坐标，对坐标进行聚类，采用以下四种算法：</p><ol><li><p>K-Means (K均值) 聚类</p><p>步骤： </p><p>(1) 选择一些类/组，并随机初始化它们各自的中心点。中心点是与每个数据点向量长度相同的位置（需 要提前预知类的数量，即中心点的数量)。 </p><p>(2) 计算每个数据点到中心点的距离，数据点距离哪个中心点最近就划分到哪一类中。 </p><p>(3) 计算每一类中中心点作为新的中心点。 </p><p>(4) 重复以上步骤，直到每一类中心在每次迭代后变化不大为止。也可以多次随机初始化中心点，然后 选择运行结果最好的一个。</p><p>优点： </p><p>(1) 速度快 </p><p>(2) 计算简便</p><p>缺点： </p><p>(1) 需要提前知道数据有多少类 </p><p>(2) 摩拜单车数据量庞大，并不知道一共可以分成多少类，存在一定误差，但在中小规模数据下可以适 用。</p></li><li><p>均值漂移聚类</p><p>步骤： </p><p>(1) 确定滑动窗口半径r，以随机选取的中心点C半径为r的圆形滑动窗口开始滑动。均值漂移类似一种爬 山算法，在每一次迭代中向密度更高的区域移动，直到收敛。 </p><p>(2) 每一次滑动到新的区域，计算滑动窗口内的均值来作为中心点，滑动窗口内的点的数量为窗口内的 密度。在每一次移动中，窗口会想密度更高的区域移动。 </p><p>(3) 移动窗口，计算窗口内的中心点以及窗口内的密度，知道没有方向在窗口内可以容纳更多的点，即 一直移动到圆内密度不再增加为止。 </p><p>(4) 步骤一到三会产生很多个滑动窗口，当多个滑动窗口重叠时，保留包含最多点的窗口，然后根据数 据点所在的滑动窗口进行聚类。</p><p>优点： </p><p>(1) 不需要设定一共有多少组 </p><p>(3) 受均值影响小 </p><p>缺点： </p><p>r 的选择可能并不重要，在本次实验中并没有好的预期效果。</p></li><li><p>基于密度的聚类方法 (DBSCAN)</p><p>步骤： </p><p>(1) 首先确定半径 r 和 minPoints。从一个没有被访问过的任意数据点开始，以这个点为中心，r 为半径 的圆内包含的点的数量是否大于或等于 minPoints，如果大于或等于 minPoints 则改点被标记为 central point ,反之则会被标记为 noise point。 </p><p>(2) 重复 (1) 的步骤，如果一个 noise point 存在于某个 central point 为半径的圆内，则这个点被标记为 边缘点，反之仍为 noise point。重复步骤 ，直到所有的点都被访问过。</p><p>优点： </p><p>不需要设定一共有多少组。</p><p>缺点： </p><p>需要频繁改动距离 r 和 minPoints，来获得较好的预期效果。</p></li><li><p>用高斯混合模型（GMM）的最大期望（EM）聚类</p><p>步骤： </p><p>(1) 选择簇的数量 (与K-Means类似) 并随机初始化每个簇的高斯分布参数 (均值和方差) 。也可以先观察 数据给出一个相对精确的均值和方差。 </p><p>(2) 给定每个簇的高斯分布，计算每个数据点属于每个簇的概率。一个点越靠近高斯分布的中心就越可 能属于该簇。 </p><p>(3) 基于这些概率我们计算高斯分布参数使得数据点的概率最大化，可以使用数据点概率的加权来计算 这些新的参数，权重就是数据点属于该簇的概率。 重复迭代 (2) 和 (3) 直到在迭代中的变化不大。</p><p>优点：</p><p>(1) 使用均值和标准差，簇可以呈现出椭圆形而不是仅仅限制于圆形 </p><p>(2) 使用概率，所有一个数据点可以属于多个簇 </p><p>缺点： </p><p>目的为确认单车的密度分布，并不太适用此算法。</p></li></ol><p>代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> cholesky</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle  <span class="comment"># 用于打乱数据</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">tf.disable_v2_behavior()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zc_read_csv</span>():</span></span><br><span class="line">    zc_dataframe = pd.read_csv(<span class="string">&quot;C:/Users/HP/Desktop/mobike/mobike/1/123.csv&quot;</span>, sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    x = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> zc_index <span class="keyword">in</span> zc_dataframe.index:</span><br><span class="line">        zc_row = zc_dataframe.loc[zc_index]</span><br><span class="line">        x.append([zc_row[<span class="number">6</span>],zc_row[<span class="number">7</span>]])</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">x = zc_read_csv()</span><br><span class="line">y = tf.convert_to_tensor(x,name=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">z = tf.to_double(y, name=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    srcdata = sess.run(z)</span><br><span class="line"><span class="built_in">print</span>(srcdata)</span><br><span class="line"><span class="comment"># 画出当前的所有点</span></span><br><span class="line">plt.plot(srcdata[:, <span class="number">0</span>], srcdata[:, <span class="number">1</span>], <span class="string">&#x27;bo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义K-means算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义K-means算法函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span>(<span class="params">vectors, k_num</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 TensorFlow 实现K-Means 算法</span></span><br><span class="line"><span class="string">    :param vectors: 是一个 n * k 的Numpy数组，n代表k维向量的数量，也就是模拟产生的数据点的Tensor</span></span><br><span class="line"><span class="string">    :param k_num: 表示需要分类的个数,是一个整数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 将 k 转换为整数</span></span><br><span class="line">    k_num = <span class="built_in">int</span>(k_num)</span><br><span class="line">    <span class="comment"># 异常处理，防止后续数组下标越界,防止出现分类个数大于实际的点的个数</span></span><br><span class="line">    <span class="keyword">assert</span> k_num &lt; <span class="built_in">len</span>(vectors)</span><br><span class="line">    <span class="comment"># 找出每个向量的维度,平面点的维度为2(x,y)，空间点维度为3(x,y,z)</span></span><br><span class="line">    dim = <span class="built_in">len</span>(vectors[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 获取 vectors 长度大小的随机数据(本例中为1000)</span></span><br><span class="line">    vector_indices = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(vectors)))</span><br><span class="line">    <span class="comment"># 打乱 vector_indices 中的所有数据，能够更好的泛化</span></span><br><span class="line">    shuffle(vector_indices)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算图</span></span><br><span class="line">    <span class="comment"># 我们创建了一个默认的计算流的图用于整个算法中，这样就保证了当函数被多次调用时，始终使用的     # 是默认的图</span></span><br><span class="line">    graph = tf.Graph()</span><br><span class="line">    <span class="keyword">with</span> graph.as_default():</span><br><span class="line">        <span class="comment"># 创建会话</span></span><br><span class="line">        tf.compat.v1.disable_eager_execution()</span><br><span class="line">        <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">            <span class="comment"># 构建基本的计算的元素</span></span><br><span class="line">            <span class="comment"># 首先我们需要保证每个中心点都会存在一个Variable矩阵</span></span><br><span class="line">            <span class="comment"># 从现有的点集合中抽取出前 k_num 个数据作为默认的中心点,并且定义为 tf 的变量,</span></span><br><span class="line">            <span class="comment"># 用于后续的中心点的运算</span></span><br><span class="line">            centroids = [tf.Variable((vectors[vector_indices[i]]))<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k_num)]</span><br><span class="line">            <span class="comment"># 创建一个placeholder用于存放各个分类的中心点</span></span><br><span class="line">            centroid_value = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 给 k_num 个中心点向量进行赋值,cent_assigns 用于保存中心点的位置信息</span></span><br><span class="line">            cent_assigns = []</span><br><span class="line">            <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids:</span><br><span class="line">                cent_assigns.append(tf.assign(centroid, centroid_value))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># assignments 用于保存 sampleNo 个点的经过计算分类后位置</span></span><br><span class="line">            assignments = [tf.Variable(<span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors))]</span><br><span class="line">            <span class="comment"># 存储每个单独的点到 k_num 个分类的最短距离</span></span><br><span class="line">            assignment_value = tf.placeholder(dtype=tf.int32)</span><br><span class="line">            <span class="comment"># cluster_assigns 存储的是每个点到 k_num 个中心点中的最小的一个距离</span></span><br><span class="line">            cluster_assigns = []</span><br><span class="line">            <span class="comment"># 初始化 cluster_assigns</span></span><br><span class="line">            <span class="keyword">for</span> assignment <span class="keyword">in</span> assignments:</span><br><span class="line">                cluster_assigns.append(tf.assign(assignment, assignment_value))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 下面创建用于计算平均值的操作节点</span></span><br><span class="line">            <span class="comment"># 输入的placeholder</span></span><br><span class="line">            mean_input = tf.placeholder(dtype=tf.float64, shape=[<span class="literal">None</span>, dim])</span><br><span class="line">            <span class="comment"># 节点/OP接受输入，并且计算0维度的平均值，如输入的向量列表</span></span><br><span class="line">            mean_op = tf.reduce_mean(mean_input, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 用于计算欧几里得距离的节点 distance = ((x1 - x2)^2 + (y1 - y2)^2)^(1/2)</span></span><br><span class="line">            v1 = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line">            v2 = tf.placeholder(dtype=tf.float64, shape=[dim])</span><br><span class="line">            </span><br><span class="line">            euclid_dist = tf.sqrt(tf.reduce_sum(tf.<span class="built_in">pow</span>(tf.subtract(v1, v2), <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这个OP会决定应该将向量归属到哪个节点</span></span><br><span class="line">            <span class="comment"># 基于向量到中心点的欧几里得距离</span></span><br><span class="line">            <span class="comment"># Placeholder for input</span></span><br><span class="line">            centroid_distances = tf.placeholder(dtype=tf.float64, shape=[k_num])</span><br><span class="line">            <span class="comment"># cluster_assignment 计算 k_num 个中心点的最短欧几里得距离</span></span><br><span class="line">            cluster_assignment = tf.argmin(centroid_distances, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 初始化所有的状态值</span></span><br><span class="line">            init_op = tf.global_variables_initializer()</span><br><span class="line">            <span class="comment"># 初始化所有的变量</span></span><br><span class="line">            sess.run(init_op)</span><br><span class="line">            <span class="comment"># 创建tensor图,并保存在当前的log目录下</span></span><br><span class="line">            tf.summary.FileWriter(<span class="string">&quot;./log&quot;</span>, sess.graph)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 集群遍历</span></span><br><span class="line">            <span class="comment"># 接下来在K-Means聚类迭代中使用最大期望算法。为了简单起见，只让它执行固</span></span><br><span class="line">            <span class="comment"># 定的训练的次数为20次，而不设置一个终止条件</span></span><br><span class="line">            noofiterations = <span class="number">20</span></span><br><span class="line">            <span class="keyword">for</span> iteration_n <span class="keyword">in</span> <span class="built_in">range</span>(noofiterations):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 期望步骤</span></span><br><span class="line">                <span class="comment"># 基于上次迭代后算出的中心点的位置</span></span><br><span class="line">                <span class="comment"># 1.首先遍历所有的向量,len(vectors)在此案例中值为 sampleNo = 1000</span></span><br><span class="line">                <span class="comment"># 计算每个点到 k_num 个分类中心点的最短距离,并存储在 cluster_assigns 中</span></span><br><span class="line">                <span class="keyword">for</span> vector_n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors)):</span><br><span class="line">                    <span class="comment"># 获取第 vector_n 个向量,取值范围在[0,999]</span></span><br><span class="line">                    vect = vectors[vector_n]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 当前点与 k_num 个分类的中心点欧几里得距离</span></span><br><span class="line">                    distances = [sess.run(euclid_dist, feed_dict=&#123;</span><br><span class="line">                        v1: vect, v2: sess.run(centroid)&#125;) <span class="keyword">for</span> centroid <span class="keyword">in</span> centroids]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 获取当前点到 k_num 个分类中心点的最短距离,目的是为了后续选择最近距离的中心点</span></span><br><span class="line">                    assignment = sess.run(cluster_assignment, feed_dict=&#123;</span><br><span class="line">                        centroid_distances: distances&#125;)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 接下来为每个向量分配合适的值</span></span><br><span class="line">                    sess.run(cluster_assigns[vector_n], feed_dict=&#123;</span><br><span class="line">                        assignment_value: assignment&#125;)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 2.将所有点进行分类</span></span><br><span class="line">                <span class="comment"># 基于上述的期望步骤，计算每个新的中心点的距离从而使集群内的平方和最小</span></span><br><span class="line">                <span class="keyword">for</span> cluster_n <span class="keyword">in</span> <span class="built_in">range</span>(k_num):</span><br><span class="line">                    <span class="comment"># 收集 k_num 个分类中,对应每个分类的数据</span></span><br><span class="line">                    assigned_vects = [vectors[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vectors))</span><br><span class="line">                                      <span class="keyword">if</span> sess.run(assignments[i]) == cluster_n]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 采用平均值的计算方式重新计算每个分类集群新的中心点</span></span><br><span class="line">                    new_location = sess.run(mean_op, feed_dict=&#123;</span><br><span class="line">                        mean_input: array(assigned_vects)&#125;)</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 为 k_num 个分类分配新的中心点</span></span><br><span class="line">                    sess.run(cent_assigns[cluster_n], feed_dict=&#123;</span><br><span class="line">                        centroid_value: new_location&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回 k_num 个中心节点</span></span><br><span class="line">            centroids = sess.run(centroids)</span><br><span class="line">            <span class="comment"># 返回 k_num 个分组</span></span><br><span class="line">            assignments = sess.run(assignments)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> centroids, assignments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义聚类的个数,并使用kmeans算法去计算</span></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">center, result = kmeans(srcdata, k)</span><br><span class="line"><span class="built_in">print</span>(np.shape(result))</span><br><span class="line"><span class="comment"># 打印 k 个中心点</span></span><br><span class="line"><span class="built_in">print</span>(center)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整理结果,并使用 seaborn 画图</span></span><br><span class="line">res = &#123;<span class="string">&quot;x&quot;</span>: [], <span class="string">&quot;y&quot;</span>: [], <span class="string">&quot;kmeans_res&quot;</span>: []&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(result)):</span><br><span class="line">    res[<span class="string">&quot;x&quot;</span>].append(srcdata[i][<span class="number">0</span>])</span><br><span class="line">    res[<span class="string">&quot;y&quot;</span>].append(srcdata[i][<span class="number">1</span>])</span><br><span class="line">    res[<span class="string">&quot;kmeans_res&quot;</span>].append(result[i])</span><br><span class="line"></span><br><span class="line">pd_res = pd.DataFrame(res)</span><br><span class="line">sns.lmplot(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, data=pd_res, fit_reg=<span class="literal">False</span>, height=<span class="number">5</span>, hue=<span class="string">&quot;kmeans_res&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>对聚类出的经纬度数据聚类后，为了方便检测聚类结果，我们直接采用 python 的 matplotlib 库以经 纬度为坐标画出聚类结果，但发现这种方式对于聚类结果的显示并不是很直观，无法发现聚类结果和实 际地形的关联。于是想到使用高德地图的 API，希望可以将聚类结果直接在实际的地图上投影，在参阅 了高德地图官方 API 实例之后，发现其提供的海量点，点聚合可以实现我们的需求。申请成为高德地图 开放平台的个人开发者，得到 key，然后利用其中的 API 进行可视化。如下图所示：</p><p><img src="12.png" alt="12"></p><p><img src="13.png" alt="13"></p><p><img src="14.png" alt="14"></p><p><img src="15.png" alt="15"></p><p><img src="16.png" alt="16"></p><p>可视化后可以发现上海区域地图上呈现若干密集点，通过调整地图的大小，可以调整密集点的大小， 根据需求可以知道不同区域摩拜单车的密集度。这些密集度说明哪些区域会使用更多的摩拜单车，为了 符合人们用车需求应当调整不同区域摩拜单车的数量，才能更好地满足人们的需求。</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0, user-scalable=no, width=device-width&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>点聚合<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">25rem</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">7rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: .<span class="number">7rem</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.input-card</span> <span class="selector-class">.btn</span><span class="selector-pseudo">:last-child</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;map&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>聚合点效果切换<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;默认样式&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add0&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(0)&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;自定义图标&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add1&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(1)&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;完全自定义&quot;</span> <span class="attr">id</span>=<span class="string">&quot;add2&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;addCluster(2)&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./china.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;https://webapi.amap.com/maps?v=1.4.15&amp;key=2b373ec81fe728db4bf6b57baea1138d&amp;plugin=AMap.MarkerClusterer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> cluster, markers = [];</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> map = <span class="keyword">new</span> AMap.Map(<span class="string">&quot;container&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">resizeEnable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">center</span>: [<span class="number">105</span>, <span class="number">34</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">zoom</span>: <span class="number">4</span></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        markers.push(<span class="keyword">new</span> AMap.Marker(&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">position</span>: points[i][<span class="string">&#x27;lnglat&#x27;</span>],</span></span><br><span class="line"><span class="javascript">            <span class="attr">content</span>: <span class="string">&#x27;&lt;div style=&quot;background-color: hsla(180, 100%, 50%, 0.7); height: 24px; width: 24px; border: 1px solid hsl(180, 100%, 40%); border-radius: 12px; box-shadow: hsl(180, 100%, 50%) 0px 0px 1px;&quot;&gt;&lt;/div&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">15</span>, -<span class="number">15</span>)</span></span><br><span class="line"><span class="javascript">        &#125;))</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> count = markers.length;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> _renderClusterMarker = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> factor = <span class="built_in">Math</span>.pow(context.count / count, <span class="number">1</span> / <span class="number">18</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> Hue = <span class="number">180</span> - factor * <span class="number">180</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> bgColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,50%,0.7)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> fontColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,20%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> borderColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,40%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> shadowColor = <span class="string">&#x27;hsla(&#x27;</span> + Hue + <span class="string">&#x27;,100%,50%,1)&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.backgroundColor = bgColor;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> size = <span class="built_in">Math</span>.round(<span class="number">30</span> + <span class="built_in">Math</span>.pow(context.count / count, <span class="number">1</span> / <span class="number">5</span>) * <span class="number">20</span>);</span></span><br><span class="line"><span class="javascript">        div.style.width = div.style.height = size + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.border = <span class="string">&#x27;solid 1px &#x27;</span> + borderColor;</span></span><br><span class="line"><span class="javascript">        div.style.borderRadius = size / <span class="number">2</span> + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.boxShadow = <span class="string">&#x27;0 0 1px &#x27;</span> + shadowColor;</span></span><br><span class="line"><span class="javascript">        div.innerHTML = context.count;</span></span><br><span class="line"><span class="javascript">        div.style.lineHeight = size + <span class="string">&#x27;px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.color = fontColor;</span></span><br><span class="line"><span class="javascript">        div.style.fontSize = <span class="string">&#x27;14px&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        div.style.textAlign = <span class="string">&#x27;center&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        context.marker.setOffset(<span class="keyword">new</span> AMap.Pixel(-size / <span class="number">2</span>, -size / <span class="number">2</span>));</span></span><br><span class="line"><span class="javascript">        context.marker.setContent(div)</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    addCluster(<span class="number">2</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">addCluster</span>(<span class="params">tag</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (cluster) &#123;</span></span><br><span class="line"><span class="javascript">            cluster.setMap(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (tag == <span class="number">2</span>) &#123;<span class="comment">//完全自定义</span></span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">gridSize</span>: <span class="number">80</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">renderClusterMarker</span>: _renderClusterMarker</span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag == <span class="number">1</span>) &#123;<span class="comment">//自定义图标</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> sts = [&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/blue.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">32</span>, <span class="number">32</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">16</span>, -<span class="number">16</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/green.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">32</span>, <span class="number">32</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">16</span>, -<span class="number">16</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/orange.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">36</span>, <span class="number">36</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">18</span>, -<span class="number">18</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/red.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">48</span>, <span class="number">48</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">24</span>, -<span class="number">24</span>)</span></span><br><span class="line"><span class="javascript">            &#125;, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">url</span>: <span class="string">&quot;https://a.amap.com/jsapi_demos/static/images/darkRed.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">size</span>: <span class="keyword">new</span> AMap.Size(<span class="number">48</span>, <span class="number">48</span>),</span></span><br><span class="line"><span class="javascript">                <span class="attr">offset</span>: <span class="keyword">new</span> AMap.Pixel(-<span class="number">24</span>, -<span class="number">24</span>)</span></span><br><span class="line"><span class="javascript">            &#125;];</span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">styles</span>: sts,</span></span><br><span class="line"><span class="javascript">                <span class="attr">gridSize</span>: <span class="number">80</span></span></span><br><span class="line"><span class="javascript">            &#125;);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//默认样式</span></span></span><br><span class="line"><span class="javascript">            cluster = <span class="keyword">new</span> AMap.MarkerClusterer(map, markers, &#123;<span class="attr">gridSize</span>: <span class="number">80</span>&#125;);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码地址：</p><p><a href="https://github.com/10185102110/HBase">https://github.com/10185102110/HBase</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h2&gt;&lt;p&gt;Ubuntu 14.04&lt;/p&gt;
&lt;h2 id=&quot;实验设备&quot;&gt;&lt;a href=&quot;#实验设备&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Server" scheme="http://10185102110.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>KDD竞赛基准系统</title>
    <link href="http://10185102110.github.io/2021/07/15/KDD%E7%AB%9E%E8%B5%9B%E5%9F%BA%E5%87%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://10185102110.github.io/2021/07/15/KDD%E7%AB%9E%E8%B5%9B%E5%9F%BA%E5%87%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-15T11:39:25.000Z</published>
    <updated>2021-07-15T12:55:06.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>给定作者 ID 和论文 ID，判断该作者是否写了这篇论文。</p><h2 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h2><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p><h2 id="数据集描述"><a href="#数据集描述" class="headerlink" title="数据集描述"></a>数据集描述</h2><ul><li><u>作者数据集</u> : <code>Author.csv</code>。包含作者的编号（Id），名字（Name），单位（affiliation） 信息。相同 的作者可能在 <code>Author.csv</code> 数据集中出现多次，因为作者在不同会议／期刊上发表论文的名字可 能有多个版本。例如：J. Doe, Jane Doe, 和 J. A. Doe 指的均是同一个人。此外，Affiliation 信息可能为空。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">Id</td><td style="text-align:left">int</td><td style="text-align:left">作者编号</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:left">string</td><td style="text-align:left">作者名称</td></tr><tr><td style="text-align:left">Affiliation</td><td style="text-align:left">string</td><td style="text-align:left">隶属单位</td></tr></tbody></table></div><ul><li><u>论文数据集</u> : <code>Paper.csv</code>。包含论文的标题(title)，会议／期刊信息, 关键字(keywords)。 同一论文可 能会通过不同的数据来源获取，因此在 <code>Paper.csv</code> 中会存在多个副本。此外， Keyword 信息可能为空。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">Id</td><td style="text-align:left">int</td><td style="text-align:left">论文编号</td></tr><tr><td style="text-align:left">Title</td><td style="text-align:left">string</td><td style="text-align:left">论文标题</td></tr><tr><td style="text-align:left">Year</td><td style="text-align:left">int</td><td style="text-align:left">论文年份</td></tr><tr><td style="text-align:left">ConferenceId</td><td style="text-align:left">int</td><td style="text-align:left">论文发表的会议Id</td></tr><tr><td style="text-align:left">JournalId</td><td style="text-align:left">int</td><td style="text-align:left">论文发表的期刊Id</td></tr><tr><td style="text-align:left">Keywords</td><td style="text-align:left">string</td><td style="text-align:left">论文关键字</td></tr></tbody></table></div><ul><li><u>(论文-作者)数据集</u> : <code>PaperAuthor.csv</code>。包含 (论文 Id-作者 Id)对 的信息。该数据集包含 噪声 (noisy)，即存在不正确的(论文 Id-作者 Id)对，意味着 <code>PaperAuthor.csv</code> 包含的(论 文 Id-作者 Id) 对 中的作者 Id 并不一定写了该论文 Id。这是因为，作者名字存在歧义， 可能存在同名的不 同人或作者名字有多个版本（如上面的例子：J. Doe, Jane Doe 和 J. A. Doe 指的均是同一个人）。 此外，Affiliation 信息可能为空。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">PaperId</td><td style="text-align:left">int</td><td style="text-align:left">论文编号</td></tr><tr><td style="text-align:left">AuthorId</td><td style="text-align:left">int</td><td style="text-align:left">作者编号</td></tr><tr><td style="text-align:left">Name</td><td style="text-align:left">string</td><td style="text-align:left">作者名称</td></tr><tr><td style="text-align:left">Affiliation</td><td style="text-align:left">string</td><td style="text-align:left">隶属单位</td></tr></tbody></table></div><ul><li><u>会议和期刊数据集</u> ：<code>Conference.csv, Journal.csv</code>。每篇论文发表在会议或者期刊上。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">Id</td><td style="text-align:left">int</td><td style="text-align:left">会议/期刊编号</td></tr><tr><td style="text-align:left">ShortName</td><td style="text-align:left">string</td><td style="text-align:left">简称</td></tr><tr><td style="text-align:left">Fullname</td><td style="text-align:left">string</td><td style="text-align:left">全称</td></tr><tr><td style="text-align:left">Homepage</td><td style="text-align:left">string</td><td style="text-align:left">主页</td></tr></tbody></table></div><ul><li><p>共同作者的信息：<code>coauthor.json</code>。该文件内容是从 <code>PaperAuthor.csv</code> 中抽取出来共同作者的信息， 该文件的生成可以通过运行 <code>model_trainer</code> 下的 <code>coauthor.py</code> 。</p><p><code>coauthor.json</code> 文件的内容格式形如： {“A 作者 ID”: {“B1 作者 ID”: 合作次数, “B2 作者 ID”: 合作次数}} 第一层的 key 为作者的 ID，对应的 value 为共同作者信息（同样为 key-value 形式，key 为 共 同作者的 ID，value 为合作次数）。 </p><p>目前，<code>coauthor.json</code> 文件给出每个作者合作频率最高的 10 个共同作者，该文件的格式为 json。 可以通过修改 <code>coauthor.py</code> 中 <code>get_top_k_coauthors (paper_author_path, k, to_file)</code>方法中 的 k 值 来获取最高的 k 个共同作者，即 top k： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">10</span>  </span><br><span class="line">get_top_k_coauthors(os.path.join(config.DATASET_PATH,<span class="string">&quot;PaperAuthor.csv&quot;</span>),  k, os.path.join(config.DATA_PATH, <span class="string">&quot;coauthor.json&quot;</span>)) </span><br></pre></td></tr></table></figure><p>例 如 ， 获 取 作 者 ID 为 ‘742736’ 的 共 同 作 者 信 息 ， 可 以 通 过 以 下 代 码 获 取 ， coauthor[“742736”] 值对应的是 ID 为 ‘742736’ 作者的共同作者信息。u’823230’: 3 表 示 ID 为 ‘742736’ 的作者 与 ID 为 ‘823230’ 的作者共合作过 3 次： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> json  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coauthor = json.load(<span class="built_in">open</span>(<span class="string">&quot;coauthour.json&quot;</span>))  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coauthor[<span class="string">&quot;742736&quot;</span>] &#123;<span class="string">u&#x27;823230&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;647433&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;1691202&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;891164&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;1910552&#x27;</span>:  <span class="number">3</span>, <span class="string">u&#x27;607259&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;2182818&#x27;</span>: <span class="number">7</span>, <span class="string">u&#x27;1355775&#x27;</span>: <span class="number">4</span>, <span class="string">u&#x27;2097154&#x27;</span>: <span class="number">3</span>, <span class="string">u&#x27;1108518&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><u>论文&amp;作者 pair 字符串信息</u> ：<code>paperIdAuthorId_to_name_and_affiliation.json</code>。该文件内容是从 <code>Paper-Author.csv</code> 提取的，该文件可以通过运行 <code>model_trainer</code> 文件夹下的<code>stringDistance.py</code> 来获取。</p><p>将 <code>Paper-Author.csv</code> 中相同的论文 ID 和作者 ID 对的 name 和 affiliation 合并，文件内容为 key-value 形式， key 为 论 文 ID 和作者 ID 对 ： ‘paperid|authorid’, value 为 {“name”:  “name1##name2##name3”, “affiliation”: “aff1##aff2##aff3”}。 {“A 作者 ID”: {“B1 作者 ID”: 合作次 数, “B2 作者 ID”: 合作次数}} </p><p>例如，获取 ID 为 ‘1156615’ 的论文和 ID 为 ‘2085584’ 的作者 name 和 affiliation 信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pa_name_aff = json.load(<span class="built_in">open</span>(<span class="string">&quot;paperIdAuthorId_to_name_and_affiliation.json&quot;</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pa_name_aff[<span class="string">&#x27;1156615|2085584&#x27;</span>] </span><br><span class="line">&#123;<span class="string">u&#x27;affiliation&#x27;</span>: <span class="string">u&#x27;Huawei##Microsoft Research Asia&#x27;</span>, <span class="string">u&#x27;name&#x27;</span>: <span class="string">u&#x27;Hang Li##Hang Li&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p><u>训 练 集</u>  ：<code>Train.csv</code> 。 ComfirmedPaperIds 列 对 应 的 表 示 该 作 者 写 了 这 些 论 文 的 列 表 ， DeletedPaperIds 列对应的表示该作者没有写这些论文论文。</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">AuthorId</td><td style="text-align:left">int</td><td style="text-align:left">作者ID</td></tr><tr><td style="text-align:left">ComfirmedPaperIds</td><td style="text-align:left">string</td><td style="text-align:left">以空格分割的论文列表</td></tr><tr><td style="text-align:left">DeletedPaperIds</td><td style="text-align:left">string</td><td style="text-align:left">以空格分割的论文列表</td></tr></tbody></table></div><ul><li><u>验证集</u> ： <code>Valid.csv</code>文件的格式如下：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">字段名称</th><th style="text-align:left">数据类型</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">AuthorId</td><td style="text-align:left">int</td><td style="text-align:left">作者ID</td></tr><tr><td style="text-align:left">PaperIds</td><td style="text-align:left">string</td><td style="text-align:left">以空格分割的论文列表，待测的论文列表</td></tr></tbody></table></div><ul><li><p><u>测试集</u> ：<code>Test.csv</code>。测试集 <code>Test.csv</code>文件的格式与验证集 <code>Valid.csv</code> 格式相同。</p></li><li><p>数据集的统计：</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">数据集</th><th style="text-align:left">（作者-论文）对个数</th></tr></thead><tbody><tr><td style="text-align:left">训练集</td><td style="text-align:left">11263</td></tr><tr><td style="text-align:left">验证集</td><td style="text-align:left">2347</td></tr><tr><td style="text-align:left">测试集</td><td style="text-align:left">1300</td></tr></tbody></table></div><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li>根据任务的目标，从给定的数据集合中构造出训练正负样本/测试样本；</li><li>从给定的数据集合中，对构造出的训练样本/测试样本进行特征的设计和抽取，并针对每个训练样本/测试样本生成相应的特征集合；</li><li>选择分类算法，在训练样本生成的特征集合上构造分类器；</li><li>使用分类器对测试样本的特征集合进行预测，并将分类器的预测结果转换为任务要求的提交格式。</li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li><p>构造训练/测试的正负样本</p><ul><li>构建训练样本。 系统从 <code>data/dataset/train_set/Train.csv</code> 中构建训练集的正负样本。 <ul><li>将 authorId 与 ConfirmedPaperIds 中的每个 paperId 组合，作为正样本（label 为 1）； </li><li>将 authorId 与 DeletedPaperIds 中的每个 paperId 组合，作为负样本（label 为 0）。</li></ul></li><li>构建测试样本。系统从 <code>data/dataset/valid_set/Valid.csv</code> 或 <code>data/dataset/test_set/Test.csv</code>  中构建测试样本。 由于测试集的类标是待预测的，这里直接将其赋值为 -1。</li></ul></li><li><p>构造特征</p><p>分 别 为 每 一 个 训 练 ／ 测 试 样 本 设 计 并 抽 取 特 征 。 特 征 抽 取 函 数 位 于 <code>model_trainer/feature_functions.py</code> 中。</p><p>目前基准系统实现的特征有：</p><ul><li><p>共作者特征（共作者的相似度特征） </p><p>一篇论文会存在多个作者，根据 <code>PaperAuthor.csv</code> 统计每一个作者的 top 10（也可以是 top 20 或者其他 top K）的共作者 coauthor（本系统从 <code>PaperAuthor.csv</code> 获取了每个作 者 top 10 的 共作者，保存在 <code>coauthor.json</code> 文件中。）。对于一个作者论文对（aid，pid）， 计算 PaperId 为 pid 的论文作者是否出现在 AuthorId 为 aid 的作者的 top 10 coauthor  中。有两种计算方式：</p><ul><li>计算 PaperId 为 pid 的论文的作者在 AuthorId 为 aid 的作者的 top 10 coauthor 中出现的 人（个）数，作为一个特征。</li><li>计算 PaperId 为 pid 的论文的作者，与在 AuthorId 为 aid 的作者的 top 10 coauthor  中的 作者的合作次数进行累加，将累加后的次数作为一个特征。</li></ul></li><li><p>字符串距离特征（计算作者名字和单位相似度特征）</p><p>假设当前的作者论文对是(aid,pid), 从 <code>paperIdAuthorId_to_name_and_affiliation.json</code>  里得到 的 name 串和 affiliation 串分别为 name1##name2##name3, aff1##aff2##aff3,  根据 aid 从 <code>Author.csv</code> 表找到的 name 和 affliction 分别为 name-a，affliction-a，这样 我们可以计算字符串的距离。</p><p>特征计算方式有两种：</p><ul><li>计算 name-a 与,name1##name2##name3 的距离；类似地，计算 affliction-a  和,aff1##aff2##aff3 的距离。</li><li>分别计算 name-a 与 name1，name2 和 name3 的各自距离，然后对这三个距 离取平 均；类似地，计算 affliction-a 和,aff1，aff2，aff3 的平均距离。</li></ul><p>距离（相似度）的度量实现以下四种：</p><ul><li>编辑距离</li><li>最长公共子序列（LCS）</li><li>最长公共子串（LSS）</li><li>余弦相似度</li></ul></li><li><p>作者 aid 之前发表的论文的 journal 和 conference，与当前的论文 pid 的 journal 和 conference 之间的相似度。</p></li><li><p>论文的 keyword 相似度</p><p>作者 A 写过的论文的 keyword 构成一个集合 X，一篇论文 B 的 keyword 构成一个集合 Y， 这里 的 keyword 指的是论文的 title 和 keyword 分词后得到的单词，对于一个作者论文对（A， B） 计算他们的 keyword 的交集或者相似度：X∩Y。 每个单词可以计算类似于 tf-idf 的分数， 最后 把属于 X∩Y 的单词的分数累加起来作为一维特征。</p></li></ul></li><li><p>分类器选择</p><p>每一种分类器，对应于一个类（class），目前系统实现的分类器有：</p><ul><li>Decision Tree</li><li>Naive Bayes</li><li>KNN</li><li>SVM</li><li>Logister Regreation</li><li>Random Forest</li><li>AdaBoost</li><li>VotingClassifier</li></ul></li><li><p>数据预处理</p><p>主要是数据清洗和集成。</p></li></ol><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>经过多次实验，发现用了 boost 思想的 adaboost，和 bagging 思想的 vote 准确率是最高的。</p><p><img src="4.png" alt="4"></p><p>代码地址：</p><p><a href="https://github.com/10185102110/KDD/tree/main/KDD_Benchmark">https://github.com/10185102110/KDD/tree/main/KDD_Benchmark</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验任务&quot;&gt;&lt;a href=&quot;#实验任务&quot; class=&quot;headerlink&quot; title=&quot;实验任务&quot;&gt;&lt;/a&gt;实验任务&lt;/h2&gt;&lt;p&gt;给定作者 ID 和论文 ID，判断该作者是否写了这篇论文。&lt;/p&gt;
&lt;h2 id=&quot;目录介绍&quot;&gt;&lt;a href=&quot;#目录介绍</summary>
      
    
    
    
    
    <category term="数据挖掘" scheme="http://10185102110.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>基于GaussDB的招聘与就业信息管理系统</title>
    <link href="http://10185102110.github.io/2021/07/12/%E5%9F%BA%E4%BA%8EGaussDB%E7%9A%84%E6%8B%9B%E8%81%98%E4%B8%8E%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://10185102110.github.io/2021/07/12/%E5%9F%BA%E4%BA%8EGaussDB%E7%9A%84%E6%8B%9B%E8%81%98%E4%B8%8E%E5%B0%B1%E4%B8%9A%E4%BF%A1%E6%81%AF%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-12T08:24:40.000Z</published>
    <updated>2021-07-12T09:03:04.015Z</updated>
    
    <content type="html"><![CDATA[<p>基于云数据库 GaussDB(for MySQL)实现，使用华为云账号进行操作。</p><h2 id="系统描述"><a href="#系统描述" class="headerlink" title="系统描述"></a>系统描述</h2><p>大学毕业生要就业，企业要吸收新鲜血液，学校作为两者之间的桥梁，需要进行信息的集成和管理，便于对毕业生就业与企业招聘信息进行管理和调研。 </p><p>本系统主要面对三种用户，学校管理机构、毕业生、企业。 </p><ul><li><p>管理机构人员可以对本校毕业生、面向本校的招聘会和参会企业的基本信息进行查询和修改，同时对毕业生参会、面试、聘用情况进行查询， 最后获得企业用人倾向和毕业生择业倾向的统计分析结果。 </p></li><li><p>毕业生可以对个人信息修改，对企业和招聘会的信息进行查询。 </p></li><li><p>企业可以对本企业信息和招聘会投递岗位信息进行修改和查询。 </p></li></ul><p>本系统集成了学校、毕业生、企业三方信息，便于学生了解和参与本校与企业合作提供的招聘会，同时方便学校做信息调研。</p><h2 id="应用程序功能"><a href="#应用程序功能" class="headerlink" title="应用程序功能"></a>应用程序功能</h2><p>(1) 对所有用户开放：</p><p> 招聘会基本信息的查询 </p><p>招聘会参会企业的查询</p><p> (2) 对学生开放： </p><p>自己基本信息的编辑 </p><p>自己学业信息的编辑 </p><p>报名招聘会 </p><p>(3) 对企业开放： </p><p>本企业信息的编辑 </p><p>毕业生的面试和聘用情况的录入</p><p> (4) 对学校开放： </p><p>招聘与就业信息的查询、统计和分析</p><h2 id="系统-rm-E-R-图"><a href="#系统-rm-E-R-图" class="headerlink" title="系统 $\rm{E-R}$ 图"></a>系统 $\rm{E-R}$ 图</h2><p><img src="1.png" alt="1"></p><h2 id="关系模式设计"><a href="#关系模式设计" class="headerlink" title="关系模式设计"></a>关系模式设计</h2><p>根据概念结构设计得到的 E-R 图和转换规则，得到如下关系模式（主键用下 划线标出，外键予以说明）：</p><ul><li>基本信息：学号、姓名、籍贯、出生日期、性别、身份证号、政治面貌、 民族、婚姻状况、户口所在地、联系电话、电子邮箱。 </li><li>学业信息：学号、学院、专业、最高学历、均绩、英语水平、计算机水平、普通话水平、实习经历、竞赛经历、项目经历。学号外键参考基本信息。 </li><li>招聘会：编号、名称、日期、地址。 </li><li>企业：编号、名称、类型、社会信用代码、城市、邮政代码、联系地址。 </li><li>参会：学号、招聘会编号。学号外键参考基本信息，招聘会编号外键参考招聘会。 </li><li>招聘信息包括：招聘会编号、企业编号、岗位、人数、薪资。 招聘会编号外键参考招聘会，企业编号外键参考企业。 </li><li>面试： 学号、企业编号、岗位、聘用、薪资。学号外键参考基本信息， 企业编号外键参考企业。 </li><li>账户：账号、密码、权限。</li></ul><h2 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h2><video src="http://qw4inwd8e.hd-bkt.clouddn.com/video/%E7%89%9F%E8%83%9C%E6%9D%B0_%E7%99%BD%E5%A3%AB%E5%86%9B_%E9%99%88%E5%89%91%E9%9D%92%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E4%B8%9A%E5%B1%95%E7%A4%BA.mp4" controls="controls" style="max-width: 100%; display: block; margin-left: auto; margin-right: auto;"> your browser does not support the video tag </video><p>代码地址：</p><p><a href="https://github.com/10185102110/Recruitment-and-employment-information-management-system">10185102110/Recruitment-and-employment-information-management-system (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于云数据库 GaussDB(for MySQL)实现，使用华为云账号进行操作。&lt;/p&gt;
&lt;h2 id=&quot;系统描述&quot;&gt;&lt;a href=&quot;#系统描述&quot; class=&quot;headerlink&quot; title=&quot;系统描述&quot;&gt;&lt;/a&gt;系统描述&lt;/h2&gt;&lt;p&gt;大学毕业生要就业，企业要吸收</summary>
      
    
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于openpose的手势识别</title>
    <link href="http://10185102110.github.io/2021/06/13/%E5%9F%BA%E4%BA%8Eopenpose%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/"/>
    <id>http://10185102110.github.io/2021/06/13/%E5%9F%BA%E4%BA%8Eopenpose%E7%9A%84%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB/</id>
    <published>2021-06-13T07:31:03.000Z</published>
    <updated>2021-06-13T09:07:37.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多视图引导的手部关键点检测"><a href="#多视图引导的手部关键点检测" class="headerlink" title="多视图引导的手部关键点检测"></a>多视图引导的手部关键点检测</h3><p>作者提出了一种称为 Multiview Bootstrapping 的手部关键点检测迭代改进算法。</p><h4 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h4><p>首先，采用少量标注的人手部关键点图像数据集训练网络，用31个高清摄像头从不同的视角对人手部进行拍摄，</p><p>将拍摄图像送入手部关键点检测器，初步得到粗略的关键点检测结果，再将这些关键点根据摄像机位姿构建三角，</p><p>得到关键点的3D位置，然后将计算得到的3D点位置重投影到每一幅不同视角的2D图像，最后用这些2D图像和关</p><p>键点进一步训练网络，经过几次迭代就能得到较为精确的手部关键点检测模型。</p><h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><p>(1) 定义一个检测器d，I表示图像，$X_p$表示预测关键点坐标，$C_p$表示置信度，P表示点的个数；</p><p>(2) 对于初始化训练集$T_0$：f表示图像帧，每帧$N_0$个视图，y表示真实标签；</p><p>(3) 初始化检测器d；</p><p>(4) 对于未标定数据集$T_1$，用$d_0$进行预测标记，得到检测器$d_1$。用$d_0$标记$T_1$时需要基于多视图几何进行监督，至</p><p>少存在2个视图检测成功，才能保证$T_1$中不包含$T_0$已经存在的信息；</p><p>(5) 预测每一个视图；</p><p>(6) 最小化重投影误差，三角化3D关键点；</p><p>(7) 根据置信度的和对视图排序，只选择成功的视图进行三维重建；</p><p>(8) 重投影到失败视图，生成N帧视图，用于迭代训练检测器。</p><script type="math/tex; mode=display">\begin{align*}  & d(\rm{I})\rightarrow \{(X_p,C_p)\ \rm{for}\ \ p \in [1\dots\it{P}\rm{]}\}\tag{1}\\  & T_0:=\{(I^f,\{y_p^f\})\ \rm{for}\ f\in[1\dots \it{N_0}\rm{]}\}\tag{2}\\  & d_0\leftarrow \rm{train}(T_0)\tag{3}\\  & d_1\leftarrow \rm{train}(T_0\cup T_1)\tag{4}\\  & D\leftarrow\{d_i(\rm{I}_v^f)\ \rm{for}\ \it{v}\in\rm{[}1\dots V]\}\tag{5}\\  & \rm{X}_p^f=arg\ \underset{X}min\sum\limits_{v\in I_p^f}||\it{P}_v\rm{(X)}-X_p^v||_2^2\tag{6}\\  & \rm{score}(\{X_p^f\})=\sum\limits_{p\in[1\dots P]}\sum\limits_{v\in I_p^f}c_p^v\tag{7}\\  & T_{i+1}=\{\rm{(I_v^{Sn}},\{P_v(X_p^{Sn}):v\in [1\dots V],p\in [1\dots P]\})\ for\ n\in[1\dots N\}\tag{8}\end{align*}</script><p><img src="2.png" alt=""></p><p><img src="0.png" alt=""></p><h4 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h4><p>采用CPM (Convolutional Pose Machines) 网络：</p><p>CPM是由全卷积网络组成的序列化结构，卷积网络直接在前一阶段的置信图操作，输出越来越精细化的关节点位</p><p>置估计结果。</p><p><img src="1.png" alt=""></p><p>流程：</p><ul><li>基于每个尺度，计算网络预测的各关节点的热力图</li><li>累加各个关节点对应的所有尺度的热力图，取最大值所在位置为关节点位置</li></ul><p><img src="3.png" alt=""></p><p>文中提出的模型可生成22个关键点，其中21个点是人手部的，第22个点代表背景。</p><p><img src="line.png" alt=""></p><p><img src="dot.png" alt=""></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protoFile = <span class="string">r&quot;C:\Users\AveBai\Desktop\model\pose_deploy.prototxt&quot;</span></span><br><span class="line">weightsFile = <span class="string">r&quot;C:\Users\AveBai\Desktop\model\pose_iter_102000.caffemodel&quot;</span></span><br><span class="line">nPoints = <span class="number">22</span></span><br><span class="line">POSE_PAIRS = [ [<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">0</span>,<span class="number">9</span>],[<span class="number">9</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">11</span>],[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">0</span>,<span class="number">13</span>],[<span class="number">13</span>,<span class="number">14</span>],[<span class="number">14</span>,<span class="number">15</span>],[<span class="number">15</span>,<span class="number">16</span>],[<span class="number">0</span>,<span class="number">17</span>],[<span class="number">17</span>,<span class="number">18</span>],[<span class="number">18</span>,<span class="number">19</span>],[<span class="number">19</span>,<span class="number">20</span>] ]</span><br><span class="line"></span><br><span class="line">threshold = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line">input_source = <span class="string">r&quot;C:\Users\AveBai\Desktop\img\1.mp4&quot;</span></span><br><span class="line">cap = cv2.VideoCapture(input_source)</span><br><span class="line">hasFrame, frame = cap.read()</span><br><span class="line"></span><br><span class="line">frameWidth = frame.shape[<span class="number">1</span>]</span><br><span class="line">frameHeight = frame.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">aspect_ratio = frameWidth/frameHeight</span><br><span class="line"></span><br><span class="line">inHeight = <span class="number">368</span></span><br><span class="line">inWidth = <span class="built_in">int</span>(((aspect_ratio*inHeight)*<span class="number">8</span>)//<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">vid_writer = cv2.VideoWriter(<span class="string">r&#x27;C:\Users\AveBai\Desktop\res\output.avi&#x27;</span>,cv2.VideoWriter_fourcc(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;G&#x27;</span>), <span class="number">15</span>, (frame.shape[<span class="number">1</span>],frame.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">net = cv2.dnn.readNetFromCaffe(protoFile, weightsFile)</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    k+=<span class="number">1</span></span><br><span class="line">    t = time.time()</span><br><span class="line">    hasFrame, frame = cap.read()</span><br><span class="line">    frameCopy = np.copy(frame)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasFrame:</span><br><span class="line">        cv2.waitKey()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    inpBlob = cv2.dnn.blobFromImage(frame, <span class="number">1.0</span> / <span class="number">255</span>, (inWidth, inHeight),    <span class="comment"># 图像归一化</span></span><br><span class="line">                              (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), swapRB=<span class="literal">False</span>, crop=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    net.setInput(inpBlob)  <span class="comment"># 将图片输入到caffe网络中</span></span><br><span class="line"></span><br><span class="line">    output = net.forward()   <span class="comment"># 前向传播</span></span><br><span class="line"></span><br><span class="line">    points = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nPoints):</span><br><span class="line">        <span class="comment"># 置信度</span></span><br><span class="line">        probMap = output[<span class="number">0</span>, i, :, :]</span><br><span class="line">        probMap = cv2.resize(probMap, (frameWidth, frameHeight))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 精确定位</span></span><br><span class="line">        minVal, prob, minLoc, point = cv2.minMaxLoc(probMap)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prob &gt; threshold :</span><br><span class="line">            cv2.circle(frameCopy, (<span class="built_in">int</span>(point[<span class="number">0</span>]), <span class="built_in">int</span>(point[<span class="number">1</span>])), <span class="number">6</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>, lineType=cv2.FILLED)</span><br><span class="line">            cv2.putText(frameCopy, <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i), (<span class="built_in">int</span>(point[<span class="number">0</span>]), <span class="built_in">int</span>(point[<span class="number">1</span>])), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">.8</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, lineType=cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line">            points.append((<span class="built_in">int</span>(point[<span class="number">0</span>]), <span class="built_in">int</span>(point[<span class="number">1</span>])))</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            points.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pair <span class="keyword">in</span> POSE_PAIRS:</span><br><span class="line">        partA = pair[<span class="number">0</span>]</span><br><span class="line">        partB = pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> points[partA] <span class="keyword">and</span> points[partB]:</span><br><span class="line">            cv2.line(frame, points[partA], points[partB], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>, lineType=cv2.LINE_AA)</span><br><span class="line">            cv2.circle(frame, points[partA], <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>, lineType=cv2.FILLED)</span><br><span class="line">            cv2.circle(frame, points[partB], <span class="number">5</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), thickness=-<span class="number">1</span>, lineType=cv2.FILLED)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;time a frame = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(time.time() - t))</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Output&#x27;</span>, frame)</span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;total time= &#123;&#125;&quot;</span>.<span class="built_in">format</span>(time.time() - t))</span><br><span class="line"></span><br><span class="line">    vid_writer.write(frame)</span><br><span class="line"></span><br><span class="line">vid_writer.release()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h4><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=546123557&bvid=BV1uq4y1L7X9&cid=353519444&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ul><li><p>Hand Keypoint Detection in Single Images using Multiview Bootstrapping</p><p><a href="https://arxiv.org/pdf/1704.07809.pdf">https://arxiv.org/pdf/1704.07809.pdf</a></p></li><li><p>Convolutional Pose Machines</p><p><a href="https://arxiv.org/pdf/1602.00134.pdf">https://arxiv.org/pdf/1602.00134.pdf</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多视图引导的手部关键点检测&quot;&gt;&lt;a href=&quot;#多视图引导的手部关键点检测&quot; class=&quot;headerlink&quot; title=&quot;多视图引导的手部关键点检测&quot;&gt;&lt;/a&gt;多视图引导的手部关键点检测&lt;/h3&gt;&lt;p&gt;作者提出了一种称为 Multiview Bootst</summary>
      
    
    
    
    <category term="openpose" scheme="http://10185102110.github.io/categories/openpose/"/>
    
    
    <category term="openpose" scheme="http://10185102110.github.io/tags/openpose/"/>
    
  </entry>
  
  <entry>
    <title>C++笔记</title>
    <link href="http://10185102110.github.io/2021/05/16/CPP%E7%AC%94%E8%AE%B0/"/>
    <id>http://10185102110.github.io/2021/05/16/CPP%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-16T09:13:40.000Z</published>
    <updated>2021-05-16T10:02:30.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector 是C++ STL的一个重要成员，使用它时需要包含头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>;</span></span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>有五种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量，但没有给出初值。</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量,且给出每个元素的初值为1</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//用b向量来创建a向量，整体复制性赋值</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>; <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>)</span></span>; <span class="comment">//从数组中获得初值</span></span><br></pre></td></tr></table></figure><h4 id="重要操作"><a href="#重要操作" class="headerlink" title="重要操作"></a>重要操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//a只含4个元素，且每个元素为2</span></span><br><span class="line">a.<span class="built_in">back</span>(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">a.<span class="built_in">front</span>(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在</span></span><br><span class="line">a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">a.<span class="built_in">empty</span>(); <span class="comment">//判断a是否为空，空则返回ture,否则返回false</span></span><br><span class="line">a.<span class="built_in">pop_back</span>(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素</span></span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素的位置插入b的第3个元素到第5个元素</span></span><br><span class="line">a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">a.<span class="built_in">capacity</span>(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，避免内存自动进行容量扩充操作</span></span><br><span class="line">a.<span class="built_in">swap</span>(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br></pre></td></tr></table></figure><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ul><li><p>添加元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>从数组中选择元素添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=a.<span class="built_in">begin</span>();it&lt;a.<span class="built_in">end</span>();it++)</span><br><span class="line">    b.<span class="built_in">push_back</span>(*it);</span><br></pre></td></tr></table></figure></li><li><p>从文件读取元素并添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; in&gt;&gt;i)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>通过下标读取元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=b.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">    cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="重要算法"><a href="#重要算法" class="headerlink" title="重要算法"></a>重要算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括）到a.end()（不包括）的元素进行从小到大排列</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括）到a.end()（不包括）的元素倒置</span></span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括）到a.end()（不包括）的元素复制到b中，从b.begin()+1的位置（包括）开始复制，覆盖原有元素</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括）到a.end()（不包括）的元素中查找10，若存在返回其在向量中的位置</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是STL的一个关联容器，它提供一对一的hash。</p><p>map内部的实现是自建一颗红黑树，这颗树具有对数据自动排序的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>, string&gt; m;</span><br></pre></td></tr></table></figure><h4 id="重要操作-1"><a href="#重要操作-1" class="headerlink" title="重要操作"></a>重要操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>));</span><br><span class="line">m[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line">iter = m.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);<span class="comment">//返回查找元素的位置否则返回map::end()位置</span></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(iter);</span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(), m.<span class="built_in">end</span>());<span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">clear</span>();<span class="comment">//清空</span></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="keyword">int</span> n = m.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()<span class="comment">//如果map为空则返回true</span></span><br><span class="line"><span class="built_in">lower_bound</span>()<span class="comment">//返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line"><span class="built_in">max_size</span>()    <span class="comment">//返回可以容纳的最大元素个数</span></span><br><span class="line"><span class="built_in">swap</span>()   <span class="comment">//交换两个map</span></span><br><span class="line"><span class="built_in">count</span>(key)  <span class="comment">//查询关键字为key的元素的个数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector 是C++ S</summary>
      
    
    
    
    <category term="C++" scheme="http://10185102110.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://10185102110.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>DNS的配置与管理</title>
    <link href="http://10185102110.github.io/2021/05/14/DNS%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>http://10185102110.github.io/2021/05/14/DNS%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-14T14:14:36.000Z</published>
    <updated>2021-05-14T15:40:52.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS的配置与管理"><a href="#DNS的配置与管理" class="headerlink" title="DNS的配置与管理"></a>DNS的配置与管理</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><ol><li><h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h3></li></ol><ul><li>全称：Domain Name System /域名系统</li><li>使域名和 IP 地址相互映射</li><li>域名解析：通过主机名，最终得到该主机名对应的IP地址的过程</li></ul><ol><li><h3 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h3></li></ol><ul><li><p>概念：与网络上的数字型IP地址相对应的字符型地址</p></li><li><p>一般结构：主机名.三级域名.二级域名.顶级域名</p><p>– 顶级域名：cn、jp … edu、org …</p><p>– 二级域名：ibm、yahoo … com、edu、net、gov、top …</p><p>– 三级域名：A-Z, a-z, 0-9, 连接符 -</p></li></ul><ol><li><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3></li></ol><ul><li>第0步：检查本地缓存</li><li>第1步：向本地DNS服务器请求</li><li>第2步：向根域名服务器请求</li><li>第3步：向顶级域名服务器请求</li><li>第4步：向权威域名服务器请求</li><li>一旦成功：返回结果，缓存留作备用，解析过程中止</li></ul><ol><li><h3 id="DNS查询模式"><a href="#DNS查询模式" class="headerlink" title="DNS查询模式"></a>DNS查询模式</h3></li></ol><ul><li>递归查询：若自身不能，则以客户身份请求其他，客户机和服务器之间属于递归查询</li><li><p>循环查询：若自身不能，则指导客户请求其他，一般DNS服务器之间属于循环查询</p></li><li><p>正向解析：通过域名查 ip</p></li><li>反向解析：通过 ip 查域名</li></ul><ol><li><h3 id="DNS服务器类型"><a href="#DNS服务器类型" class="headerlink" title="DNS服务器类型"></a>DNS服务器类型</h3></li></ol><ul><li>主域名服务器 master </li><li>辅助域名服务器 slave </li><li>缓存服务器 Caching-only</li></ul><ol><li><h3 id="DNS资源记录"><a href="#DNS资源记录" class="headerlink" title="DNS资源记录"></a>DNS资源记录</h3></li></ol><ul><li>SOA记录（Start Of Authority record）起始授权记录</li><li>NS 记录(Name Server record)当前区域的DNS服务器</li><li>A 和 AAAA 记录（Adress record）</li><li>PTR 记录（PoinTer Record）全限定域名</li><li>CNAME（Canonical Name record）别名记录</li><li>MX 记录（Mail eXchange record）邮件交换器</li></ul><h2 id="二、项目实施"><a href="#二、项目实施" class="headerlink" title="二、项目实施"></a>二、项目实施</h2><ol><li><h3 id="安装-DNS-服务软件"><a href="#安装-DNS-服务软件" class="headerlink" title="安装 DNS 服务软件"></a>安装 DNS 服务软件</h3></li></ol><ul><li><p>bind：DNS服务主程序，仅服务器端需要</p></li><li><p>bind-utils：辅助工具，用于测试 DNS，服务器和客户端都需要</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install bind bind-utils</span><br><span class="line">注：本实验基于上次的DHCP，先把网络连接方式改成NAT，再将ifcfg-enp0s3文件恢复原样，</span><br><span class="line">最后重启网卡：service network restart ，安装成功再改回DHCP的配置</span><br></pre></td></tr></table></figure></li></ul><ol><li><h3 id="修改主服务器主配置文件：-etc-named-conf"><a href="#修改主服务器主配置文件：-etc-named-conf" class="headerlink" title="修改主服务器主配置文件：/etc/named.conf"></a>修改主服务器主配置文件：/etc/named.conf</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">  listen-on port 53 &#123; any; &#125;; // 在本机所有网卡的#53端口监听</span><br><span class="line">  ……</span><br><span class="line">  directory &quot;/var/named&quot;;</span><br><span class="line">  ……</span><br><span class="line">  allow-query &#123; any; &#125;; // 允许所有客户端请求</span><br><span class="line">  ……</span><br><span class="line">&#125;;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><h3 id="主服务器扩展配置文件：-etc-named-rfc1912-zones"><a href="#主服务器扩展配置文件：-etc-named-rfc1912-zones" class="headerlink" title="主服务器扩展配置文件：/etc/named.rfc1912.zones"></a>主服务器扩展配置文件：/etc/named.rfc1912.zones</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 在前面添加如下代码</span></span><br><span class="line">zone &quot;ecnu.edu&quot; IN &#123; // 正向解析信息</span><br><span class="line">type master; // 主服务器</span><br><span class="line">file &quot;ecnu.edu.zone&quot;; // 区域文件名</span><br><span class="line">allow-update &#123;192.168.100.2;&#125;; // 填写从服务器，若无，则填 none</span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;100.168.192.in-addr.arpa&quot; IN &#123; // 反向解析信息</span><br><span class="line">type master; // 主服务器</span><br><span class="line">file &quot;192.168.100.arpa&quot;; // 区域文件名</span><br><span class="line">allow-update &#123;192.168.100.2;&#125;; // 从服务器</span><br><span class="line">&#125;;</span><br><span class="line">…</span><br></pre></td></tr></table></figure></li><li><h3 id="正向解析文件：-var-named-ecnu-edu-zone"><a href="#正向解析文件：-var-named-ecnu-edu-zone" class="headerlink" title="正向解析文件：/var/named/ecnu.edu.zone"></a>正向解析文件：/var/named/ecnu.edu.zone</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv named]#cp -a named.localhost ecnu.ed</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$TTL 1D</span><br><span class="line">@ IN SOA ns1.ecnu.edu. admin.ecnu.edu. ( // ns1:DNS服务器 // 联系 admin@ecnu.edu</span><br><span class="line">  0 ; serial</span><br><span class="line">  1D ; refresh</span><br><span class="line">  1H ; retry</span><br><span class="line">  1W ; expire</span><br><span class="line">  3H ); minimum</span><br><span class="line"><span class="code">      IN NS ns1.ecnu.edu. // DNS服务器</span></span><br><span class="line"><span class="code">dhcp  IN A 192.168.100.1 // 定义域名与IP地址的映射</span></span><br><span class="line"><span class="code">ns1   IN A 192.168.100.1</span></span><br><span class="line"><span class="code">ns2   IN A 192.168.100.2</span></span><br><span class="line"><span class="code">ftp   IN A 192.168.100.10</span></span><br><span class="line"><span class="code">www   IN A 192.168.100.20</span></span><br><span class="line"><span class="code">mail  IN A 192.168.100.30</span></span><br></pre></td></tr></table></figure></li><li><h3 id="反向解析文件：-var-named-192-168-100-arpa"><a href="#反向解析文件：-var-named-192-168-100-arpa" class="headerlink" title="反向解析文件：/var/named/192.168.100.arpa"></a>反向解析文件：/var/named/192.168.100.arpa</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv named]#cp -a named.loopback 192.168.100.arpa</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$TTL 1D</span><br><span class="line">@ IN SOA ns1.ecnu.edu. admin.ecnu.edu. ( // ns1:DNS服务器 // 联系 admin@ecnu.edu</span><br><span class="line">  0 ; serial</span><br><span class="line">  1D ; refresh</span><br><span class="line">  1H ; retry</span><br><span class="line">  1W ; expire</span><br><span class="line">  3H ); minimum</span><br><span class="line"><span class="code">      IN NS ns1.ecnu.edu. // DNS服务器</span></span><br><span class="line"><span class="code">ns1   IN A 192.168.100.1</span></span><br><span class="line"><span class="code">1     IN PTR dhcp.ecnu.edu. // 定义IP地址与域名的映射</span></span><br><span class="line"><span class="code">1     IN PTR ns1.ecnu.edu.</span></span><br><span class="line"><span class="code">2     IN PTR ns2.ecnu.edu.</span></span><br><span class="line"><span class="code">10    IN PTR ftp.ecnu.edu.</span></span><br><span class="line"><span class="code">20    IN PTR www.ecnu.edu.</span></span><br><span class="line"><span class="code">30    IN PTR mail.ecnu.edu.</span></span><br></pre></td></tr></table></figure></li><li><h3 id="本机测试"><a href="#本机测试" class="headerlink" title="本机测试"></a>本机测试</h3></li></ol><ul><li><p>启动服务器</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv ~]# systemctl start named</span><br></pre></td></tr></table></figure></li><li><p>确保服务器指向本机</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Srv ~]# cat /etc/resolv.conf</span><br><span class="line">nameserver 192.168.100.1</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="1.png" alt=""></p></li></ul><ol><li><h3 id="异机测试"><a href="#异机测试" class="headerlink" title="异机测试"></a>异机测试</h3><p>即开启DHCP服务后，结果同上</p></li><li><h3 id="配置辅助DNS服务器及测试"><a href="#配置辅助DNS服务器及测试" class="headerlink" title="配置辅助DNS服务器及测试"></a>配置辅助DNS服务器及测试</h3></li></ol><ul><li><p>复制虚拟机 Srv2</p></li><li><p>关闭 Srv 和 Srv2 的防火墙</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure></li><li><p>修改 /etc/resolv.conf 将客户端 DNS 改为192.168.100.2</p></li><li><p>修改 /etc/named.rfc1912.zones</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;ecnu.edu&quot; IN &#123;</span><br><span class="line">  type slave;</span><br><span class="line">  file &quot;slaves/ecnu.edu.zone&quot;;</span><br><span class="line">  masters &#123;192.168.100.1;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;100.168.192.in-addr.arpa&quot; IN &#123;</span><br><span class="line">  type slave;</span><br><span class="line">  file &quot;slaves/192.168.100.arpa&quot;;</span><br><span class="line">  masters &#123;192.168.100.1;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>重启服务器，/var/named/slaves 中已同步正/反向解析文件</p></li><li><p>测试</p><p><img src="2.png" alt=""></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DNS的配置与管理&quot;&gt;&lt;a href=&quot;#DNS的配置与管理&quot; class=&quot;headerlink&quot; title=&quot;DNS的配置与管理&quot;&gt;&lt;/a&gt;DNS的配置与管理&lt;/h1&gt;&lt;h2 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Server" scheme="http://10185102110.github.io/categories/Server/"/>
    
    
    <category term="Server、DNS" scheme="http://10185102110.github.io/tags/Server%E3%80%81DNS/"/>
    
  </entry>
  
  <entry>
    <title>DHCP的配置与管理</title>
    <link href="http://10185102110.github.io/2021/05/14/DHCP%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/"/>
    <id>http://10185102110.github.io/2021/05/14/DHCP%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%AE%A1%E7%90%86/</id>
    <published>2021-05-14T13:46:49.000Z</published>
    <updated>2021-05-16T08:14:46.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DHCP的配置与管理"><a href="#DHCP的配置与管理" class="headerlink" title="DHCP的配置与管理"></a>DHCP的配置与管理</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><ol><li><h3 id="什么是DHCP"><a href="#什么是DHCP" class="headerlink" title="什么是DHCP"></a>什么是DHCP</h3><p>– 全称：Dynamic Host Configuration Protocol ，动态主机配置协议 </p><p>– 是一个局域网的网络协议，使用UDP协议工作 </p><p>– 中、大型网络中手动分配IP地址的方法不合适 ，DHCP可高效分配IP地址 </p></li><li><h3 id="DHCP的主要功能"><a href="#DHCP的主要功能" class="headerlink" title="DHCP的主要功能"></a>DHCP的主要功能</h3><p>–为内部网络自动分配IP地址 </p><p>– 中央管理所有计算机的手段</p></li><li><h3 id="DHCP服务优点"><a href="#DHCP服务优点" class="headerlink" title="DHCP服务优点"></a>DHCP服务优点</h3><p>– 集中验证IP地址等参数，不必检查每个主机</p><p>– 不会分配相同IP给不同主机 </p><p>– 约束特定计算机使用特定IP </p><p>– 为DHCP作用域设置各种选项</p><p>– 子网间移动主机不需重设IP</p></li><li><h3 id="DHCP服务缺点"><a href="#DHCP服务缺点" class="headerlink" title="DHCP服务缺点"></a>DHCP服务缺点</h3><p>– 不能发现非DHCP客户机IP </p><p>– 多DHCP服务器难联动分配 </p><p>– DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发</p></li><li><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><p>– DHCP服务器：提供DHCP服务的计算机 </p><p>– DHCP客户端：启用DHCP设置的计算机 </p><p>– 作用域：完整连续的可用IP地址范围 </p><p>– 排除范围：作用域内从DHCP服务中排除的有限IP地址序列 </p><p>– 地址池：定义作用域并应用排除范围后剩余的地址 </p><p>– 租约：客户机可使用动态分配IP地址的时间 </p><ul><li><p>客户机发出租约后：此租约被看作是活动的 </p></li><li><p>租约终止前：客户机可向DHCP服务器请求更新租约 </p></li><li><p>租约到期或被删后：此租约变为不活动的 </p></li></ul></li></ol><p>– 预约：客户机指定永久租约</p><ol><li><h3 id="DCHP的工作流程"><a href="#DCHP的工作流程" class="headerlink" title="DCHP的工作流程"></a>DCHP的工作流程</h3><p>– 发现阶段：客户机寻找服务器 </p><p>– 提供阶段：服务器提供IP地址 </p><p>– 选择阶段：客户机选择某台服务器提供的IP地址 </p><p>– 确认阶段：服务器确认所提供的IP地址 </p><p>– 重新登录</p><ul><li>客户机重新登录网络时，不需再发送DHCPdiscover发现信息</li><li>直接发送包含前一次所分配的IP地址的DHCPrequest请求信息 </li></ul><p>– 更新租约</p><ul><li>出租IP有租借期限，期满后便收回</li><li>如要延长租约，则须更新租约</li></ul></li><li><h3 id="DHCP分配地址的方法"><a href="#DHCP分配地址的方法" class="headerlink" title="DHCP分配地址的方法"></a>DHCP分配地址的方法</h3><p>– 自动分配</p><ul><li>服务器为客户机指定永久IP地址</li><li>第一次成功租到IP地址后就可永久使用 </li></ul><p>– 动态分配</p><ul><li>服务器为客户机指定具时间限制的IP地址</li><li>到期或明确放弃该地址时可被其他客户机使用</li></ul><p>– 手工分配：客户机IP地址由网管指定</p></li></ol><h2 id="二、项目实施"><a href="#二、项目实施" class="headerlink" title="二、项目实施"></a>二、项目实施</h2><ol><li><h3 id="准备-3-台机器"><a href="#准备-3-台机器" class="headerlink" title="准备 3 台机器"></a>准备 3 台机器</h3><p>– 安装好 1 台CentOS虚拟机 </p><p>– 使用链接复制的方式复制3台 </p><ul><li>命名分别为 Srv、CliCent1和CliCent2</li><li>分别用作DHCP服务器、测试用客户端1和测试用客户端2 </li></ul><p><img src="1.png" alt=""></p><p><img src="2.png" alt=""></p><p>– 修改3台虚拟机的主机名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname [MYHOSTNAME]</span><br></pre></td></tr></table></figure><p>– 修改 3 台虚拟机的唯一编号</p><ul><li><p>/etc/machine-id</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uuidgen &gt;/etc/machine-id</span><br></pre></td></tr></table></figure></li><li><p>/etc/sysconfig/network-scripts/ifcfg-enp0s3</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/^UUID=[0-9a-z\-]<span class="emphasis">*$/UUID=`uuidgen`/g&quot; /etc/sysconfig/network-scripts/ifcfg-enp0s3</span></span><br></pre></td></tr></table></figure></li><li><p>uuidgen命令可产生唯一标识UUID</p></li></ul><p><img src="3.png" alt=""></p></li><li><h3 id="安装DHCP"><a href="#安装DHCP" class="headerlink" title="安装DHCP"></a>安装DHCP</h3><p>– yum安装命令 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install dhcp</span><br></pre></td></tr></table></figure><p>– 安装完后会生成主配置文件：/etc/dhcp/dhcpd.conf</p><p>– 确保客户机上安装有DHCP客户端程序 dhcp-clien</p></li><li><h3 id="配置DHCP"><a href="#配置DHCP" class="headerlink" title="配置DHCP"></a>配置DHCP</h3><p>– Srv主配置文件</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ddns-update-style none;</span><br><span class="line">option domain-name-servers 192.168.100.1;</span><br><span class="line">subnet 192.168.100.0 netmask 255.255.255.0 &#123;</span><br><span class="line">range 192.168.100.101 192.168.100.200;</span><br><span class="line">option routers 192.168.100.1;</span><br><span class="line">option subnet-mask 255.255.255.0;</span><br><span class="line">&#125;</span><br><span class="line">DHCPDARGS=&quot;enp0s3&quot;;</span><br><span class="line"><span class="section">#服务器IP是192.168.100.1</span></span><br><span class="line"><span class="section">#分本的地址是该网段的 192.168.100.101~192.168.100.200</span></span><br><span class="line"><span class="section">#绑定在 enp0s3网卡上</span></span><br></pre></td></tr></table></figure><p><img src="4.png" alt=""></p><p>– 修改Srv的网络配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOTPROTO=static   # 将IP地址设为静态</span><br><span class="line">IPADDR=192.168.100.1</span><br><span class="line">NETMASK=255.255.255.0</span><br></pre></td></tr></table></figure><p><img src="5.png" alt=""></p><p>– 客户机CliCent1和CliCent2 维持原状</p><p>– 改虚拟机的网络为内部网络并刷新网卡物理地址</p><p><img src="6.png" alt=""></p></li><li><p>启动服务器</p><p>– 在Srv上启动DHCP服务器</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start dhcp</span><br></pre></td></tr></table></figure><p><img src="7.png" alt=""></p><p>– 重启客户机CliCent1和CliCent2</p><ul><li>查看其IP地址</li><li>相互Ping检查是否相通</li></ul><p><img src="8.png" alt=""></p><p><img src="9.png" alt=""></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;DHCP的配置与管理&quot;&gt;&lt;a href=&quot;#DHCP的配置与管理&quot; class=&quot;headerlink&quot; title=&quot;DHCP的配置与管理&quot;&gt;&lt;/a&gt;DHCP的配置与管理&lt;/h1&gt;&lt;h2 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;</summary>
      
    
    
    
    <category term="Server" scheme="http://10185102110.github.io/categories/Server/"/>
    
    
    <category term="Server、DHCP" scheme="http://10185102110.github.io/tags/Server%E3%80%81DHCP/"/>
    
  </entry>
  
  <entry>
    <title>基于CF的单目标追踪</title>
    <link href="http://10185102110.github.io/2021/05/12/%E5%9F%BA%E4%BA%8ECF%E5%8D%95%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"/>
    <id>http://10185102110.github.io/2021/05/12/%E5%9F%BA%E4%BA%8ECF%E5%8D%95%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/</id>
    <published>2021-05-12T04:46:49.000Z</published>
    <updated>2021-06-13T08:28:30.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Correlation-Filter-based-tracker（相关滤波器）"><a href="#Correlation-Filter-based-tracker（相关滤波器）" class="headerlink" title="Correlation Filter based tracker（相关滤波器）"></a>Correlation Filter based tracker（相关滤波器）</h2><h4 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h4><p>寻找一个滤波模版 H，与输入图像 F 求相关性，得到相关图 G。相关图 G 描述目标响应，越接近时值越大，使得当 H 作用在跟踪目标上时，得到的响应最大。</p><h4 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h4><script type="math/tex; mode=display">\begin{eqnarray*}&&g=f\bigodot h^{*} \tag{1} \\&&F(g)=F(f⨀h^{*})=F(f)\cdot F(h)^{*} \tag{2}\\&&G=F\cdot H^{*} \tag{3}\\&&H^{*}=\frac{G}{F} \tag{4}\\&&\underset{H^{*}}{min}\sum\limits_{i}|F_{i}⊙H^{∗} − G_{i}|^{2}\tag{5}\\&&0=\frac{∂}{∂H^{*}_{ων}}\sum\limits_{i}|F_{iων}H^{∗}_{ων} − G_{iων}|^{2}\tag{6}\\&& H=\frac{\sum_i G_{i}⊙F^{∗}_i}{\sum_i F_{i}⊙F^{∗}_i}\tag{7}\\&&H^{*}_i=η\frac{G_{i}⊙F^{∗}_i}{F_{i}⊙F^{∗}_i}+(1-η)H^∗_{i−1}=\frac{A_i}{B_i} \tag{8}\\&&A_i=ηG_i ⊙ F^∗_i + (1 − η)A_{i−1}\\&&B_i=ηF_i ⊙ F^∗_i + (1 − η)B_{i−1}\end{eqnarray*}</script><ol><li><p>g 表示响应输出，f 表示输入图像，h 表示滤波模板，$h^{*}$表示复共轭(实部不变，虚部取反)；</p></li><li><p>为加快计算速度，根据卷积定理可知，函数互相关的傅里叶变换等于函数傅里叶变换的乘积；</p></li><li><p>由(2)得到；</p></li><li>由(3)得到，$H^{*}$就是所求滤波器；</li><li>MOSSE 采用最小化平方和误差；</li><li>将图像展开到像素，最小化求偏导等于 0；</li><li>最终得到求解公式；</li><li>在线更新策略，根据当前帧不断进行调整。</li></ol><h4 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h4><ul><li>run.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> basetracker</span><br><span class="line"></span><br><span class="line">initTracking = <span class="literal">True</span></span><br><span class="line">ix, iy, cx, cy = -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">w, h = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">inteval = <span class="number">1</span></span><br><span class="line">duration = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">cap = cv2.VideoCapture(<span class="string">&quot;CarScale.avi&quot;</span>)</span><br><span class="line"><span class="comment">#获取cap的视频帧</span></span><br><span class="line">fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line"><span class="comment"># 获取cap视频流的每帧大小</span></span><br><span class="line">size = (<span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH)),<span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line"><span class="comment"># 定义视频格式，参数搭配固定，不同的编码格式对应不同的参数</span></span><br><span class="line">fourcc = cv2.VideoWriter_fourcc(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line"><span class="comment"># 定义视频文件输入对象</span></span><br><span class="line">outVideo = cv2.VideoWriter(<span class="string">&quot;result.mp4&quot;</span>, fourcc, fps, size,isColor=<span class="literal">True</span>)</span><br><span class="line">inteval = <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">tracker = basetracker.BaseTracker(<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>)  <span class="comment"># hog, fixed_window, multiscale</span></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;tracking&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">ret, frame = cap.read()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(initTracking):</span><br><span class="line">r = cv2.selectROI(<span class="string">&#x27;tracking&#x27;</span>,frame)   <span class="comment">#????</span></span><br><span class="line">ix, iy, w, h = r</span><br><span class="line">tracker.init([ix,iy,w,h], frame)</span><br><span class="line">initTracking = <span class="literal">False</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">t0 = time()</span><br><span class="line">boundingbox = tracker.update(frame)</span><br><span class="line">t1 = time()</span><br><span class="line"></span><br><span class="line">boundingbox = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, boundingbox))</span><br><span class="line">cv2.rectangle(frame,(boundingbox[<span class="number">0</span>],boundingbox[<span class="number">1</span>]), (boundingbox[<span class="number">0</span>]+boundingbox[<span class="number">2</span>],boundingbox[<span class="number">1</span>]+boundingbox[<span class="number">3</span>]), (<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">duration = <span class="number">0.8</span>*duration + <span class="number">0.2</span>*(t1-t0)</span><br><span class="line"><span class="comment">#duration = t1-t0</span></span><br><span class="line">cv2.putText(frame, <span class="string">&#x27;FPS: &#x27;</span>+<span class="built_in">str</span>(<span class="number">1</span>/duration)[:<span class="number">4</span>].strip(<span class="string">&#x27;.&#x27;</span>), (<span class="number">8</span>,<span class="number">20</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.6</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用VideoWriter类中的write(frame)方法，将图像帧写入视频文件</span></span><br><span class="line">outVideo.write(frame)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;tracking&#x27;</span>, frame)</span><br><span class="line">c = cv2.waitKey(inteval) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">outVideo.release()</span><br><span class="line"><span class="comment">#cv2.waitKey()</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><ul><li>basetracker.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># recttools</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x2</span>(<span class="params">rect</span>):</span></span><br><span class="line">    <span class="keyword">return</span> rect[<span class="number">0</span>] + rect[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y2</span>(<span class="params">rect</span>):</span></span><br><span class="line">    <span class="keyword">return</span> rect[<span class="number">1</span>] + rect[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">limit</span>(<span class="params">rect, limit</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">0</span>] + rect[<span class="number">2</span>] &gt; limit[<span class="number">0</span>] + limit[<span class="number">2</span>]):</span><br><span class="line">        rect[<span class="number">2</span>] = limit[<span class="number">0</span>] + limit[<span class="number">2</span>] - rect[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">1</span>] + rect[<span class="number">3</span>] &gt; limit[<span class="number">1</span>] + limit[<span class="number">3</span>]):</span><br><span class="line">        rect[<span class="number">3</span>] = limit[<span class="number">1</span>] + limit[<span class="number">3</span>] - rect[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">0</span>] &lt; limit[<span class="number">0</span>]):</span><br><span class="line">        rect[<span class="number">2</span>] -= (limit[<span class="number">0</span>] - rect[<span class="number">0</span>])</span><br><span class="line">        rect[<span class="number">0</span>] = limit[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">1</span>] &lt; limit[<span class="number">1</span>]):</span><br><span class="line">        rect[<span class="number">3</span>] -= (limit[<span class="number">1</span>] - rect[<span class="number">1</span>])</span><br><span class="line">        rect[<span class="number">1</span>] = limit[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">2</span>] &lt; <span class="number">0</span>):</span><br><span class="line">        rect[<span class="number">2</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (rect[<span class="number">3</span>] &lt; <span class="number">0</span>):</span><br><span class="line">        rect[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> rect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getBorder</span>(<span class="params">original, limited</span>):</span></span><br><span class="line">    res = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    res[<span class="number">0</span>] = limited[<span class="number">0</span>] - original[<span class="number">0</span>]</span><br><span class="line">    res[<span class="number">1</span>] = limited[<span class="number">1</span>] - original[<span class="number">1</span>]</span><br><span class="line">    res[<span class="number">2</span>] = x2(original) - x2(limited)</span><br><span class="line">    res[<span class="number">3</span>] = y2(original) - y2(limited)</span><br><span class="line">    <span class="keyword">assert</span> (np.<span class="built_in">all</span>(np.array(res) &gt;= <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subwindow</span>(<span class="params">img, window, borderType=cv2.BORDER_CONSTANT</span>):</span></span><br><span class="line">    cutWindow = [x <span class="keyword">for</span> x <span class="keyword">in</span> window]</span><br><span class="line">    cutWindow = limit(cutWindow, [<span class="number">0</span>, <span class="number">0</span>, img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]])  <span class="comment"># modify cutWindow</span></span><br><span class="line">    <span class="keyword">assert</span> (cutWindow[<span class="number">2</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> cutWindow[<span class="number">3</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    border = getBorder(window, cutWindow)</span><br><span class="line">    res = img[cutWindow[<span class="number">1</span>]:cutWindow[<span class="number">1</span>] + cutWindow[<span class="number">3</span>], cutWindow[<span class="number">0</span>]:cutWindow[<span class="number">0</span>] + cutWindow[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (border != [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]):</span><br><span class="line">        res = cv2.copyMakeBorder(res, border[<span class="number">1</span>], border[<span class="number">3</span>], border[<span class="number">0</span>], border[<span class="number">2</span>], borderType)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># KCF tracker</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTracker</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hog=<span class="literal">False</span>, fixed_window=<span class="literal">True</span>, multiscale=<span class="literal">False</span></span>):</span></span><br><span class="line">        self._interp_factor = <span class="number">0.0075</span>  <span class="comment"># model updating rate</span></span><br><span class="line">        self._tmpl_sz = np.array([<span class="number">50</span>, <span class="number">50</span>])  <span class="comment"># the fixed model size</span></span><br><span class="line">        self._roi = [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]  <span class="comment"># cv::Rect2f, [left_up_x,left_up_y,width,height]</span></span><br><span class="line">        self._tmpl = <span class="literal">None</span>  <span class="comment"># our model</span></span><br><span class="line">        self.G = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># self._scale_pool = [1]</span></span><br><span class="line">        self._scale_pool = [<span class="number">0.985</span>, <span class="number">0.99</span>, <span class="number">0.995</span>, <span class="number">1.0</span>, <span class="number">1.005</span>, <span class="number">1.01</span>, <span class="number">1.015</span>]</span><br><span class="line"></span><br><span class="line">        self.padding = <span class="number">2.5</span>  <span class="comment"># extra area surrounding the target</span></span><br><span class="line">        self.output_sigma_factor = <span class="number">0.125</span>  <span class="comment"># bandwidth of gaussian target</span></span><br><span class="line">        self.lambdar = <span class="number">0.0001</span>  <span class="comment"># regularization</span></span><br><span class="line"></span><br><span class="line">        self.ishog = <span class="literal">False</span></span><br><span class="line">        winSize = (<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">        blockSize = (<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        blockStride = (<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        cellSize = (<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">        nbins = <span class="number">32</span></span><br><span class="line">        self.hog = cv2.HOGDescriptor(winSize, blockSize, blockStride, cellSize, nbins)</span><br><span class="line"></span><br><span class="line">        self._cos_win = np.hamming(self._tmpl_sz[<span class="number">0</span>]).reshape(self._tmpl_sz[<span class="number">0</span>], <span class="number">1</span>) @ \</span><br><span class="line">                        np.hamming(self._tmpl_sz[<span class="number">0</span>]).reshape(<span class="number">1</span>, self._tmpl_sz[<span class="number">0</span>])</span><br><span class="line">        self._cos_win = self._cos_win[..., np.newaxis]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">linear_correlation</span>(<span class="params">self, x1, x2</span>):</span></span><br><span class="line">        res = x1 * x2.conjugate()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createGaussianPeak</span>(<span class="params">self, sizey, sizex</span>):</span></span><br><span class="line">        syh, sxh = sizey / <span class="number">2</span>, sizex / <span class="number">2</span></span><br><span class="line">        output_sigma = np.sqrt(sizex * sizey) / self.padding * self.output_sigma_factor</span><br><span class="line">        mult = -<span class="number">0.5</span> / (output_sigma * output_sigma)</span><br><span class="line">        y, x = np.ogrid[<span class="number">0</span>:sizey, <span class="number">0</span>:sizex]</span><br><span class="line">        y, x = (y - syh) ** <span class="number">2</span>, (x - sxh) ** <span class="number">2</span></span><br><span class="line">        gaussian_res = np.exp(mult * (y + x))</span><br><span class="line">        <span class="keyword">return</span> np.fft.fft2(gaussian_res)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subPixelPeak</span>(<span class="params">self, left, center, right</span>):</span></span><br><span class="line">        divisor = <span class="number">2</span> * center - right - left  <span class="comment"># float</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span> <span class="keyword">if</span> <span class="built_in">abs</span>(divisor) &lt; <span class="number">1e-3</span> <span class="keyword">else</span> <span class="number">0.5</span> * (right - left) / divisor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFeatures</span>(<span class="params">self, image, roi, needed_size</span>):</span></span><br><span class="line">        roi = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, roi))  <span class="comment"># ensure that everything is int</span></span><br><span class="line">        z = subwindow(image, roi, cv2.BORDER_REPLICATE)  <span class="comment"># sample a image patch</span></span><br><span class="line">        <span class="keyword">if</span> z.shape[<span class="number">1</span>] != needed_size[<span class="number">0</span>] <span class="keyword">or</span> z.shape[<span class="number">0</span>] != needed_size[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> self.ishog:</span><br><span class="line">                z = cv2.resize(z, <span class="built_in">tuple</span>(needed_size * <span class="number">4</span>))  <span class="comment"># resize to template size</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                z = cv2.resize(z, <span class="built_in">tuple</span>(needed_size)) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.ishog:</span><br><span class="line">            FeaturesMap = self.hog.compute(z).reshape(needed_size[<span class="number">0</span>], needed_size[<span class="number">1</span>], -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># if z.ndim == 3 and z.shape[2] == 3:</span></span><br><span class="line">            <span class="comment">#    FeaturesMap = cv2.cvtColor(z, cv2.COLOR_BGR2GRAY)</span></span><br><span class="line">            <span class="comment"># elif z.ndim == 2:</span></span><br><span class="line">            FeaturesMap = z  <span class="comment"># (size_patch[0],size_patch[1]) #np.int8 #0~255</span></span><br><span class="line">            FeaturesMap = FeaturesMap.astype(np.float32) / <span class="number">255.0</span> - <span class="number">0.5</span></span><br><span class="line">        FeaturesMap = FeaturesMap * self._cos_win</span><br><span class="line">        <span class="keyword">return</span> FeaturesMap</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">track</span>(<span class="params">self, search_region, img</span>):</span> </span><br><span class="line">        global_max = <span class="number">0</span></span><br><span class="line">        global_loc = []</span><br><span class="line">        ind_s = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> it_s <span class="keyword">in</span> self._scale_pool:</span><br><span class="line">            search_region_s = <span class="built_in">list</span>(search_region)</span><br><span class="line">            search_region_s[<span class="number">2</span>] = search_region[<span class="number">2</span>] * it_s</span><br><span class="line">            search_region_s[<span class="number">3</span>] = search_region[<span class="number">3</span>] * it_s</span><br><span class="line">            search_region_s = <span class="built_in">map</span>(<span class="built_in">float</span>, search_region_s)</span><br><span class="line">            s_patch = self.getFeatures(img, search_region_s, self._tmpl_sz)  <span class="comment"># sample the search patch</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># patch=self.getFeatures(img,search_region,self._tmpl_sz)</span></span><br><span class="line">            F_new = np.fft.fft2(s_patch, axes=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            res = F_new * self._tmpl</span><br><span class="line">            res = np.fft.ifft2(res, axes=(<span class="number">0</span>, <span class="number">1</span>)).real</span><br><span class="line">            res = np.<span class="built_in">sum</span>(res, axis=<span class="number">2</span>)</span><br><span class="line">            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> max_val &gt; global_max:</span><br><span class="line">                global_max = max_val</span><br><span class="line">                global_loc = max_loc</span><br><span class="line">                ind_s = it_s</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> global_loc[<span class="number">0</span>], global_loc[<span class="number">1</span>], ind_s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_model</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        F_new = np.fft.fft2(x, axes=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        new_tmp = self.linear_correlation(self.G, F_new) / (self.linear_correlation(F_new, F_new) + self.lambdar)</span><br><span class="line">        self._tmpl = (<span class="number">1</span> - self._interp_factor) * self._tmpl + self._interp_factor * new_tmp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">self, roi, image</span>):</span></span><br><span class="line">        self._roi = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, roi))</span><br><span class="line">        <span class="keyword">assert</span> (roi[<span class="number">2</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> roi[<span class="number">3</span>] &gt; <span class="number">0</span>)</span><br><span class="line">        self.G = self.createGaussianPeak(self._tmpl_sz[<span class="number">0</span>], self._tmpl_sz[<span class="number">1</span>])</span><br><span class="line">        self.G = self.G[..., np.newaxis]</span><br><span class="line"></span><br><span class="line">        cx = self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">        cy = self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">        search_rect = [cx - self._roi[<span class="number">2</span>], cy - self._roi[<span class="number">3</span>], self._roi[<span class="number">2</span>] * <span class="number">2</span>, self._roi[<span class="number">3</span>] * <span class="number">2</span>]</span><br><span class="line">        f = self.getFeatures(image, search_rect, self._tmpl_sz)</span><br><span class="line">        F = np.fft.fft2(f, axes=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        self._tmpl = self.linear_correlation(self.G, F) / (self.linear_correlation(F, F) + self.lambdar)</span><br><span class="line">        <span class="built_in">print</span>(self._tmpl.shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, image</span>):</span></span><br><span class="line">        <span class="comment"># some check boundary here</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] &lt;= <span class="number">0</span>):  self._roi[<span class="number">0</span>] = -self._roi[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] &lt;= <span class="number">0</span>):  self._roi[<span class="number">1</span>] = -self._roi[<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">0</span>] &gt;= image.shape[<span class="number">1</span>] - <span class="number">1</span>):  self._roi[<span class="number">0</span>] = image.shape[<span class="number">1</span>] - <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (self._roi[<span class="number">1</span>] &gt;= image.shape[<span class="number">0</span>] - <span class="number">1</span>):  self._roi[<span class="number">1</span>] = image.shape[<span class="number">0</span>] - <span class="number">2</span></span><br><span class="line">        <span class="comment"># center position of our target</span></span><br><span class="line">        cx = self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">        cy = self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">        <span class="comment"># we double the searching region compared to the selected region</span></span><br><span class="line">        search_rect = [cx - self._roi[<span class="number">2</span>], cy - self._roi[<span class="number">3</span>], self._roi[<span class="number">2</span>] * <span class="number">2</span>, self._roi[<span class="number">3</span>] * <span class="number">2</span>]</span><br><span class="line">        <span class="comment"># the delta in search region</span></span><br><span class="line">        loc_pos = self.track(search_rect, image)</span><br><span class="line">        <span class="built_in">print</span>(loc_pos)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># delta_x and delta_y we want to estimate</span></span><br><span class="line">        delta = (np.array(loc_pos[:<span class="number">2</span>]) - self._tmpl_sz / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># scale between the search_roi and our template</span></span><br><span class="line">        scale = loc_pos[<span class="number">2</span>] * np.array(search_rect[<span class="number">2</span>:]).astype(<span class="built_in">float</span>) / (np.array(self._tmpl_sz) * <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># back to the original size</span></span><br><span class="line">        delta = delta * scale</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add the delta to original position</span></span><br><span class="line">        self._roi[<span class="number">0</span>] = self._roi[<span class="number">0</span>] + delta[<span class="number">0</span>]</span><br><span class="line">        self._roi[<span class="number">1</span>] = self._roi[<span class="number">1</span>] + delta[<span class="number">1</span>]</span><br><span class="line">        self._roi[<span class="number">2</span>] = self._roi[<span class="number">2</span>] * loc_pos[<span class="number">2</span>]</span><br><span class="line">        self._roi[<span class="number">3</span>] = self._roi[<span class="number">3</span>] * loc_pos[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># some check boundary here</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">0</span>] &gt;= image.shape[<span class="number">1</span>] - <span class="number">1</span>:  self._roi[<span class="number">0</span>] = image.shape[<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">1</span>] &gt;= image.shape[<span class="number">0</span>] - <span class="number">1</span>:  self._roi[<span class="number">1</span>] = image.shape[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] &lt;= <span class="number">0</span>:  self._roi[<span class="number">0</span>] = -self._roi[<span class="number">2</span>] + <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] &lt;= <span class="number">0</span>:  self._roi[<span class="number">1</span>] = -self._roi[<span class="number">3</span>] + <span class="number">2</span></span><br><span class="line">        <span class="keyword">assert</span> (self._roi[<span class="number">2</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> self._roi[<span class="number">3</span>] &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        cx = cy = self._roi[<span class="number">0</span>] + self._roi[<span class="number">2</span>] / <span class="number">2.</span></span><br><span class="line">        cy = self._roi[<span class="number">1</span>] + self._roi[<span class="number">3</span>] / <span class="number">2.</span></span><br><span class="line">        search_rect = [cx - self._roi[<span class="number">2</span>], cy - self._roi[<span class="number">3</span>], self._roi[<span class="number">2</span>] * <span class="number">2</span>, self._roi[<span class="number">3</span>] * <span class="number">2</span>]</span><br><span class="line">        <span class="comment"># update the template</span></span><br><span class="line">        x = self.getFeatures(image, self._roi, self._tmpl_sz)  <span class="comment"># new observation</span></span><br><span class="line">        self.update_model(x)</span><br><span class="line">        <span class="keyword">return</span> self._roi</span><br></pre></td></tr></table></figure><h4 id="四、测试结果"><a href="#四、测试结果" class="headerlink" title="四、测试结果"></a>四、测试结果</h4><p><div class="bilibili">    <iframe src="//player.bilibili.com/player.html?bvid=BV1wf4y1Y7xk&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div></p><h4 id="五、结果分析"><a href="#五、结果分析" class="headerlink" title="五、结果分析"></a><strong>五、结果分析</strong></h4><p>对于运动速度较慢的物体追踪效果好，速度越快效果越差，遇到遮挡物会受到影响。</p><h4 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a><strong>六、参考资料</strong></h4><ul><li>MOSSE：<a href="https://www.cs.colostate.edu/~draper/papers/bolme_cvpr10.pdf">https://www.cs.colostate.edu/~draper/papers/bolme_cvpr10.pdf</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Correlation-Filter-based-tracker（相关滤波器）&quot;&gt;&lt;a href=&quot;#Correlation-Filter-based-tracker（相关滤波器）&quot; class=&quot;headerlink&quot; title=&quot;Correlation Fi</summary>
      
    
    
    
    <category term="Tracker" scheme="http://10185102110.github.io/categories/Tracker/"/>
    
    
    <category term="Tracker" scheme="http://10185102110.github.io/tags/Tracker/"/>
    
  </entry>
  
  <entry>
    <title>JDBC数据库操作</title>
    <link href="http://10185102110.github.io/2021/05/11/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    <id>http://10185102110.github.io/2021/05/11/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/</id>
    <published>2021-05-11T10:16:36.000Z</published>
    <updated>2021-05-12T07:25:17.141Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDBC连接数据库-Mysql"><a href="#JDBC连接数据库-Mysql" class="headerlink" title="JDBC连接数据库(Mysql)"></a>JDBC连接数据库(Mysql)</h4><ol><li><p>下载JDBC驱动包：mysql-connector-java-8.0.16.jar</p></li><li><p>右键java项目——&gt;Build Path——&gt;Add External Archives——&gt;选择1中文件</p></li><li>打开项目中的module-info.java文件，在括号中添加requires java.sql;</li></ol><p><img src="1.png" alt=""></p><ol><li>测试代码</li></ol><ul><li>select</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">             <span class="comment">//MySQL8.0以上版本 com.mysql.jdbc.Driver 更换为 com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;加载数据库驱动时抛出异常！&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/bank?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">             <span class="comment">//serverTimezone=UTC用来解决数据库和系统时区差异引起的问题</span></span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;select * from officer&quot;</span>;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String f,l;</span><br><span class="line">    <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">    id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    f = rs.getString(<span class="number">3</span>);</span><br><span class="line">    l = rs.getString(<span class="number">4</span>);</span><br><span class="line">    System.out.println(id+<span class="string">&quot; &quot;</span>+l+f);</span><br><span class="line">    &#125;</span><br><span class="line">    rs.close();</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>insert</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;加载数据库驱动时抛出异常！&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/bank?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">    String sql = <span class="string">&quot;insert into customer(CUST_ID,ADDRESS,CITY,CUST_TYPE_CD,PROVICIAL_REGION,POSTAL_CODE)values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">    PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line">    pstmt.setString(<span class="number">1</span>, <span class="string">&quot;14&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">2</span>, <span class="string">&quot;浙江省杭州市滨江区网商路599号网易大厦&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">3</span>, <span class="string">&quot;杭州市&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">4</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">5</span>, <span class="string">&quot;浙江省&quot;</span>);</span><br><span class="line">    pstmt.setString(<span class="number">6</span>, <span class="string">&quot;310052&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> temp = pstmt.executeUpdate();</span><br><span class="line">    <span class="keyword">if</span>(temp!=<span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录添加成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录添加失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pstmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>update</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">my</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;加载数据库驱动时抛出异常！&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    String url = <span class="string">&quot;jdbc:mysql://localhost:3306/bank?serverTimezone=UTC&amp;characterEncoding=utf-8&quot;</span>;</span><br><span class="line">    String user = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    String sql = <span class="string">&quot;update customer set CUST_TYPE_CD=&#x27;B&#x27; where ADDRESS=&#x27;上海市南京西路11号1021室&#x27;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = stmt.executeUpdate(sql);</span><br><span class="line">    <span class="keyword">if</span>(temp!=<span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录修改成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;记录修改失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JDBC连接数据库(Mysql)</summary>
    
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Mysql无密码登录与修改密码</title>
    <link href="http://10185102110.github.io/2021/05/11/Mysql%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <id>http://10185102110.github.io/2021/05/11/Mysql%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E4%B8%8E%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</id>
    <published>2021-05-11T10:16:36.000Z</published>
    <updated>2021-05-12T07:23:21.296Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mysql无密码登录与修改密码"><a href="#Mysql无密码登录与修改密码" class="headerlink" title="Mysql无密码登录与修改密码"></a>Mysql无密码登录与修改密码</h4><ol><li>打开cmd，cd到mysql安装目录的bin文件夹</li><li>运行 net stop mysql</li><li>运行 mysqld —console —skip-grant-tables —shared-memory</li><li>此时该窗口如图，重新打开一个新的cmd窗口</li></ol><p><img src="2.png" alt=""></p><ol><li>运行 mysql</li><li>运行 use mysql</li><li>运行 flush privileges;</li><li>运行 ALTER user ‘root’@’localhost’ IDENTIFIED BY ‘123456’;</li><li>运行 flush privileges;</li><li>运行 exit</li><li>运行 net start mysql</li><li>重新登录，mysql -u root -p</li></ol><p><img src="1.png" alt=""></p>]]></content>
    
    
    <summary type="html">Mysql无密码登录与修改密码</summary>
    
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://10185102110.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="http://10185102110.github.io/2021/05/07/hexo/"/>
    <id>http://10185102110.github.io/2021/05/07/hexo/</id>
    <published>2021-05-07T15:33:36.000Z</published>
    <updated>2021-07-12T09:52:26.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo基础操作"><a href="#Hexo基础操作" class="headerlink" title="Hexo基础操作"></a>Hexo基础操作</h2><h3 id="一、hexo命令行"><a href="#一、hexo命令行" class="headerlink" title="一、hexo命令行"></a>一、hexo命令行</h3><ol><li><h5 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h5></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章名 <span class="comment">#新建文章</span></span><br><span class="line">hexo g <span class="comment"># 生成页面</span></span><br><span class="line">hexo s <span class="comment"># 本地预览</span></span><br><span class="line">hexo d <span class="comment"># 上传页面</span></span><br><span class="line">hexo g -d <span class="comment">#一步完成</span></span><br></pre></td></tr></table></figure><ol><li><h5 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h5></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清除缓存</span></span><br><span class="line">手动删除文件</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h3 id="二、文章内容"><a href="#二、文章内容" class="headerlink" title="二、文章内容"></a>二、文章内容</h3><ol><li><h5 id="阅读全文"><a href="#阅读全文" class="headerlink" title="阅读全文"></a>阅读全文</h5></li></ol><p>在想要隐藏的位置加入代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><ol><li><h5 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h5></li></ol><ul><li><p><code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p></li><li><p>打开/node_modules/hexo-asset-image/index.js，将内容更换为下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line"><span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line"><span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">   !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">  <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">srcArray.shift();</span><br><span class="line">  src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">  <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>打开_config.yml文件，修改下述内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>将图片放到生成的同名文件夹中，引用时 </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](img.png)</span><br></pre></td></tr></table></figure></li></ul><ol><li><h5 id="插入B站视频"><a href="#插入B站视频" class="headerlink" title="插入B站视频"></a>插入B站视频</h5></li></ol><ul><li><p>在\themes\Butterfly\source\css 创建文件 bilibili.css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*哔哩哔哩视频适配*/</span></span><br><span class="line"><span class="selector-class">.bilibili</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;              <span class="comment">/*高度设置这里无效，设置为0，用padding撑开div*/</span></span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">75%</span>;    <span class="comment">/*68%到80%都可以*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bilibili</span> <span class="selector-tag">iframe</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主题配置文件中搜索 inject，在 head 下添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/bilibili.css&quot;&gt;</span>  </span><br></pre></td></tr></table></figure></li><li><p>在文章中添加代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?bvid=番号(例如BV1wf4y1Y7xk)<span class="symbol">&amp;amp;</span>page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><h5 id="按钮：点击显示文本"><a href="#按钮：点击显示文本" class="headerlink" title="按钮：点击显示文本"></a>按钮：点击显示文本</h5></li></ol><ul><li><p>行内</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br><span class="line"><span class="section">#例如</span></span><br><span class="line">哪个英文字母最酷？ &#123;% hideInline 因为西装酷(C装酷),查看答案,#FF7242,#fff %&#125;</span><br><span class="line">门里站着一個人? &#123;% hideInline 闪 %&#125;</span><br></pre></td></tr></table></figure><p>content: 文本内容</p><p>display: 按钮显示的文字(可选)</p><p>bg: 按钮背景颜色(可选)</p><p>color: 按钮文字颜色(可选)</p></li></ul><ol><li><h5 id="开启-mathjax-数学公式渲染"><a href="#开启-mathjax-数学公式渲染" class="headerlink" title="开启 mathjax 数学公式渲染"></a>开启 mathjax 数学公式渲染</h5></li></ol><ul><li><p>卸载 hexo默认引擎 marked，安装 kramed</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></li><li><p>更改 /node_modules/hexo-renderer-kramed/lib/renderer.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Fit kramed&#x27;s rule: $$ + \1 + $$</span></span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/`\$(.*?)\$`/g</span>, <span class="string">&#x27;$$$$$1$$$$&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"><span class="comment">// Change inline math rule</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatText</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>卸载 hexo-math，安装 hexo-renderer-mathjax</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure></li><li><p>更改默认转移规则，/node_modules/kramed/lib/rules/nline.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换11行</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()# +\-.!_&gt;])/</span>,</span><br><span class="line"><span class="comment">//替换20行</span></span><br><span class="line">em: <span class="regexp">/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure></li><li><p>开启 mathjax，修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">perpage:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>修改 /node_modules/hexo-renderer-mathjax/mathjax.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 更新cdn</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在文章中使用 mathjax，声明 mathjax: true</p></li></ul><h3 id="三、主题配置"><a href="#三、主题配置" class="headerlink" title="三、主题配置"></a>三、主题配置</h3><ol><li><h5 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h5></li></ol><ul><li><p>安装插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>hexo配置文件添加代码</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><h5 id="添加友链"><a href="#添加友链" class="headerlink" title="添加友链"></a>添加友链</h5></li></ol><ul><li><p>在 /source/_data/link.yml 中添加代码，格式如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">class:</span></span><br><span class="line">  <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="attr">1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">姓名</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">链接</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">图片</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">签名</span></span><br><span class="line">    <span class="attr">2:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">姓名</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">链接</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">图片</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">签名</span></span><br></pre></td></tr></table></figure></li></ul><ol><li><h5 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h5></li></ol><ul><li><p>内容见 /source/_data/butterfly.yml</p></li><li><p>打字特效见主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment">#  open shake (抖动特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br><span class="line"> <span class="comment"># 如果有英文逗号&#x27; , &#x27;,使用转义字元 &amp;#44;</span></span><br><span class="line"> <span class="comment"># 如果有英文双引号&#x27; &quot; &#x27;,使用转义字元 &amp;quot;</span></span><br><span class="line"> <span class="comment"># 开头不允許转义字元，如需要，請把整个句子用双引号包住</span></span><br><span class="line"> <span class="comment"># 如果关闭打字效果，subtitle只会显示sub的第一行文字</span></span><br></pre></td></tr></table></figure></li><li><p>字体大小颜色</p><p>见 \themes\butterfly\source\css\_layout\head.styl</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#site-subtitle</span></span><br><span class="line">    <span class="attribute">color</span>: var(--white)   #此处修改为白色</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.05em</span>     #字体大小</span><br><span class="line"></span><br><span class="line">    +minWidth768()</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">1.40em</span>   #字体大小</span><br></pre></td></tr></table></figure></li></ul><ol><li><h5 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h5></li></ol><ul><li>主页的顶部图可以在 Butterfly.yml 设置 index_img</li><li>归档页的顶部图可以在 Butterfly.yml 设置 archive_img</li><li>其他标签页的顶部图可以在 md 页面设置 front-matter 中的 top_img</li></ul><ol><li><h5 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h5></li></ol><ul><li><p>picture.md 中添加代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">#例如</span><br><span class="line">&#123;% galleryGroup &#x27;Genshin Impact&#x27; &#x27;关于&#x27; &#x27;https://imgtu.com/album/rbLk9&#x27; https://imgtu.com/i/gw6a6A %&#125;</span><br></pre></td></tr></table></figure><p>name：相册名字<br>description：相册描述<br>link：相册地址<br>img-url：相册封面</p></li></ul><ol><li><h5 id="页面加载动画"><a href="#页面加载动画" class="headerlink" title="页面加载动画"></a>页面加载动画</h5></li></ol><ul><li><p>主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载动画 Loading Animation</span></span><br><span class="line"><span class="attr">preloader:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Typora符号"><a href="#Typora符号" class="headerlink" title="Typora符号"></a>Typora符号</h1><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p><p><img src="4.png" alt="4"></p>]]></content>
    
    
    <summary type="html">Hexo基础操作</summary>
    
    
    
    <category term="Hexo" scheme="http://10185102110.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://10185102110.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
