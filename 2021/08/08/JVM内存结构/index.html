<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JVM内存结构 | 浮生孰来</title><meta name="keywords" content="Java"><meta name="author" content="Ave Bai"><meta name="copyright" content="Ave Bai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM内存结构1. 运行时数据区Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存结构，主要就是分析 JVM 运行时数据存储区域。 JVM 的运行时数据区主要包括：堆、栈、方法区、程序计数器等。 而 JVM 的优化问题主要在线程共享的数据区中：堆、方法区。  1.1 程序计数器程序计数器（Program Counter Register）是">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM内存结构">
<meta property="og:url" content="http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="浮生孰来">
<meta property="og:description" content="JVM内存结构1. 运行时数据区Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存结构，主要就是分析 JVM 运行时数据存储区域。 JVM 的运行时数据区主要包括：堆、栈、方法区、程序计数器等。 而 JVM 的优化问题主要在线程共享的数据区中：堆、方法区。  1.1 程序计数器程序计数器（Program Counter Register）是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://10185102110.github.io/img/5.jpg">
<meta property="article:published_time" content="2021-08-08T08:56:22.000Z">
<meta property="article:modified_time" content="2021-08-08T09:58:40.200Z">
<meta property="article:author" content="Ave Bai">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://10185102110.github.io/img/5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu_site_verification"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?211d055ab9f6b88805047adca6ce783d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM内存结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-08 17:58:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/bilibili.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="浮生孰来" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浮生孰来</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM内存结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-08T08:56:22.000Z" title="发表于 2021-08-08 16:56:22">2021-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-08T09:58:40.200Z" title="更新于 2021-08-08 17:58:40">2021-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM内存结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><h2 id="1-运行时数据区"><a href="#1-运行时数据区" class="headerlink" title="1. 运行时数据区"></a>1. 运行时数据区</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。分析 JVM 内存结构，主要就是分析 JVM 运行时数据存储区域。</p>
<p>JVM 的运行时数据区主要包括：<strong>堆、栈、方法区、程序计数器</strong>等。</p>
<p>而 JVM 的优化问题主要在<strong>线程共享的数据区</strong>中：<strong>堆、方法区</strong>。</p>
<p><img src="D:\blog\source\_posts\JVM内存结构\2019040912492050.png" alt="2019040912492050"></p>
<h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，<strong>一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行</strong>。</p>
<p>为了确保线程切换后（<strong>上下文切换</strong>）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。也就是说程序计数器是<strong>线程私有的内存</strong>。</p>
<p>如果线程执行 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，计数器值为 Undefined。</p>
<p>程序计数器<strong>不会发生内存溢出</strong>（OutOfMemoryError 即 OOM）问题。</p>
<h3 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h3><p>JVM 中的栈包括 <strong>Java 虚拟机栈</strong> 和 <strong>本地方法栈</strong>，两者的区别就是，Java 虚拟机栈为 JVM 执行 Java 方法服务，本地方法栈则为 JVM 使用到的 Native 方法服务。Java 虚拟机栈，以下简称栈。</p>
<blockquote>
<p>Native 方法是什么？</p>
</blockquote>
<p>JDK 中有很多方法是使用 <strong>Native</strong> 修饰的。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）。Native 方法可以理解为是与操作系统直接交互的。比如通知垃圾收集器进行垃圾回收的代码 System.gc()，就是使用 native 修饰的。</p>
<blockquote>
<p>栈是什么？​</p>
</blockquote>
<p>定义：限定仅在表头进行插入和删除操作的线性表。即压栈（入栈）和弹栈（出栈）都是对栈顶元素进行操作的。所以栈是后进先出的。</p>
<p>栈是<strong>线程私有的</strong>，他的生命周期与线程相同。每个线程都会分配一个栈的空间，即每个线程拥有独立的栈空间。</p>
<blockquote>
<p>栈中存储的是什么？</p>
</blockquote>
<p><strong>栈帧</strong>是栈的元素。每个方法在执行时都会创建一个栈帧。栈帧中存储了<strong>局部变量表、操作数栈、动态连接和方法出口</strong>等信息。每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。</p>
<p><img src="D:\blog\source\_posts\JVM内存结构\20190409182042686.png" alt="20190409182042686"></p>
<h4 id="1-2-1-局部变量表"><a href="#1-2-1-局部变量表" class="headerlink" title="1.2.1 局部变量表"></a>1.2.1 局部变量表</h4><p>局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（String、数组、对象等），但是<strong>不存储对象的内容</strong>。局部变量表所需的内存空间<strong>在编译期间完成分配</strong>，在方法运行期间不会改变局部变量表的大小。</p>
<p>局部变量的容量以<strong>变量槽（Slot）</strong>为最小单位，每个变量槽最大存储32位的数据类型。对于 $64$ 位的数据类型（long、double），JVM 会为其分配两个连续的变量槽来存储。</p>
<p>JVM 通过索引定位的方式使用局部变量表，索引的范围从 $0$ 开始至局部变量表中最大的容量槽数量。普通方法与 static 方法在第 $0$ 个槽位的存储有所不同，非 static 方法的第 $0$ 个槽位存储方法所属对象实例的引用。</p>
<blockquote>
<p>Slot 复用？</p>
</blockquote>
<p>为了尽可能的节省栈帧空间，局部变量表中的 <strong>Slot 是可以复用</strong>的。方法中定义的局部变量，其作用域不一定会覆盖整个方法。当方法运行时，如果已经超出了某个变量的作用域，即变量失效了，那这个变量对应的 Slot 就可以交给其他变量使用，也就是所谓的 Slot 复用。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">66</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">55</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当虚拟机运行 test 方法，就会创建一个栈帧，并压入到当前线程的栈中。当运行到 <code>int a = 66</code> 时，在当前栈帧的局部变量中创建一个 Slot 存储变量 a，当运行到 <code>int b = 55</code> 时，此时已经超出变量 a 的作用域（变量 a 的作用域在{}所包含的代码块中），此时 a 就失效了，变量 a 占用的 Slot 可以交给 b 来使用，这就是 Slot 复用。</p>
<p>Slot 复用虽然节省了栈帧空间，但是会直接影响到系统的垃圾收集行为。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上段代码很简单，先向内存中填充了 64M 的数据，然后通知虚拟机进行垃圾回收。为了更清晰的查看垃圾回收的过程，在虚拟机的运行参数中加上 <code>-verbose:gc</code>，这个参数的作用就是打印 GC 信息。</p>
<p><img src="D:\blog\source\_posts\JVM内存结构\afas.png" alt="afas"></p>
<p>打印的GC信息如下：</p>
<p><img src="D:\blog\source\_posts\JVM内存结构\reh.png" alt="reh"></p>
<p>箭头前后的数据分别表示垃圾收集 GC 前后所有存活对象使用的内存容量，说明有70M-68M=2M 的对象容量被回收，而虚拟机没有回收这 64M 内存。为什么没有被回收？当执行 System.gc() 方法时，变量 placeholder 还在作用域范围之内，虚拟机是不会回收的，它还是“有效”的。</p>
<p>对上面的代码稍作修改，使其作用域“失效”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是虚拟机还是没有回收 placeholder 变量占用的 64M 内存，再对代码稍作修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 System.gc() 方法之前，加入 <code>int a = 0</code>，再执行方法，查看垃圾回收情况。</p>
<p><img src="D:\blog\source\_posts\JVM内存结构\qfgh.png" alt="qfgh"></p>
<p>发现 placeholder 变量占用的 64M 内存空间被回收了。</p>
<p>第一次修改中，限定了 placeholder 的作用域，但之后并没有任何对局部变量表的读写操作，placeholder 变量在局部变量表中占用的 Slot 没有被其它变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。所以 placeholder 变量没有被回收。</p>
<p>第二次修改后，运行到 int a = 0 时，已经超过了 placeholder 变量的作用域，此时 placeholder 在局部变量表中占用的 Slot 可以交给其他变量使用。而变量a正好复用了 placeholder 占用的 Slot，至此局部变量表中的 Slot 已经没有 placeholder 的引用了，虚拟机就回收了 placeholder 占用的 64M 内存空间。</p>
<h4 id="1-2-2-操作数栈"><a href="#1-2-2-操作数栈" class="headerlink" title="1.2.2 操作数栈"></a>1.2.2 操作数栈</h4><p>操作数栈的<strong>元素可以是任意的Java数据类型</strong>。方法刚开始执行时，操作数栈是空的，在方法执行过程中，通过字节码指令对操作数栈进行压栈和出栈的操作。</p>
<p>通常进行<strong>算数运算</strong>的时候是通过操作数栈来进行的，又或者是在调用其他方法的时候通过操作数栈进行<strong>参数传递</strong>。操作数栈可以理解为栈帧中用于计算的临时数据存储区。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStack</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        add(<span class="number">100</span>, <span class="number">98</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add 方法刚开始执行时，操作数栈是空的。首先把局部变量 $0$ 压栈，即 $100$ 入操作数栈。然后执行把局部变量 $1$ 压栈，即 $98$ 入操作数栈。接着执行弹出两个变量（$100$ 和 $98$ 出操作数栈），对 $100$ 和 $98$ 进行求和，然后将结果 $198$ 压栈。然后弹出结果（出栈）。<br>局部变量表和操作数栈的变化情况如下图：</p>
<p><img src="D:\blog\source\_posts\JVM内存结构\20190409205401344.jpg" alt="20190409205401344"></p>
<blockquote>
<p>栈中可能出现哪些异常？</p>
</blockquote>
<ul>
<li>StackOverflowError：如果采用固定大小的 Java 虚拟机栈，线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，则抛出栈溢出错误。</li>
<li>OutOfMemoryError：如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，则抛出内存不足。</li>
</ul>
<blockquote>
<p>如何设置栈参数？</p>
</blockquote>
<p>使用参数 <strong>-Xss</strong> 设置线程的最大栈空间。由于栈是<strong>线程私有</strong>的，线程数越多，占用栈空间越大。</p>
<p>栈的大小直接决定函数调用的最大可达深度，这也是慎用递归调用的原因。递归调用时，每次调用方法都会创建栈帧并压栈。当调用一定次数之后，所需栈的大小已经超过了虚拟机运行配置的最大栈参数，就会抛出 StackOverflowError 异常。</p>
<h3 id="1-3-Java堆"><a href="#1-3-Java堆" class="headerlink" title="1.3 Java堆"></a>1.3 Java堆</h3><p>堆是Java虚拟机所管理的内存中最大的一块存储区域。堆内存被所有<strong>线程共享</strong>。主要存放使用 <strong>new</strong> 关键字创建的对象。所有<strong>对象实例以及数组</strong>都要在堆上分配。垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间。</p>
<p>Java 堆分为<strong>年轻代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation）；年轻代又分为伊甸园（Eden）和幸存区（Survivor区）；幸存区又分为 From Survivor 空间和 To Survivor 空间。</p>
<p>老年代存储<strong>长期存活的对象和大对象</strong>。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发 <strong>Full GC</strong>。</p>
<p><strong>Full GC </strong>是清理整个堆空间，包括年轻代和老年代。如果Full GC之后，堆中仍然无法存储对象，就会抛出<strong>OutOfMemoryError </strong>异常。</p>
<p>Java 堆设置常用参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>堆内存初始大小</td>
</tr>
<tr>
<td>-Xmx（MaxHeapSize）</td>
<td>堆内存最大允许大小，一般不要大于物理内存的80%</td>
</tr>
<tr>
<td>-XX:NewSize（-Xns）</td>
<td>年轻代内存初始大小</td>
</tr>
<tr>
<td>-XX:MaxNewSize（-Xmn）</td>
<td>年轻代内存最大允许大小，也可以缩写</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>新生代和老年代的比值，值为4 表示新生代:老年代=1:4</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>年轻代中Eden区与Survivor区的容量比例值，默认为8</td>
</tr>
<tr>
<td>XX:+HeapDumpOnOutOfMemoryError</td>
<td>内存溢出时，导出堆信息到文件</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=7</td>
<td>表示如果在幸存区移动多少次没有被垃圾回收，进入老年代</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-4-方法区"><a href="#1-4-方法区" class="headerlink" title="1.4 方法区"></a>1.4 方法区</h3><p>方法区同 Java 堆一样是被所有<strong>线程共享</strong>的区间，用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。关闭 JVM 会释放方法区的内存。</p>
<p>JDK1.8 使用元空间 <strong>MetaSpace</strong> 替代方法区，元空间并不在 JVM 中，而是使用本地内存。元空间两个参数：</p>
<ul>
<li>MetaSpaceSize：初始化元空间大小，控制发生 GC 的阈值</li>
<li>MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存</li>
</ul>
<p>常量池是方法区的一部分，存储编译器生成的各种字面量和符号引用。</p>
<p>字面量就是Java中常量的意思，包括字符串，final修饰的常量和基本数据类型的值。</p>
<p>符号引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符。</p>
<blockquote>
<p>常量池有什么用 ？</p>
</blockquote>
<p>常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p>
<ul>
<li><strong>Integer 常量池</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestIntegerCache</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="number">66</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> integer(<span class="number">66</span>);</span><br><span class="line">        Integer i3 = <span class="number">66</span>;</span><br><span class="line">        Integer i4 = <span class="number">66</span>;</span><br><span class="line">        Integer i5 = <span class="number">150</span>;</span><br><span class="line">        Integer i6 = <span class="number">150</span>;</span><br><span class="line">        System.out.println(i1 == i2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(i3 == i4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(i5 == i6);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i1 和 i2 使用 new 关键字，每 new 一次都会在堆上创建一个对象，所以 <code>i1 == i2</code> 为 false。</p>
<p><code>Integer i3 = 66</code> 实际上有一步<strong>装箱</strong>的操作，即将 int 型的 66 装箱成 Integer，通过 Integer 的 valueOf 方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Integer 的 valueOf 方法判断变量是否在 <strong>IntegerCache</strong> 的最小值（$-128$）和最大值（$127$）之间，如果在，则返回常量池中的内容，否则 new 一个 Integer 对象。而 IntegerCache 是 Integer的静态内部类，作用就是将 $[-128,127]$ 之间的数”缓存”在 IntegerCache 类的 cache 数组中(这个 Integer 数组包含 $-128$ 到 $127$ 之间的所有值)，valueOf 方法就是调用常量池的 cache 数组，将 i3、i4 变量的引用指向常量池中，没有真正的创建对象。</p>
<p>而 <code>i5 == i6</code> 为 false，就是因为 $150$ 不在 Integer 常量池的最大最小值之间 $[-128,127]$，从而 new 了一个对象。</p>
<p>IntegerCache 源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;<span class="comment">//最小值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;<span class="comment">//最大值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];<span class="comment">//缓存数组</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">//私有化构造方法，不让别人创建它。单例模式的思想</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//类加载的时候，执行静态代码块。作用是将-128到127之间的数缓冲在cache[]数组中</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];<span class="comment">//初始化cache数组，根据最大最小值确定</span></span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)<span class="comment">//遍历将数据放入cache数组中</span></span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一段<strong>拆箱</strong>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Integer i1 = <span class="keyword">new</span> Integer(<span class="number">4</span>);</span><br><span class="line">       Integer i2 = <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br><span class="line">       Integer i3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line">       System.out.print(i3 == i1+i2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于 i1 和 i2 是 Integer 对象，是不能使用+运算符的。首先 i1 和 i2 进行自动拆箱操作，拆箱成int后再进行数值加法运算。i3 也是拆箱后再与之比较数值是否相等的。所以 <code>i3 == i1+i2</code> 其实是比较的 int 型数值是否相等，所以为 true。</p>
<ul>
<li>String 常量池</li>
</ul>
<p>String 是由 final 修饰的类，是不可以被继承的。通常有两种方式来创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则直接将 str 引用指向常量池中的“abcd”。</span></span><br><span class="line">String str = <span class="string">&quot;abcd&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>对于 String 类，equals 方法用于比较字符串内容是否相同；== 号用于比较内存地址是否相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       String str2 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在栈上存放变量引用 str1，然后通过符号引用去常量池中找是否有 abcd，没有，则将 abcd 存储在常量池中，然后将 str1 指向常量池的 abcd。创建 str2 对象时，在常量池中发现已经有 abcd 了，就将 str2 引用直接指向 abcd 。所以 <code>str1 == str2</code>，指向同一个内存地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">       System.out.print(str1 == str2);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str1 和 str2 使用 new 创建对象，两个引用指向堆中两个不同的对象，所以为 false。</p>
<blockquote>
<p>关于字符串 + 号连接问题</p>
</blockquote>
<p>对于字符串<strong>常量</strong>的 + 号连接，在程序编译期，JVM就会将其优化为 + 号连接后的值。所以在编译期其字符串常量的值就确定了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">&quot;a1&quot;</span>;   </span><br><span class="line">String b = <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;   </span><br><span class="line">System.out.println((a == b)); <span class="comment">//result = true</span></span><br></pre></td></tr></table></figure>
<p>对于字符串<strong>引用</strong>的 + 号连接问题，由于字符串引用在编译期是无法确定下来的，在程序的运行期动态分配并创建新的地址存储对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">	   String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">	   String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">	   System.out.print(str2 == str3);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过 jad 反编译工具反编译代码后，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s2 = (<span class="keyword">new</span> StringBuilder()).append(s).append(<span class="string">&quot;b&quot;</span>).toString();</span><br><span class="line">        System.out.print(s1 = s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现 new 了一个 StringBuilder 对象，然后使用 append 方法优化了 + 操作符。new 在堆上创建对象，而 <code>String s1=“ab”</code> 则是在常量池中创建对象，两个应用所指向的内存地址是不同的，所以 <code>s1 == s2</code> 结果为 false。</p>
<p><strong>在 for 循环中操作字符串的优化</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用+号连接字符串，每循环一次，就会新建StringBuilder对象，append后就“抛弃”了它。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s = s + <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果在循环外创建StringBuilder对象，在循环中使用append方法追加字符串，可以节省 n-1 次创建和销毁对象的时间。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用 final 修饰的字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String str3 = str1 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        System.out.print(str2 == str3);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>final 修饰的变量是一个常量，编译期就能确定其值，所以 <code>str1 + &quot;b&quot;</code> 就等同于 “a” + “b”，结果是 true。</p>
<p><strong>String 对象的 intern 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String s3 = s1 + s2;</span><br><span class="line">        System.out.println(s3 == s);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3.intern() == s);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s3 调用 intern 方法，返回的是s3的内容 “ab” 在常量池中的地址值。所以 <code>s3.intern() == s</code> 结果为 true。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ave Bai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">http://10185102110.github.io/2021/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://10185102110.github.io" target="_blank">浮生孰来</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/08/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"><img class="prev-cover" src="/img/1.jpg" onerror="onerror=null;src='/img/12.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM垃圾回收机制</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/08/JMM-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"><img class="next-cover" src="/img/1.jpg" onerror="onerror=null;src='/img/12.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JMM&amp;volatile关键字</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/08/JMM-volatile关键字/" title="JMM&volatile关键字"><img class="cover" src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-08</div><div class="title">JMM&volatile关键字</div></div></a></div><div><a href="/2021/08/08/JVM垃圾回收机制/" title="JVM垃圾回收机制"><img class="cover" src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-08</div><div class="title">JVM垃圾回收机制</div></div></a></div><div><a href="/2021/08/08/Java线程安全/" title="Java线程安全"><img class="cover" src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-08</div><div class="title">Java线程安全</div></div></a></div><div><a href="/2021/08/08/Java多线程基础/" title="Java多线程基础"><img class="cover" src="/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-08</div><div class="title">Java多线程基础</div></div></a></div><div><a href="/2021/08/08/Java容器/" title="Java容器"><img class="cover" src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-08</div><div class="title">Java容器</div></div></a></div><div><a href="/2021/08/08/Java线程池-Executor框架/" title="Java线程池&Executor框架"><img class="cover" src="/img/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-08</div><div class="title">Java线程池&Executor框架</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">JVM内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.1.</span> <span class="toc-text">1. 运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%A0%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 局部变量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 操作数栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Java%E5%A0%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 Java堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 方法区</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/5.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Ave Bai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>