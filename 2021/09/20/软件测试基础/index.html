<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>软件测试基础 | 浮生孰来</title><meta name="keywords" content="软件测试"><meta name="author" content="Ave Bai"><meta name="copyright" content="Ave Bai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 概述什么是软件根据 IEEE 的定义，软件由计算机程序、规程、文档和运行所需的数据组成，这些要素构成了软件工程过程中的各种配置。 软件特征（1）软件是逻辑产品，不是物理产品，所以软件具有和硬件完全不同的特征。  软件是由开发产生，不是用传统方法制造的； 软件不会像硬件那样有磨损； 软件不能通过已有构件组装，只能自己定义。  （2）当前软件分为七大类：  系统软件 应用软件 Web 应用">
<meta property="og:type" content="article">
<meta property="og:title" content="软件测试基础">
<meta property="og:url" content="http://10185102110.github.io/2021/09/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="浮生孰来">
<meta property="og:description" content="[TOC] 概述什么是软件根据 IEEE 的定义，软件由计算机程序、规程、文档和运行所需的数据组成，这些要素构成了软件工程过程中的各种配置。 软件特征（1）软件是逻辑产品，不是物理产品，所以软件具有和硬件完全不同的特征。  软件是由开发产生，不是用传统方法制造的； 软件不会像硬件那样有磨损； 软件不能通过已有构件组装，只能自己定义。  （2）当前软件分为七大类：  系统软件 应用软件 Web 应用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://10185102110.github.io/img/default/0.jpg">
<meta property="article:published_time" content="2021-09-20T03:47:18.000Z">
<meta property="article:modified_time" content="2021-09-27T12:05:36.338Z">
<meta property="article:author" content="Ave Bai">
<meta property="article:tag" content="软件测试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://10185102110.github.io/img/default/0.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://10185102110.github.io/2021/09/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu_site_verification"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?211d055ab9f6b88805047adca6ce783d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件测试基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-27 20:05:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/bilibili.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="浮生孰来" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default/0.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">浮生孰来</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-camera"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件测试基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-20T03:47:18.000Z" title="发表于 2021-09-20 11:47:18">2021-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-27T12:05:36.338Z" title="更新于 2021-09-27 20:05:36">2021-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件测试基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h2><p>根据 IEEE 的定义，软件由计算机程序、规程、文档和运行所需的数据组成，这些要素构成了软件工程过程中的各种配置。</p>
<h2 id="软件特征"><a href="#软件特征" class="headerlink" title="软件特征"></a>软件特征</h2><p>（1）软件是逻辑产品，不是物理产品，所以软件具有和硬件完全不同的特征。</p>
<ul>
<li>软件是由开发产生，不是用传统方法制造的；</li>
<li>软件不会像硬件那样有磨损；</li>
<li>软件不能通过已有构件组装，只能自己定义。</li>
</ul>
<p>（2）当前软件分为七大类：</p>
<ol>
<li>系统软件</li>
<li>应用软件</li>
<li>Web 应用软件</li>
<li>工程和科学软件</li>
<li>嵌入式软件</li>
<li>产品线软件</li>
<li>人工智能软件</li>
</ol>
<p>（3）软件工程是一种层次化技术。</p>
<ol>
<li>软件工程的根基在于对质量的关注。</li>
<li>软件工程的过程层是基础。过程层定义了关键过程区域的框架，确立上下各区域的关系，并规定了采用的技术方法，产生的工程产品，建立里程碑，质量保证以及管理变化。</li>
<li>软件工程的方法层涵盖一系列任务，如需求分析、设计、编程、测试、维护。</li>
<li>软件工程的工具层对过程层和方法层提供自动、半自动的支持。</li>
</ol>
<p>（4）<strong>软件质量</strong></p>
<p>生产高质量的软件是我们的首要目标。</p>
<p>IEEE 关于软件质量的定义：</p>
<ul>
<li>系统、部件或者过程满足规定需求的程度。</li>
<li>系统、部件或者过程满足顾客或者用户需要或期望的程度。</li>
</ul>
<p>各类软件综合起来可以看到 $6$ 个主要特征：</p>
<ol>
<li>功能性：软件实现的功能达到要求的和隐含的用户需求以及设计规范的程度。</li>
<li>可靠性：软件在指定条件和特定时间段内维持性能的能力程度。</li>
<li>易使用性：用户使用该软件所付出的学习精力。</li>
<li>效率：在指定条件下软件功能与所占资源之间的比值。</li>
<li>可维护性：当发现错误、运行环境改变或客户需求改变时程序能修改的容易程度。</li>
<li>可移植性：将软件从一种环境移入另一种环境的容易程度。</li>
</ol>
<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>（1）软件测试是保证软件质量的关键步骤，是对软件规格说明、设计和编码的最后复审。</p>
<p>（2）软件测试工作可以这样概括：</p>
<ul>
<li>测试执行、模拟一个系统或者程序的操作；</li>
<li>测试在于带着发现问题和错误的意图来分析程序；</li>
<li>测试能够度量程序的功能和质量；</li>
<li>测试在于评价程序和项目工作产品的属性、能力，并且评估是否获得了期望。</li>
</ul>
<p>（3）<strong>软件测试的方法</strong></p>
<p>软件测试技术可以从不同角度加以分类。</p>
<p>从是否需要执行被测软件的角度分为静态测试和动态测试；</p>
<p>从是否针对系统的内部结构和具体实现算法的角度分为白盒测试和黑盒测试。</p>
<p>1.<strong>静态测试</strong></p>
<p>静态测试无需执行被测代码，而是借助专用的软件测试工具评审软件文档或程序，度量程序静态复杂度，通过分析或检查源程序的文法、结构、过程、接口等来检查程序的正确性，借以发现程序的不足之处来减少错误概率。</p>
<p>静态测试包含的内容如下：</p>
<ul>
<li>代码检查</li>
<li>静态结构分析：主要以图形的方式表现程序的内部结构，例如函数调用关系图、函数内部控制流图。</li>
<li>代码质量度量</li>
</ul>
<ol>
<li><strong>动态测试</strong></li>
</ol>
<p>动态测试通过人工或使用工具运行程序，使被测代码在相对真实的环境下运行，从多角度观察程序运行时能体现的功能、逻辑、行为、结构等行为，并通过检查、分析程序的执行状态、程序的外部表现来定位程序的错误。</p>
<p>动态测试由三部分组成：</p>
<ul>
<li>功能确认和接口测试</li>
<li>覆盖率分析</li>
<li>性能分析</li>
</ul>
<ol>
<li><strong>黑盒测试</strong></li>
</ol>
<p>也称为功能测试，是已知软件所需功能，通过测试来检测每个功能是否都能正常使用。</p>
<p>黑盒测试方法主要有等价类划分、边值分析、因果图、错误推测等。</p>
<p>该方法着眼于程序外部结构，不考虑内部逻辑结构，针对软件界面和软件功能进行测试。黑盒测试方法是穷举输入测试，只有把所有可能的输入都作为测试情况使用，才能查出程序中所有的错误。</p>
<ol>
<li><strong>白盒测试</strong></li>
</ol>
<p>也称结构测试或逻辑驱动测试，知道软件内部的工作过程，可通过测试来检测软件产品内部的动作是否按照规格说明书的规定正常进行，并且按照程序内部的结构测试程序来检验程序中的每条通路是否都能按照预定要求正确工作，而不考虑功能是否正确。</p>
<p>白盒测试方法主要有逻辑覆盖、域测试、路径测试、程序插桩、程序变异等。</p>
<ol>
<li><strong>灰盒测试</strong></li>
</ol>
<p>介于白盒与黑盒之间，关注输出对于输入的正确性，同时也关注内部表现。但这种关注不像白盒那样详细完整，只是通过一些表征性的现象、标志来判断内部的运行状态。</p>
<p>如果每次都通过白盒测试来操作，效率会很低，所以需要灰盒测试。</p>
<h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><ul>
<li>HLD（High level Document）：概要设计说明书。</li>
<li>LLD（Low level Document）：详细设计说明书。</li>
<li>SRS（Software Requirements Specification）：需求规格说明书。</li>
</ul>
<h1 id="软件测试-1"><a href="#软件测试-1" class="headerlink" title="软件测试"></a>软件测试</h1><p>软件测试的核心是测试数据生成。</p>
<p>软件测试的实质是根据软件开发各阶段的规格说明和程序的内部结构精心选取一批测试数据，形成测试用例，并用这些测试用例去驱动被测程序，验证所得结果与预期结果是否一致。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul>
<li>测试是程序的执行过程，目的在于发现错误；</li>
<li>一个好的测试用例在于能发现至今未发现的错误；</li>
<li>一个成功的测试用例是发现了至今未发现的错误的测试。</li>
</ul>
<p>测试一般不可能发现程序中的所有错误，测试只能证明程序中存在错误，但不能证明程序中不存在错误。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ul>
<li><p>在整个开发过程中要尽早地和不断地进行软件测试。</p>
<p>不应把软件测试仅仅看作是软件开发的一个独立阶段，而应当贯穿到软件开发的各个阶段中。</p>
</li>
<li><p>在开始测试时不应默认程序中不存在错误。</p>
</li>
<li><p>在设计测试用例时要给出测试的预期结果。</p>
<p>一个测试用例必须包括两部分：对程序输入数据的描述和由这些输入数据应产生的输出结果的精确描述。</p>
</li>
<li><p>测试工作应避免由开发人员来承担。</p>
<p>从心理学上讲，让一个人否定自己所做的工作是一件沮丧的事情。另外，如果程序中包含了由于程序员对程序功能的误解而产生的错误，当程序员测试自己的程序时，往往还会带着同样的误解而使错误难以发现。</p>
</li>
<li><p>对合理的和不合理的输入数据都要进行测试。</p>
<p>为了提高程序的可靠性。合理的输入数据可以验证程序的正确性，而不合理的输入数据是指异常的、临界的、可能引起问题异变的输入数据。事实上，用户往往会不遵循合理的输入要求而进行一些非法的输入，如果系统不能对此做出正确反应，系统将很容易产生故障，甚至造成系统瘫痪。</p>
</li>
<li><p>重点测试错误群集的程序区段。</p>
</li>
<li><p>除检查程序功能是否完备外还要检查程序功能是否有多余。</p>
</li>
<li><p>用穷举测试是不可能的。</p>
</li>
<li><p>长期完整地保留所有的测试用例和测试文件，直到该软件产品被废弃为止。</p>
<p>因为测试不是一次完成的，在测试出错误并修改后需要继续测试。另外，以后进行维护时也需要这些测试文件进行后续测试。测试文件包括测试数据集、预期的结果、程序执行的记录等。</p>
</li>
</ul>
<h2 id="软件测试的种类"><a href="#软件测试的种类" class="headerlink" title="软件测试的种类"></a>软件测试的种类</h2><p>在进行软件测试时需要以下 3 类信息：</p>
<ul>
<li>软件配置：指需求说明书、设计说明书和源程序等。</li>
<li>测试配置：指测试方案、测试用例和测试驱动程序等。</li>
<li>测试工具：指计算机辅助测试的有关工具。</li>
</ul>
<p>通常综合测试分为 4 个步骤：</p>
<ol>
<li>单元测试（Unit Testing）</li>
<li>集成测试（Integrated Testing）</li>
<li>系统测试（System Testing）</li>
<li>验收测试（Acceptance Testing）</li>
</ol>
<p>另外，在所有测试过程中始终贯穿着回归测试（Regression Testing）。</p>
<p><img src="1.png" alt=""></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>单元测试指对软件中的最小可测试单元或基本组成单元进行检查和验证。</p>
<p>单元测试中选取的单元应可以清晰地与其他单元区分开，在某种意义上，单元的概念已经扩展为组件(Component)。</p>
<p>一般遵循以下<strong>单元选取原则</strong>：</p>
<ul>
<li>对于 C 语言这类面向过程的开发语言来说，单元常指一个函数或子过程。在特殊情况下，如果几个函数具有强耦合性，导致函数关系非常密切，应将这几个函数共同作为一个单元来测试。</li>
<li>对于 C++、Java 语言或 C# 等面向对象的开发语言来说，单元一般指一个类。然而某些基础类可能非常庞大，涉及大量属性和方法，甚至需要几个开发人员来编码完成，此时的测试应上升到集成测试的层面。</li>
<li>在图形化软件中，单元常指一个窗体或一个菜单。</li>
</ul>
<p>总之，单元是人为规定的最小的被测功能模块。而单元测试则是一小段代码，用于检测被测代码的一个很小的、很明确的功能是否正确。</p>
<h3 id="测试内容"><a href="#测试内容" class="headerlink" title="测试内容"></a>测试内容</h3><ul>
<li><p>接口测试</p>
<p>接口测试指对通过被测模块的数据流进行测试检查数据能否正确地输入和输出，主要对模块接口的以下方面进行测试：</p>
<ul>
<li>输入的实参与形参在个数、属性、量纲和顺序上是否匹配；</li>
<li>被测模块调用其他模块时传递的实参与被调用模块的形参是否匹配；</li>
<li>调用标准函数时传递的实参在个数、属性、量纲和顺序上是否正确；</li>
<li>是否存在与当前入口点无关的参数引用；</li>
<li>是否修改了只做输入用的只读形参；</li>
<li>全局变量在每个模块中的定义是否一致；</li>
<li>是否将某些约束条件作为形参来传递。</li>
</ul>
</li>
<li><p>局部数据结构测试</p>
<p>局部数据结构是最常见的缺陷来源，检查局部数据结构可以保证临时存储在模块内的数据在代码执行过程中是正确的和完整的。应考虑以下方面：</p>
<ul>
<li>是否存在不正确、不一致的数据类型说明；</li>
<li>是否存在未初始化或未赋值的错误；</li>
<li>变量是否存在初始化或默认值错误；</li>
<li>是否存在变量名拼写或书写错误；</li>
<li>是否存在不一致的数据类型；</li>
<li>是否出现上溢、下溢或地址异常。</li>
</ul>
</li>
<li><p>重要执行路径测试</p>
<p>对重要执行路径和循环的测试是最常用、最有效的测试技术，以发现因错误的计算、错误的比较和不适当的控制流而导致的缺陷。</p>
<p>常见的错误计算如下：</p>
<ul>
<li>操作符优先次序是否被正确理解；</li>
<li>是否存在混合模式的计算；</li>
<li>是否存在被零除的风险；</li>
<li>运算精度不够；</li>
<li>变量的初值是否正确；</li>
<li>表达式的符号是否正确。</li>
</ul>
<p>常见的比较和控制错误如下：</p>
<ul>
<li>是否存在不同数据类型变量之间的比较；</li>
<li>是否存在错误的逻辑运算符或优先次序；</li>
<li>是否存在因计算机表示的局限性导致浮点运算精度不够，致使期望值与实际值不相等的两值比较；</li>
<li>在关系表达式中是否存在错误的变量和比较符；</li>
<li>是否存在不可能的循环终止条件导致死循环；</li>
<li>是否存在迭代发散导致不能退出；</li>
<li>是否错误地修改了循环变量，导致循环次数多一次或少一次。</li>
</ul>
</li>
<li><p>错误处理测试</p>
<p>完善的设计应能预见各种出错条件，并设置适当的出错处理，以提高系统的容错能力，保证逻辑的正确性。</p>
<p>应考虑以下方面：</p>
<ul>
<li>输出的出错信息是否难以理解；</li>
<li>出错描述提供的信息是否不足，导致无法对错误进行定位；</li>
<li>显示的错误是否与实际遇到的缺陷不符合；</li>
<li>对错误条件的处理是否正确；</li>
<li>在程序自定义的出错处理运行之前缺陷条件是否已经引起系统干预。</li>
</ul>
</li>
<li><p>边界条件测试</p>
<p>程序最容易在边界上出错，应注意以下方面：</p>
<ul>
<li>输入/输出数据的等价类边界；</li>
<li>选择条件和循环条件的边界；</li>
<li>复杂数据结构的边界。</li>
</ul>
</li>
</ul>
<h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>在对模块进行测试时，每个模块在整个软件系统中不是孤立的，不能独立运行，而需要由其他模块来调用和驱动，模块的执行还依赖被它调用的下级模块。因此，为了模拟模块与它周围模块的关系，需要设计辅助测试模块。</p>
<p>辅助测试模块分为以下两种：</p>
<ul>
<li><strong>驱动模块</strong>（Driver）：用来模拟被测模块的上级调用模块，功能比真正的上级模块简单得多，仅仅是接受测试数据，并向被测模块传送测试数据，启动被测模块，回收并输出测试结果。</li>
<li><strong>桩模块</strong>（Stub）：用来模拟被测模块在执行过程中所要调用的模块，接受被测模块输出的数据并完成它所指派的任务。</li>
</ul>
<p>图（a）表示被测软件的结构，图（b）表示用驱动模块和桩模块建立的测试模块 B 的环境。</p>
<p><img src="2.png" alt=""></p>
<p>驱动模块和桩模块的编写会给软件开发带来额外开销，而且不必和最终的软件一起提交，因此在保证测试质量的前提下尽量避免开发驱动模块和桩模块。当测试单元较简单时，可以直接与被测模块放在一起执行测试；当测试单元较复杂时，最好利用驱动模块或桩模块构建测试环境运行程序。</p>
<h3 id="测试技术"><a href="#测试技术" class="headerlink" title="测试技术"></a>测试技术</h3><p>用于单元测试的主要技术如下：</p>
<ul>
<li><p>静态测试</p>
<p>静态测试是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。静态测试的结果可用于进一步的查错，并未测试用例选取提供指导。</p>
</li>
<li><p>白盒测试</p>
<p>白盒测试也称结构测试或逻辑驱动测试，是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p>
<p>白盒测试的原则如下：</p>
<p>（1）每条语句至少执行一次；</p>
<p>（2）每个判定的每个分支至少执行一次；</p>
<p>（3）每个判定的每个条件应取到各种可能的值；</p>
<p>（4）每个判定中各条件的每一种组合至少出现一次；</p>
<p>（5）每一条可能的路径至少执行一次。</p>
</li>
<li><p>状态转换测试</p>
<p>被测单元可能具有多个不同的状态，在某些条件下状态会互相转换。状态转换测试就是要模拟使状态发生转换的各种用户操作场景，以及通过一些非正常技术手段来校验不允许发生的状态转换。</p>
</li>
<li><p>功能测试和非功能测试</p>
<p>功能测试就是对产品的各功能进行验证，根据产品特征、操作描述和用户方案测试一个产品的特性和可操作性行为，以确定它们满足设计需求。</p>
<p>非功能测试指在必要时对单元的性能（如系统响应时间、外部接口响应时间、CPU 的使用、内存使用的相容性）等方面进行测试。</p>
</li>
</ul>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>集成测试是在单元测试的基础上将所有已通过单元测试的模块按照概要设计的要求组装成子系统或系统。</p>
<p>进行集成测试的目的是确保各单元模块组合在一起能够按照既定意图协作运行，并确保增量的行为正确。不经过单元测试的模块不应该进行集成测试，否则将对集成测试的效果和效率带来巨大的影响。</p>
<h3 id="测试内容-1"><a href="#测试内容-1" class="headerlink" title="测试内容"></a>测试内容</h3><p>集成测试的内容包括模块之间的接口以及集成后的功能，使用黑盒测试方法测试集成的功能，并对以前的集成进行回归测试。具体来说，集成测试包括以下内容：</p>
<ul>
<li>将各模块连接起来时穿越模块接口的数据是否会丢失；</li>
<li>各子功能组合起来能否达到预期要求的父功能；</li>
<li>模块的功能是否会对其他模块的功能产生不利影响；</li>
<li>全局数据结构是否有问题，是否会被异常修改；</li>
<li>单个模块的误差积累起来是否会放大到不可接受的程度。</li>
</ul>
<h3 id="测试方法-1"><a href="#测试方法-1" class="headerlink" title="测试方法"></a>测试方法</h3><ul>
<li><p>非增量式集成测试方法</p>
<p>基本思路是首先将各模块独立地进行单元测试，然后把所有模块组装在一起进行测试，最终得到一个符合要求的软件系统。</p>
<p>这种方法容易出现混乱，因为测试时可能发现一大堆错误，为每个错误进行定位和纠正非常困难，并且改正一个错误同时又可能引入新的错误。</p>
</li>
<li><p><strong>增量式集成测试方法</strong></p>
<p>基本思路是首先将各模块独立地进行单元测试，然后将这些模块逐步组装成较大的系统，边组装边测试，以发现在组装时产生的错误，最终组装成一个符合要求的软件系统。</p>
<p>按照不同的次序实施，有下面两种测试策略：</p>
<ul>
<li><p>自顶向下增量式集成测试</p>
<p>该测试方法是按照程序结构图，首先利用桩模块测试主模块，通过测试后用实际的模块替代桩模块进行测试，重复以上步骤，直至替代了所有的桩模块。</p>
<p>在测试过程中，决定模块测试次序的基本原则如下：</p>
<p>（1）尽早测试关键的模块，即比较重要、比较复杂的可能出错或含有新算法的模块；</p>
<p>（2）尽早测试包含输入、输出功能的模块。</p>
</li>
<li><p>自底向上增量式集成测试</p>
<p>该测试方法是按照程序结构图，首先利用驱动模块测试最底层模块，通过测试后用实际的模块替代驱动模块进行测试，重复以上步骤，直至替代了所有的驱动模块。</p>
<p>在测试过程中，决定测试次序的基本原则是该模块的所有下级模块都被测试过了。</p>
</li>
</ul>
</li>
</ul>
<p>两种测试方法的比较：</p>
<p><img src="0.png" alt=""></p>
<h3 id="测试技术-1"><a href="#测试技术-1" class="headerlink" title="测试技术"></a>测试技术</h3><p>集成测试主要是测试软件的结构问题，因为测试建立在模块的接口上，所以多为<strong>黑盒测试</strong>，适当辅以白盒测试。</p>
<p>集成测试一般覆盖的区域包括以下几个：</p>
<ul>
<li>从其他关联模块调用一个模块；</li>
<li>在关联模块间正确传输数据；</li>
<li>关联模块间的互相影响；</li>
<li>模块间接口的可靠性。</li>
</ul>
<p>执行集合测试应遵循下面的方法：</p>
<p>（1）确认组成一个完整系统的模块之间的关系；</p>
<p>（2）评审模块之间的交互、通信需求，确认出模块间的接口；</p>
<p>（3）使用上述信息产生一套测试用例；</p>
<p>（4）采用增量式测试，直到所有模块被功能集成进来。</p>
<h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>系统测试是将经过良好的集成测试的软件系统作为整个计算机系统的一部分与计算机硬件、外部设备、支持软件、数据以及人员等其它系统元素结合在一起，在实际使用环境下对计算机系统进行一系列的严格测试，从而发现软件中的潜在缺陷。</p>
<p>系统测试的最终目的是保证开发人员交付给用户的软件产品能够满足用户的需求，系统测试的测试用例应在实际的用户使用环境下来执行。</p>
<h3 id="测试内容-2"><a href="#测试内容-2" class="headerlink" title="测试内容"></a>测试内容</h3><p>几类常用的系统测试：</p>
<ul>
<li><p>功能测试</p>
<p>也称确认测试，根据软件需求规格说明书来检验被测系统是否满足用户的功能使用要求。</p>
<p>功能测试是系统测试中最基本的测试。</p>
</li>
<li><p>性能测试</p>
<p>性能测试检测软件运行时的性能，为记录软件的运行性能，经常需要安装必要的测试仪表或软件。</p>
</li>
<li><p>强度测试</p>
<p>强度测试检查系统能力的最高实际限度，即软件在一些超负荷情况下的运行情况。</p>
</li>
<li><p>可靠性测试</p>
<p>通常使用几个指标来度量系统的可靠性：平均无故障时间是否超过规定的时限、因故障而停机的时间在一年中不应超过多少时间等。</p>
</li>
<li><p>恢复测试</p>
<p>主要目的是检查系统的容错能力，可以采用人工干预方式。如果系统本身能够自动恢复，则应检查重新初始化、数据恢复和重新启动等机制是否正确。</p>
</li>
<li><p>安装测试</p>
<p>目的是找出那些在安装过程中出现的错误，而不是软件故障。</p>
</li>
<li><p>安全性测试</p>
<p>目的在于检查系统对非法入侵的防范能力。</p>
<p>理论上说没有不可进入的系统，因此系统安全设计的准则是使非法入侵的代价超过被保护信息的价值。</p>
</li>
<li><p>配置测试</p>
<p>操作系统、数据库管理系统以及信息交换系统等都是在许多硬件配置支持下工作的，如何保证软件在其设计和连接的硬件上正常工作是配置测试的工作目标。配置测试是用各种硬件和软件平台以及不同设置检查软件操作的过程，以保证测试的软件可以使用尽可能多的硬件组合。</p>
</li>
<li><p>可用性测试</p>
<p>可用性测试检测用户对所使用软件是否满意，具体体现为操作是否方便、用户界面是否友好等。</p>
<p>优秀的用户界面包括下面 7 个要素：符合标准和规范、直观性、一致性、灵活性、舒适性、正确性、实用性。</p>
</li>
<li><p>兼容性测试</p>
<p>检测软件之间能否正确地交互和共享信息，它是用其他软件检查软件操作的过程。</p>
</li>
<li><p>网站测试</p>
<p>一般来说包括以下几方面：文字测试、链接测试、图形测试、表单测试、动态内容测试、数据库测试、服务器性能和加载测试、安全性测试。</p>
</li>
</ul>
<h3 id="测试技术-2"><a href="#测试技术-2" class="headerlink" title="测试技术"></a>测试技术</h3><p>完全采用<strong>黑盒测试技术</strong>。</p>
<h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>验收测试是一种合格性测试，也称<strong>确认测试</strong>，是以用户为主，软件开发人员、实施人员和质量保证人员共同参与的测试。验收测试让软件用户决定是否接受产品，是一项确定产品是否能够满足合同或用户所规定需求的测试。</p>
<h3 id="测试内容-3"><a href="#测试内容-3" class="headerlink" title="测试内容"></a>测试内容</h3><ul>
<li>明确规定验收测试通过的标准；</li>
<li>确定验收测试方法；</li>
<li>确定验收测试的组织和可利用的资源；</li>
<li>制订验收测试计划，并进行评审；</li>
<li>设计验收测试的测试用例；</li>
<li>执行验收测试；</li>
<li>分析测试结果，决定是否验收。</li>
</ul>
<h3 id="测试技术-3"><a href="#测试技术-3" class="headerlink" title="测试技术"></a>测试技术</h3><p>完全采用<strong>黑盒测试</strong>技术。</p>
<p>多采用称为 $\alpha,\beta$ 测试的过程。</p>
<ul>
<li><p>$\alpha$ 测试</p>
<p>对一个早期的、不稳定的软件版本你进行验收测试。</p>
</li>
<li><p>$\beta$ 测试</p>
<p>对一个晚期的、更加稳定的软件版本进行验收测试。</p>
</li>
</ul>
<h2 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>回归测试是指修改了旧代码后重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p>
<p>回归测试作为软件生命周期的组成部分，在整个软件测试过程中占有很大的比重，软件开发的各个阶段都会进行多次回归测试。</p>
<h3 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h3><p>为了高效进行回归测试，需要对测试用例库进行维护，并依据一定的策略，选择相应的回归测试包。</p>
<ul>
<li><p>测试用例库的维护</p>
<p>软件在其生命周期中会频繁地被修改和推出新版本，新版本软件会添加一些新的功能。</p>
<p>测试用例的维护包括以下方面：</p>
<p>（1）删除过时的测试用例；</p>
<p>（2）改进不受控制的测试用例，使其达到可重复和可控制的要求；</p>
<p>（3）删除冗余的测试用例；</p>
<p>（4）增添新的测试用例。</p>
</li>
<li><p>回归测试包的选择</p>
<p>软件生命周期中，即使一个得到良好维护的测试用例库也可能变得相当大，所以有时不得不选择一个缩减的回归测试包来完成测试。</p>
<p>常用的选择回归测试包的方式：</p>
<ul>
<li>再测试全部用例：比较安全，但成本最高。</li>
<li>基于风险选择测试：基于一定的风险标准优先运行最关键的、可疑的测试。</li>
<li>基于操作剖面选择测试</li>
<li>再测试修改的部分</li>
</ul>
</li>
</ul>
<h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><p>（1）识别出软件中被修改的过程；</p>
<p>（2）从原基线测试用例库 $T$ 中排除所有不再适用的测试用例，建立一个新的基线测试用例库 $T_0$；</p>
<p>（3）依据一定策略从  $T_0$ 中选择测试用例，测试被修改的软件；</p>
<p>（4）如果有必要，生成新的测试用例集  $T_1$，用于测试  $T_0$ 无法充分测试的软件部分。</p>
<h3 id="测试技术-4"><a href="#测试技术-4" class="headerlink" title="测试技术"></a>测试技术</h3><p>一般采用黑盒测试来测试软件的高级需求，也可能采用非功能测试来检查系统的增强或扩展是否影响了系统的性能特性，以及与其它系统间的互操作性和兼容性问题。</p>
<p>错误猜测在回归测试中是很重要的，主要来自于经验。</p>
<h2 id="敏捷测试"><a href="#敏捷测试" class="headerlink" title="敏捷测试"></a>敏捷测试</h2><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><p>敏捷开发的最大特点是高度迭代，有周期性，并且能够及时、持续地响应客户的频繁反馈。</p>
<p>敏捷测试即不断修正质量指标，正确建立测试策略，确认客户的有效需求得以实现。</p>
<p>敏捷测试是遵循敏捷宣言的一种测试实践。</p>
<p>（1）强调从客户的角度来测试系统；</p>
<p>（2）重点关注持续迭代地测试新开发的功能；</p>
<p>（3）尽早开始测试。</p>
<h3 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h3><p>测试驱动开发（Test-driven development,TDD）是一种软件开发过程中的应用方法，倡导先写测试程序，然后编码实现其功能。测试驱动开发的目的是取得快速反馈并使用“illustrate the main line”方法来构建程序。</p>
<p>带两顶帽子的开发方式：先戴上实现功能的帽子，在测试的辅助下快速实现其功能；再带上重构的帽子，在测试的保护下去除冗余代码。</p>
<p>基本思想是在开发功能代码之前先编写测试代码，然后只编写使测试通过的功能代码，从而以测试来驱使整个开发过程的进行。</p>
<p>测试驱动开发的基本过程如下：</p>
<p>（1）快速新增一个测试；</p>
<p>（2）运行所有的测试，发现新增的测试不能通过；</p>
<p>（3）做一些改动，尽快让测试程序可运行，为此可以在程序中使用一些不合情理的方法；</p>
<p>（4）运行所有测试，并且全部通过；</p>
<p>（5）重构代码，消除重复设计，优化设计结构。</p>
<h1 id="生命周期测试-amp-软件开发模型-amp-软件测试模型"><a href="#生命周期测试-amp-软件开发模型-amp-软件测试模型" class="headerlink" title="生命周期测试 &amp; 软件开发模型 &amp; 软件测试模型"></a>生命周期测试 &amp; 软件开发模型 &amp; 软件测试模型</h1><p><strong>在软件生命周期中，测试过程贯穿于软件开发生命周期的每个阶段。</strong></p>
<h2 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h2><ul>
<li>需求分析</li>
<li>设计</li>
<li>编码</li>
<li>测试</li>
<li>安装</li>
<li>维护</li>
</ul>
<h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。</p>
<p>理想化的瀑布模型如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190725130452991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pqdXd4eA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这是一种经典模型，提供了软件开发的基本框架，适合需求易于完善定义且不易变更的软件系统。</p>
<p>实际的瀑布模型是带“反馈环”的，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190725160647424.png" alt="img"></p>
<p>瀑布模型是文档驱动的模型，遵守这个约束可使软件维护变得容易一些，从而显著降低软件预算。</p>
<p>优点:</p>
<ul>
<li>各阶段划分清晰；</li>
<li>强调计划与需求分析；</li>
<li>适合需求稳定的产品开发。</li>
</ul>
<p>缺点:</p>
<ul>
<li>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；</li>
<li><p>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，增加了开发的风险；</p>
</li>
<li><p>早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果；</p>
</li>
<li>最终产品往往反映用户的初始需求而不是最终需求，不适合需求模糊或需求经常变动的系统；</li>
</ul>
<h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。</p>
<p>快速原型模型是增量模型的另一种形式，在开发真实系统之前，迅速建造一个可以运行的软件原型 ，以便理解和澄清问题，在该原型的基础上，逐渐完成整个系统的开发工作。</p>
<p><img src="https://img0.baidu.com/it/u=4002882172,1165672642&amp;fm=26&amp;fmt=auto" alt="img"></p>
<p>优点：</p>
<p>克服瀑布模型的切点，减少由于软件需求不明确带来的开发风险，互动性更高更容易了解客户需求。</p>
<p>缺点：</p>
<ul>
<li>所选用的开发技术和工具不一定符合主流的发展 ；</li>
<li>快速建立起来的系统结构加上连续的修改可能会导致产品质量低下。</li>
</ul>
<h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>使用增量模型开发软件时，把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能。</p>
<p>把软件产品分解成增量构件时，唯一必须遵守的约束条件是，当把新构件集成到现有构件中时，所形成的产品必须是可测试的。</p>
<p><img src="https://wiki.mbalib.com/w/images/d/d0/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B.jpg" alt="增量模型"></p>
<p>适合技术风险较大、用户需求较稳定的软件系统。</p>
<h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>螺旋模型最大的特点在于引入了其他模型不具备的<strong>风险分析</strong>，使软件在无法排除重大风险时有机会停止，以减小损失。</p>
<p>螺旋模型是快速原型模型以进化的开发方式为中心，在每个项目阶段使用瀑布模型法。该模型的每一个周期都包括需求定义、风险分析、工程实现和评审 4 个阶段，由这 4 个阶段进行迭代。</p>
<p>简化的螺旋模型：</p>
<p><img src="https://img-blog.csdnimg.cn/20190726102921612.png" alt="img"></p>
<p>适合需求难以获取和确定、软件开发风险较大的软件系统。</p>
<h2 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h2><h3 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h3><p>$V$ 模型是在瀑布模型的基础上发展而来的，如下图所示：</p>
<p><img src="3.png" alt=""></p>
<p>在软件编码完成前，系统测试用例、软件测试用例以及单元测试用例已经完成。</p>
<p>优点：</p>
<ul>
<li>$V$ 模型开发流程将代码实现放在最后一步，即使客户需求发生变更也能很快做出修改，相比瀑布模型减少了回溯的成本和时间；</li>
<li>明确标注了测试过程中存在不同的测试类型，明确表示出了开发阶段与测试各阶段的对应关系。</li>
</ul>
<p>缺点：虽然测试尽早的进入到开发阶段，但是真正进行软件测试是在编码之后，这样忽视了测试对需求分析，系统设计的验证，时间效率上也大打折扣。</p>
<h3 id="W-模型"><a href="#W-模型" class="headerlink" title="W 模型"></a>W 模型</h3><p>又称双 V 模型，它由 V 模型演变而来，弥补了 V 模型的不足。左边的 V 是开发的生命周期，右边的 V 是测试的生命周期。</p>
<p><img src="https://img0.baidu.com/it/u=3561836809,2244645606&amp;fm=26&amp;fmt=auto" alt="img"></p>
<p>单元测试依据详细设计说明书；</p>
<p>集成测试依据概要设计说明书；</p>
<p>系统测试依据需求规格说明书。</p>
<p>优点：测试与开发是同步进行的，从而有利于尽早地发现问题。</p>
<p>缺点：$W$ 模型是顺序性的，不可逆，需求的变更和调整，依旧不方便。</p>
<h3 id="H-模型"><a href="#H-模型" class="headerlink" title="H 模型"></a>H 模型</h3><p>在 $H$ 模型中，软件测试过程活动完全独立，贯穿于整个产品的周期，与其他流程并发地进行。</p>
<p>某个测试点准备就绪时，就可以从测试准备阶段进行到测试执行阶段。</p>
<p>软件测试可以尽早进行。</p>
<p><img src="https://img1.baidu.com/it/u=1514273074,3801459989&amp;fm=26&amp;fmt=auto" alt="img"></p>
<h3 id="X-模型"><a href="#X-模型" class="headerlink" title="X 模型"></a>X 模型</h3><p>$X$ 模型也是对 V 模型的改进。</p>
<p><img src="4.png" alt=""></p>
<p>$X$ 模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成，最终成为可执行的程序，然后再对这些可执行程序进行测试。己通过集成测试的成品可以进行封装并提交给用户，也可以作为更大规模和范围内集成的一部分。</p>
<p>多根并行的曲线表示变更可以在各个部分发生。</p>
<p><strong>参考资料：</strong></p>
<p>[1] 秦航，杨强 . 软件质量保证与测试(第 2 版)[M] . 北京：清华大学出版社，2017</p>
<p>[2] 赖均，陶春梅，刘兆宏，胡峰 . 软件工程[M] . 北京：清华大学出版社，2016</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ave Bai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://10185102110.github.io/2021/09/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/">http://10185102110.github.io/2021/09/20/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://10185102110.github.io" target="_blank">浮生孰来</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a></div><div class="post_share"><div class="social-share" data-image="/img/default/0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/20/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/"><img class="prev-cover" src="/img/default/14.jpg" onerror="onerror=null;src='/img/default.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">黑盒测试</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/17/SpringBoot%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"><img class="next-cover" src="/img/default/9.jpg" onerror="onerror=null;src='/img/default.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot相关原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/10/APP自动化环境配置/" title="APP自动化环境配置"><img class="cover" src="/img/default/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-10</div><div class="title">APP自动化环境配置</div></div></a></div><div><a href="/2023/04/08/APP抓包配置/" title="APP抓包配置"><img class="cover" src="/img/default/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-08</div><div class="title">APP抓包配置</div></div></a></div><div><a href="/2023/09/18/Docker驱动selenium-grid-4实现分布式测试/" title="Docker驱动Selenium-grid实现分布式测试"><img class="cover" src="/img/default/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-18</div><div class="title">Docker驱动Selenium-grid实现分布式测试</div></div></a></div><div><a href="/2023/05/16/JMeter压力测试方案/" title="JMeter压力测试方案"><img class="cover" src="/img/default/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">JMeter压力测试方案</div></div></a></div><div><a href="/2021/10/26/JMeter 实践/" title="JMeter实践"><img class="cover" src="/img/default/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-26</div><div class="title">JMeter实践</div></div></a></div><div><a href="/2021/10/20/fiddler抓包/" title="Fiddler抓包"><img class="cover" src="/img/default/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-20</div><div class="title">Fiddler抓包</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">什么是软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">软件特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.</span> <span class="toc-text">软件测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.4.</span> <span class="toc-text">专业术语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95-1"><span class="toc-number">2.</span> <span class="toc-text">软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">2.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-number">2.2.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">软件测试的种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.4.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9"><span class="toc-number">2.4.2.</span> <span class="toc-text">测试内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">2.4.4.</span> <span class="toc-text">测试技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">2.5.</span> <span class="toc-text">集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">测试内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF-1"><span class="toc-number">2.5.4.</span> <span class="toc-text">测试技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">2.6.</span> <span class="toc-text">系统测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">2.6.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9-2"><span class="toc-number">2.6.2.</span> <span class="toc-text">测试内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF-2"><span class="toc-number">2.6.3.</span> <span class="toc-text">测试技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">2.7.</span> <span class="toc-text">验收测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">2.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9-3"><span class="toc-number">2.7.2.</span> <span class="toc-text">测试内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF-3"><span class="toc-number">2.7.3.</span> <span class="toc-text">测试技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95"><span class="toc-number">2.8.</span> <span class="toc-text">回归测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">2.8.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-number">2.8.2.</span> <span class="toc-text">测试策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-number">2.8.3.</span> <span class="toc-text">测试过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF-4"><span class="toc-number">2.8.4.</span> <span class="toc-text">测试技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E6%B5%8B%E8%AF%95"><span class="toc-number">2.9.</span> <span class="toc-text">敏捷测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91"><span class="toc-number">2.9.1.</span> <span class="toc-text">敏捷开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">2.9.2.</span> <span class="toc-text">测试驱动开发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%8B%E8%AF%95-amp-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B-amp-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">生命周期测试 &amp; 软件开发模型 &amp; 软件测试模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.1.</span> <span class="toc-text">软件开发生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">软件开发模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">瀑布模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">快速原型模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">增量模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">螺旋模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">软件测试模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#V-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">V 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#W-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">W 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">H 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#X-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.4.</span> <span class="toc-text">X 模型</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default/0.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Ave Bai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    loader: {
      source: {
        '[tex]/amsCd': '[tex]/amscd'
      }
    },
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        addClass: [200,() => {
          document.querySelectorAll('mjx-container:not([display=\'true\']').forEach( node => {
            const target = node.parentNode
            if (!target.classList.contains('has-jax')) {
              target.classList.add('mathjax-overflow')
            }
          })
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>